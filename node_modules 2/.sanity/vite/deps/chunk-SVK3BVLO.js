import {
  require_hashlru,
  require_json_inspector
} from "./chunk-6VVT4PHY.js";
import {
  AddCircleIcon,
  AddCommentIcon,
  AddIcon,
  AddonDatasetProvider,
  AnimatePresence,
  ArrowLeftIcon,
  Avatar,
  AvatarStack,
  Badge,
  BetaBadge,
  BoundaryElementProvider,
  Box,
  Button,
  Button2,
  CalendarIcon,
  Card,
  ChangeConnectorRoot,
  ChangeFieldWrapper,
  ChangeList,
  Checkbox,
  CheckmarkCircleIcon,
  CheckmarkIcon,
  ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  CircleIcon,
  CloseIcon,
  Code,
  CommandList,
  CommentIcon,
  ConditionalWrapper,
  Container,
  ContextMenuButton,
  CopyIcon,
  DEFAULT_DATE_FORMAT,
  DEFAULT_STUDIO_CLIENT_OPTIONS,
  DIFF_DELETE,
  DIFF_EQUAL,
  DIFF_INSERT,
  DatePicker,
  Dialog,
  Dialog2,
  DialogProvider,
  DiffTooltip,
  DocumentChangeContext,
  DocumentIcon,
  DocumentPreviewPresence,
  DocumentStatus,
  DocumentStatusIndicator,
  DocumentsIcon,
  DoubleChevronRightIcon,
  EMPTY_ARRAY$b,
  EMPTY_OBJECT,
  EarthAmericasIcon,
  EditIcon,
  ErrorBoundary,
  ErrorOutlineIcon,
  FieldActionsProvider,
  FieldActionsResolver,
  Flex,
  FolderIcon,
  FormBuilder,
  FormFieldHeaderText,
  GetHookCollectionState,
  Grid,
  Heading,
  Hotkeys,
  InfoOutlineIcon,
  Inline,
  InsufficientPermissionsMessage,
  IntentLink,
  JsonIcon,
  LaunchIcon,
  Layer,
  LayerProvider,
  LegacyLayerProvider,
  LinkIcon,
  LinkRemovedIcon,
  LoadingBlock,
  MasterDetailIcon,
  Menu,
  MenuButton,
  MenuDivider,
  MenuGroup,
  MenuItem,
  MenuItem2,
  NoChanges,
  PanelRightIcon,
  Popover,
  Popover2,
  PortableText,
  PortableTextEditable,
  PortableTextEditor,
  PortalProvider,
  PresenceOverlay,
  PreviewCard,
  PublishIcon,
  ReadOnlyIcon,
  ReferenceInputOptionsProvider,
  ResetIcon,
  ResourceCacheProvider,
  RestoreIcon,
  SanityDefaultPreview,
  Schema,
  ScrollContainer,
  SearchIcon,
  SearchPopover,
  SearchProvider,
  SearchResultItemPreview,
  Skeleton,
  SortIcon,
  SourceProvider,
  Spinner,
  SpinnerIcon,
  SplitVerticalIcon,
  Stack,
  StackCompactIcon,
  StackIcon,
  StateLink,
  StatusButton,
  Switch,
  SyncIcon,
  Tab,
  TabList,
  TabPanel,
  TaskIcon,
  Text,
  TextInput,
  TextSkeleton,
  TextWithTone,
  ThemeColorProvider,
  Tooltip2 as Tooltip,
  TooltipDelayGroupProvider,
  TooltipOfDisabled,
  TransformPatches,
  Translate,
  TrashIcon,
  UndoIcon,
  UnknownIcon,
  UnpublishIcon,
  UpsellDescriptionSerializer,
  UpsellDialogDismissed,
  UpsellDialogLearnMoreCtaClicked,
  UpsellDialogUpgradeCtaClicked,
  UpsellDialogViewed,
  UserAvatar,
  UserIcon,
  VirtualizerScrollInstanceProvider,
  WarningOutlineIcon,
  WorkspaceLoaderBoundary,
  WorkspaceProvider,
  _raf2,
  apply,
  applyPatch,
  at,
  cleanupEfficiency,
  collate,
  createHookFromObservableFactory,
  createPatchChannel,
  createSearch,
  decodeJsonParams,
  defaultKeyGenerator,
  defineArrayMember,
  defineDocumentInspector,
  defineEvent,
  defineField,
  defineLocaleResourceBundle,
  definePlugin,
  defineType,
  diff,
  e,
  encodeJsonParams,
  es2015_default,
  exhaustMapWithTrailing,
  focusFirstDescendant,
  focusLastDescendant,
  format,
  fromMutationPatches,
  fromString,
  generateHelpUrl,
  get,
  getCalendarLabels,
  getConfigContextFromSource,
  getDraftId,
  getExpandOperations,
  getJsonStream,
  getPreviewStateObservable,
  getPreviewValueWithFallback,
  getPublishedId,
  getSchemaTypeTitle,
  getSearchableTypes,
  getTheme_v2,
  getValueAtPath,
  ht,
  hues,
  isActionEnabled,
  isArray,
  isArrayOfBlocksSchemaType,
  isArraySchemaType,
  isDeprecatedSchemaType,
  isDev,
  isImageSource,
  isIndexSegment,
  isKeySegment,
  isObjectSchemaType,
  isPortableTextSpan,
  isPortableTextTextBlock,
  isRecord$4,
  isReferenceSchemaType,
  isSanityDocument,
  isString,
  isThisISOWeek,
  isToday,
  isValidationError,
  isValidationErrorMarker,
  isValidationWarning,
  make,
  motion,
  parse,
  prepareConfig,
  rem,
  require_apply,
  require_baseGetTag,
  require_basePropertyOf,
  require_baseRest,
  require_baseValues,
  require_capitalize,
  require_copyObject,
  require_createAssigner,
  require_createCompounder,
  require_debounce,
  require_deburr,
  require_eq,
  require_find,
  require_findIndex,
  require_image_url_umd,
  require_isEqual,
  require_isIterateeCall,
  require_isObjectLike,
  require_isPlainObject,
  require_isString,
  require_keys,
  require_keysIn,
  require_lib,
  require_negate,
  require_omit,
  require_orderBy,
  require_react_fast_compare,
  require_react_is,
  require_shallow_equals,
  require_speakingurl,
  require_startCase,
  require_throttle,
  require_toString,
  require_uniq,
  require_uniqBy,
  require_uniqueId,
  resizeObserver,
  resolveConditionalProperty,
  resolveKeyedPath,
  rgba,
  route,
  set,
  setAtPath,
  toMutationPatches,
  toPlainText,
  toString,
  unset,
  useAddonDataset,
  useAsObservable,
  useBoundaryElement,
  useClickOutside,
  useClient,
  useConfigContextFromSource,
  useConnectionState,
  useCurrentUser,
  useDateTimeFormat,
  useDidUpdate,
  useDocumentOperation,
  useDocumentOperationEvent,
  useDocumentPairPermissions,
  useDocumentPresence,
  useDocumentPreview,
  useDocumentPreviewStore,
  useDocumentStore,
  useDocumentType,
  useDocumentValuePermissions,
  useEditState,
  useElementRect,
  useFeatureEnabled,
  useFieldActions,
  useFormState,
  useFormValue,
  useForwardedRef,
  useGetI18nText,
  useGlobalKeyDown,
  useI18nText,
  useInitialValue,
  useIntentLink,
  useKeyValueStore,
  useLayer,
  useListFormat,
  useMediaIndex,
  useMemoObservable,
  useMiddlewareComponents,
  useObservableCallback,
  usePortableTextEditor,
  usePortableTextEditorSelection,
  usePortal,
  usePresenceStore,
  useProjectId,
  useRelativeTime,
  useRouter,
  useRouterState,
  useSchema,
  useSearchMaxFieldDepth,
  useSource,
  useSyncState,
  useTelemetry,
  useTemplatePermissions,
  useTemplates,
  useTimelineSelector,
  useTimelineStore,
  useToast,
  useTools,
  useTranslation,
  useTranslation2,
  useUnique,
  useUser,
  useUserListWithPermissions,
  useValidationStatus,
  useWorkspace,
  useWorkspaceLoader,
  useZIndex,
  ut,
  v4_default,
  visitDiff,
  white
} from "./chunk-2AVBTOUO.js";
import {
  require_jsx_runtime
} from "./chunk-W7O3NKM5.js";
import {
  require_react
} from "./chunk-Z7L3MLVS.js";
import {
  EMPTY,
  Subject,
  asyncScheduler,
  catchError,
  concat,
  debounce,
  debounceTime,
  defer,
  delay,
  distinctUntilChanged,
  filter,
  firstValueFrom,
  from,
  fromEvent,
  map,
  mapTo,
  merge,
  mergeMap,
  of,
  partition,
  scan,
  share,
  shareReplay,
  startWith,
  switchMap,
  take,
  tap,
  throttleTime,
  throwError,
  timer
} from "./chunk-OBAQCMH7.js";
import {
  __commonJS,
  __toESM
} from "./chunk-AUZ3RYOM.js";

// node_modules/lodash/assignInWith.js
var require_assignInWith = __commonJS({
  "node_modules/lodash/assignInWith.js"(exports, module) {
    var copyObject = require_copyObject();
    var createAssigner = require_createAssigner();
    var keysIn = require_keysIn();
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });
    module.exports = assignInWith;
  }
});

// node_modules/lodash/isError.js
var require_isError = __commonJS({
  "node_modules/lodash/isError.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var isPlainObject = require_isPlainObject();
    var domExcTag = "[object DOMException]";
    var errorTag = "[object Error]";
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
    }
    module.exports = isError;
  }
});

// node_modules/lodash/attempt.js
var require_attempt = __commonJS({
  "node_modules/lodash/attempt.js"(exports, module) {
    var apply2 = require_apply();
    var baseRest = require_baseRest();
    var isError = require_isError();
    var attempt = baseRest(function(func, args) {
      try {
        return apply2(func, void 0, args);
      } catch (e2) {
        return isError(e2) ? e2 : new Error(e2);
      }
    });
    module.exports = attempt;
  }
});

// node_modules/lodash/_customDefaultsAssignIn.js
var require_customDefaultsAssignIn = __commonJS({
  "node_modules/lodash/_customDefaultsAssignIn.js"(exports, module) {
    var eq = require_eq();
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === void 0 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
        return srcValue;
      }
      return objValue;
    }
    module.exports = customDefaultsAssignIn;
  }
});

// node_modules/lodash/_escapeStringChar.js
var require_escapeStringChar = __commonJS({
  "node_modules/lodash/_escapeStringChar.js"(exports, module) {
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    module.exports = escapeStringChar;
  }
});

// node_modules/lodash/_reInterpolate.js
var require_reInterpolate = __commonJS({
  "node_modules/lodash/_reInterpolate.js"(exports, module) {
    var reInterpolate = /<%=([\s\S]+?)%>/g;
    module.exports = reInterpolate;
  }
});

// node_modules/lodash/_escapeHtmlChar.js
var require_escapeHtmlChar = __commonJS({
  "node_modules/lodash/_escapeHtmlChar.js"(exports, module) {
    var basePropertyOf = require_basePropertyOf();
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    module.exports = escapeHtmlChar;
  }
});

// node_modules/lodash/escape.js
var require_escape = __commonJS({
  "node_modules/lodash/escape.js"(exports, module) {
    var escapeHtmlChar = require_escapeHtmlChar();
    var toString2 = require_toString();
    var reUnescapedHtml = /[&<>"']/g;
    var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    function escape(string) {
      string = toString2(string);
      return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
    }
    module.exports = escape;
  }
});

// node_modules/lodash/_reEscape.js
var require_reEscape = __commonJS({
  "node_modules/lodash/_reEscape.js"(exports, module) {
    var reEscape = /<%-([\s\S]+?)%>/g;
    module.exports = reEscape;
  }
});

// node_modules/lodash/_reEvaluate.js
var require_reEvaluate = __commonJS({
  "node_modules/lodash/_reEvaluate.js"(exports, module) {
    var reEvaluate = /<%([\s\S]+?)%>/g;
    module.exports = reEvaluate;
  }
});

// node_modules/lodash/templateSettings.js
var require_templateSettings = __commonJS({
  "node_modules/lodash/templateSettings.js"(exports, module) {
    var escape = require_escape();
    var reEscape = require_reEscape();
    var reEvaluate = require_reEvaluate();
    var reInterpolate = require_reInterpolate();
    var templateSettings = {
      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      "escape": reEscape,
      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      "evaluate": reEvaluate,
      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      "interpolate": reInterpolate,
      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      "variable": "",
      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      "imports": {
        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        "_": { "escape": escape }
      }
    };
    module.exports = templateSettings;
  }
});

// node_modules/lodash/template.js
var require_template = __commonJS({
  "node_modules/lodash/template.js"(exports, module) {
    var assignInWith = require_assignInWith();
    var attempt = require_attempt();
    var baseValues = require_baseValues();
    var customDefaultsAssignIn = require_customDefaultsAssignIn();
    var escapeStringChar = require_escapeStringChar();
    var isError = require_isError();
    var isIterateeCall = require_isIterateeCall();
    var keys = require_keys();
    var reInterpolate = require_reInterpolate();
    var templateSettings = require_templateSettings();
    var toString2 = require_toString();
    var INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var reEmptyStringLeading = /\b__p \+= '';/g;
    var reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
    var reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    function template2(string, options, guard) {
      var settings = templateSettings.imports._.templateSettings || templateSettings;
      if (guard && isIterateeCall(string, options, guard)) {
        options = void 0;
      }
      string = toString2(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);
      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
      var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
        "g"
      );
      var sourceURL = hasOwnProperty.call(options, "sourceURL") ? "//# sourceURL=" + (options.sourceURL + "").replace(/\s/g, " ") + "\n" : "";
      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;
        return match;
      });
      source += "';\n";
      var variable = hasOwnProperty.call(options, "variable") && options.variable;
      if (!variable) {
        source = "with (obj) {\n" + source + "\n}\n";
      } else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }
      source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
      source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
      var result = attempt(function() {
        return Function(importsKeys, sourceURL + "return " + source).apply(void 0, importsValues);
      });
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }
    module.exports = template2;
  }
});

// node_modules/lodash/isNumber.js
var require_isNumber = __commonJS({
  "node_modules/lodash/isNumber.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var numberTag = "[object Number]";
    function isNumber2(value) {
      return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
    }
    module.exports = isNumber2;
  }
});

// node_modules/lodash/camelCase.js
var require_camelCase = __commonJS({
  "node_modules/lodash/camelCase.js"(exports, module) {
    var capitalize = require_capitalize();
    var createCompounder = require_createCompounder();
    var camelCase2 = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    module.exports = camelCase2;
  }
});

// node_modules/lodash/kebabCase.js
var require_kebabCase = __commonJS({
  "node_modules/lodash/kebabCase.js"(exports, module) {
    var createCompounder = require_createCompounder();
    var kebabCase2 = createCompounder(function(result, word, index) {
      return result + (index ? "-" : "") + word.toLowerCase();
    });
    module.exports = kebabCase2;
  }
});

// node_modules/toggle-selection/index.js
var require_toggle_selection = __commonJS({
  "node_modules/toggle-selection/index.js"(exports, module) {
    module.exports = function() {
      var selection = document.getSelection();
      if (!selection.rangeCount) {
        return function() {
        };
      }
      var active = document.activeElement;
      var ranges = [];
      for (var i = 0; i < selection.rangeCount; i++) {
        ranges.push(selection.getRangeAt(i));
      }
      switch (active.tagName.toUpperCase()) {
        case "INPUT":
        case "TEXTAREA":
          active.blur();
          break;
        default:
          active = null;
          break;
      }
      selection.removeAllRanges();
      return function() {
        selection.type === "Caret" && selection.removeAllRanges();
        if (!selection.rangeCount) {
          ranges.forEach(function(range) {
            selection.addRange(range);
          });
        }
        active && active.focus();
      };
    };
  }
});

// node_modules/copy-to-clipboard/index.js
var require_copy_to_clipboard = __commonJS({
  "node_modules/copy-to-clipboard/index.js"(exports, module) {
    "use strict";
    var deselectCurrent = require_toggle_selection();
    var clipboardToIE11Formatting = {
      "text/plain": "Text",
      "text/html": "Url",
      "default": "Text"
    };
    var defaultMessage = "Copy to clipboard: #{key}, Enter";
    function format2(message) {
      var copyKey = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
      return message.replace(/#{\s*key\s*}/g, copyKey);
    }
    function copy(text, options) {
      var debug, message, reselectPrevious, range, selection, mark, success = false;
      if (!options) {
        options = {};
      }
      debug = options.debug || false;
      try {
        reselectPrevious = deselectCurrent();
        range = document.createRange();
        selection = document.getSelection();
        mark = document.createElement("span");
        mark.textContent = text;
        mark.ariaHidden = "true";
        mark.style.all = "unset";
        mark.style.position = "fixed";
        mark.style.top = 0;
        mark.style.clip = "rect(0, 0, 0, 0)";
        mark.style.whiteSpace = "pre";
        mark.style.webkitUserSelect = "text";
        mark.style.MozUserSelect = "text";
        mark.style.msUserSelect = "text";
        mark.style.userSelect = "text";
        mark.addEventListener("copy", function(e2) {
          e2.stopPropagation();
          if (options.format) {
            e2.preventDefault();
            if (typeof e2.clipboardData === "undefined") {
              debug && console.warn("unable to use e.clipboardData");
              debug && console.warn("trying IE specific stuff");
              window.clipboardData.clearData();
              var format3 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
              window.clipboardData.setData(format3, text);
            } else {
              e2.clipboardData.clearData();
              e2.clipboardData.setData(options.format, text);
            }
          }
          if (options.onCopy) {
            e2.preventDefault();
            options.onCopy(e2.clipboardData);
          }
        });
        document.body.appendChild(mark);
        range.selectNodeContents(mark);
        selection.addRange(range);
        var successful = document.execCommand("copy");
        if (!successful) {
          throw new Error("copy command was unsuccessful");
        }
        success = true;
      } catch (err) {
        debug && console.error("unable to copy using execCommand: ", err);
        debug && console.warn("trying IE specific stuff");
        try {
          window.clipboardData.setData(options.format || "text", text);
          options.onCopy && options.onCopy(window.clipboardData);
          success = true;
        } catch (err2) {
          debug && console.error("unable to copy using clipboardData: ", err2);
          debug && console.error("falling back to prompt");
          message = format2("message" in options ? options.message : defaultMessage);
          window.prompt(message, text);
        }
      } finally {
        if (selection) {
          if (typeof selection.removeRange == "function") {
            selection.removeRange(range);
          } else {
            selection.removeAllRanges();
          }
        }
        if (mark) {
          document.body.removeChild(mark);
        }
        reselectPrevious();
      }
      return success;
    }
    module.exports = copy;
  }
});

// node_modules/react-copy-to-clipboard/lib/Component.js
var require_Component = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/Component.js"(exports) {
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CopyToClipboard = void 0;
    var _react = _interopRequireDefault(require_react());
    var _copyToClipboard = _interopRequireDefault(require_copy_to_clipboard());
    var _excluded = ["text", "onCopy", "options", "children"];
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _objectWithoutProperties(source, excluded) {
      if (source == null)
        return {};
      var target = _objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0)
            continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key))
            continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e2) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var CopyToClipboard2 = function(_React$PureComponent) {
      _inherits(CopyToClipboard3, _React$PureComponent);
      var _super = _createSuper(CopyToClipboard3);
      function CopyToClipboard3() {
        var _this;
        _classCallCheck(this, CopyToClipboard3);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized(_this), "onClick", function(event) {
          var _this$props = _this.props, text = _this$props.text, onCopy = _this$props.onCopy, children = _this$props.children, options = _this$props.options;
          var elem = _react["default"].Children.only(children);
          var result = (0, _copyToClipboard["default"])(text, options);
          if (onCopy) {
            onCopy(text, result);
          }
          if (elem && elem.props && typeof elem.props.onClick === "function") {
            elem.props.onClick(event);
          }
        });
        return _this;
      }
      _createClass(CopyToClipboard3, [{
        key: "render",
        value: function render() {
          var _this$props2 = this.props, _text = _this$props2.text, _onCopy = _this$props2.onCopy, _options = _this$props2.options, children = _this$props2.children, props = _objectWithoutProperties(_this$props2, _excluded);
          var elem = _react["default"].Children.only(children);
          return _react["default"].cloneElement(elem, _objectSpread(_objectSpread({}, props), {}, {
            onClick: this.onClick
          }));
        }
      }]);
      return CopyToClipboard3;
    }(_react["default"].PureComponent);
    exports.CopyToClipboard = CopyToClipboard2;
    _defineProperty(CopyToClipboard2, "defaultProps", {
      onCopy: void 0,
      options: void 0
    });
  }
});

// node_modules/react-copy-to-clipboard/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/react-copy-to-clipboard/lib/index.js"(exports, module) {
    "use strict";
    var _require = require_Component();
    var CopyToClipboard2 = _require.CopyToClipboard;
    CopyToClipboard2.CopyToClipboard = CopyToClipboard2;
    module.exports = CopyToClipboard2;
  }
});

// node_modules/sanity/lib/_chunks/StructureToolProvider-CK141bsB.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var React = __toESM(require_react());
var import_react2 = __toESM(require_react());
var import_orderBy = __toESM(require_orderBy());
var import_isEqual2 = __toESM(require_isEqual());
var import_template = __toESM(require_template());
var import_deburr = __toESM(require_deburr());
var import_react_copy_to_clipboard = __toESM(require_lib2());
var import_isNumber = __toESM(require_isNumber());
var import_isString = __toESM(require_isString());
var import_omit = __toESM(require_omit());
var import_uniqBy = __toESM(require_uniqBy());
var import_negate = __toESM(require_negate());
var import_throttle2 = __toESM(require_throttle());
var import_findIndex = __toESM(require_findIndex());
var import_is_hotkey = __toESM(require_lib());
var import_react_json_inspector = __toESM(require_json_inspector());
var import_hashlru = __toESM(require_hashlru());
var import_shallow_equals = __toESM(require_shallow_equals());

// node_modules/sanity/lib/_internalBrowser.esm.js
var import_isEqual = __toESM(require_isEqual());
var import_react = __toESM(require_react());
var import_throttle = __toESM(require_throttle());

// node_modules/sanity/lib/_chunks/StructureToolProvider-CK141bsB.js
var import_camelCase = __toESM(require_camelCase());
var import_speakingurl = __toESM(require_speakingurl());
var import_uniqueId = __toESM(require_uniqueId());
var import_react_is = __toESM(require_react_is());
var import_uniq = __toESM(require_uniq());
var import_kebabCase = __toESM(require_kebabCase());
var import_find = __toESM(require_find());
var import_startCase = __toESM(require_startCase());
var import_image_url = __toESM(require_image_url_umd());
var import_react_fast_compare = __toESM(require_react_fast_compare());
var import_debounce = __toESM(require_debounce());
var commentsLocaleNamespace = "comments";
var commentsUsEnglishLocaleBundle = defineLocaleResourceBundle({ locale: "en-US", namespace: commentsLocaleNamespace, resources: () => import("./resources-C_zJRKZ5-55VPSHDM.js") });
var DOCUMENT_PANEL_MIN_WIDTH = 320;
var DOCUMENT_PANEL_INITIAL_MIN_WIDTH = 600;
var DOCUMENT_INSPECTOR_MIN_WIDTH = 320;
var DOCUMENT_INSPECTOR_MAX_WIDTH = 540;
var EMPTY_PARAMS$2 = {};
var INSPECT_ACTION_PREFIX = "inspect:";
var DEFAULT_MENU_ITEM_GROUPS = [{ id: "inspectors" }, { id: "links" }];
var HISTORY_INSPECTOR_NAME = "sanity/structure/history";
var VALIDATION_INSPECTOR_NAME = "sanity/structure/validation";
var COMMENTS_INSPECTOR_NAME = "sanity/structure/comments";
var separator = (0, import_jsx_runtime.jsx)(Text, { muted: true, children: (0, import_jsx_runtime.jsx)(ChevronRightIcon, {}) });
var renderItem = (item, index) => {
  return (0, import_jsx_runtime.jsx)(Box, { as: "li", children: (0, import_jsx_runtime.jsx)(Text, { textOverflow: "ellipsis", size: 1, weight: "medium", children: item }) }, "".concat(item, "-").concat(index));
};
function CommentBreadcrumbs(props) {
  const { titlePath, maxLength } = props;
  const items = (0, import_react2.useMemo)(() => {
    const len = titlePath.length;
    const beforeLength = Math.ceil(maxLength / 2);
    const afterLength = Math.floor(maxLength / 2);
    if (maxLength && len > maxLength) {
      return [...titlePath.slice(0, beforeLength - 1), titlePath.slice(beforeLength - 1, len - afterLength), ...titlePath.slice(len - afterLength)];
    }
    return titlePath;
  }, [maxLength, titlePath]);
  const nodes = (0, import_react2.useMemo)(() => {
    return items.map((item, index) => {
      const key = "".concat(item, "-").concat(index);
      const showSeparator = index < items.length - 1;
      if (Array.isArray(item)) {
        return (0, import_jsx_runtime.jsxs)(import_react2.Fragment, { children: [(0, import_jsx_runtime.jsx)(Tooltip, { content: (0, import_jsx_runtime.jsx)(Stack, { space: 2, padding: 2, children: item.map(renderItem) }), children: (0, import_jsx_runtime.jsx)(Box, { children: renderItem("...", index) }) }), showSeparator && separator] }, key);
      }
      return (0, import_jsx_runtime.jsxs)(import_react2.Fragment, { children: [renderItem(item, index), showSeparator && separator] }, key);
    });
  }, [items]);
  return (0, import_jsx_runtime.jsx)(Flex, { align: "center", as: "ol", gap: 2, children: nodes });
}
function getDialogCopy(t) {
  return { thread: { title: t("delete-thread.title"), body: t("delete-thread.body"), confirmButtonText: t("delete-thread.confirm") }, comment: { title: t("delete-comment.title"), body: t("delete-comment.body"), confirmButtonText: t("delete-comment.confirm") } };
}
function CommentDeleteDialog(props) {
  const { isParent, onClose, commentId, onConfirm, loading, error } = props;
  const { t } = useTranslation2(commentsLocaleNamespace);
  const dialogCopy = getDialogCopy(t);
  const { title, body, confirmButtonText } = dialogCopy[isParent ? "thread" : "comment"];
  const handleDelete = (0, import_react2.useCallback)(() => {
    onConfirm(commentId);
  }, [commentId, onConfirm]);
  return (0, import_jsx_runtime.jsx)(Dialog2, { footer: { cancelButton: { onClick: onClose }, confirmButton: { loading, onClick: handleDelete, text: confirmButtonText, tone: "critical" } }, header: title, id: "delete-comment-dialog", onClose, width: 0, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 4, children: [(0, import_jsx_runtime.jsx)(Text, { size: 1, children: body }), error && (0, import_jsx_runtime.jsx)(TextWithTone, { tone: "critical", children: t("delete-dialog.error") })] }) });
}
var CommentDisabledIcon = (0, import_react2.forwardRef)(function Icon(props, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", { "data-sanity-icon": "comment-disabled", width: "1em", height: "1em", ref, viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [(0, import_jsx_runtime.jsx)("path", { d: "M5.92627 14.5381H7.92627V18.5381L11.9263 14.5381H15.9263C17.0308 14.5381 17.9263 13.6427 17.9263 12.5381V6.53809C17.9263 5.43352 17.0308 4.53809 15.9263 4.53809H5.92627C4.8217 4.53809 3.92627 5.43352 3.92627 6.53809V12.5381C3.92627 13.6427 4.8217 14.5381 5.92627 14.5381Z", stroke: "currentColor", strokeWidth: "1.2", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M2.77256 2.66835C2.54413 2.51319 2.23317 2.57259 2.07802 2.80103L1.40378 3.7937C1.32927 3.9034 1.30139 4.0382 1.32627 4.16845C1.35115 4.29871 1.42676 4.41374 1.53646 4.48825L19.5861 16.7479C19.8146 16.903 20.1255 16.8436 20.2807 16.6152L20.9549 15.6225C21.0294 15.5128 21.0573 15.378 21.0324 15.2478C21.0076 15.1175 20.9319 15.0025 20.8222 14.928L2.77256 2.66835Z", fill: "currentColor", strokeLinejoin: "round" })] });
});
var CommentIcon2 = (0, import_react2.forwardRef)(function Icon2(props, ref) {
  return (0, import_jsx_runtime.jsx)("svg", { "data-sanity-icon": "comment", width: "1em", height: "1em", ref, viewBox: "0 0 25 25", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime.jsx)("path", { d: "M7.5 15.5H9.5V19.5L13.5 15.5H17.5C18.6046 15.5 19.5 14.6046 19.5 13.5V7.5C19.5 6.39543 18.6046 5.5 17.5 5.5H7.5C6.39543 5.5 5.5 6.39543 5.5 7.5V13.5C5.5 14.6046 6.39543 15.5 7.5 15.5Z", stroke: "currentColor", strokeLinejoin: "round", strokeWidth: "1.2" }) });
});
var MentionIcon = (0, import_react2.forwardRef)(function Icon3(props, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", { "data-sanity-icon": "mention", fill: "none", height: "1em", ref, viewBox: "0 0 25 25", width: "1em", xmlns: "http://www.w3.org/2000/svg", ...props, children: [(0, import_jsx_runtime.jsx)("path", { d: "M16.6633 18.9383C15.539 19.6562 14.2034 20.0723 12.7705 20.0723C8.77022 20.0723 5.52734 16.8294 5.52734 12.8291C5.52734 8.82881 8.77022 5.58594 12.7705 5.58594C16.7708 5.58594 20.0137 8.82881 20.0137 12.8291C20.0137 13.6623 19.8249 14.7093 19.6141 15.2077C19.5578 15.3408 19.479 15.4845 19.3936 15.6238C19.0955 16.1106 18.5507 16.3721 17.9807 16.4018V16.4018C16.8271 16.462 15.8588 15.5428 15.8588 14.3877V9.27302", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("circle", { cx: "12.5732", cy: "12.8291", r: "3.08691", stroke: "currentColor", strokeWidth: 1.2 })] });
});
var ReactionIcon = (0, import_react2.forwardRef)(function Icon4(props, ref) {
  return (0, import_jsx_runtime.jsxs)("svg", { "data-sanity-icon": "add-reaction", fill: "none", height: "1em", ref, viewBox: "0 0 25 25", width: "1em", xmlns: "http://www.w3.org/2000/svg", ...props, children: [(0, import_jsx_runtime.jsx)("path", { d: "M10.1044 10.4011L10.1044 10.9972", stroke: "currentColor", strokeWidth: 1.2, strokeLinecap: "square" }), (0, import_jsx_runtime.jsx)("path", { d: "M14.2393 10.4011L14.2393 10.9972", stroke: "currentColor", strokeWidth: 1.2, strokeLinecap: "square" }), (0, import_jsx_runtime.jsx)("path", { d: "M7.12128 14.1151C7.70803 15.0226 9.66113 16.8377 11.7735 16.8377C13.8859 16.8377 15.6713 15.0226 16.4257 14.1151", stroke: "currentColor", strokeWidth: 1.2, strokeLinecap: "square" }), (0, import_jsx_runtime.jsx)("path", { d: "M16.703 6.43905C15.3486 5.36511 13.6357 4.72374 11.773 4.72374C7.38731 4.72374 3.83203 8.27902 3.83203 12.6647C3.83203 17.0503 7.38731 20.6056 11.773 20.6056C16.0995 20.6056 19.618 17.1455 19.712 12.8415", stroke: "currentColor", strokeWidth: 1.2 }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19.1135 9.03425L19.1135 11.4903L20.3135 11.4903L20.3135 9.03425L22.7693 9.03425L22.7693 7.83425L20.3135 7.83425L20.3135 5.37941L19.1135 5.37941L19.1135 7.83425L16.6584 7.83425L16.6584 9.03425L19.1135 9.03425Z", fill: "currentColor" })] });
});
var SendIcon = (0, import_react2.forwardRef)(function Icon5(props, ref) {
  return (0, import_jsx_runtime.jsx)("svg", { "data-sanity-icon": "send", fill: "none", height: "1em", ref, viewBox: "0 0 25 25", width: "1em", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime.jsx)("path", { clipRule: "evenodd", d: "M21.1602 12.5L7.16016 19.5V14.8765L13.6656 12.4989L7.16016 9.97149L7.16016 5.5L21.1602 12.5Z", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }) });
});
var CommentsAuthoringPathContext = (0, import_react2.createContext)(null);
function CommentsAuthoringPathProvider(props) {
  const { children } = props;
  const [authoringPath, setAuthoringPath] = (0, import_react2.useState)(null);
  const handleSetAuthoringPath = (0, import_react2.useCallback)((nextAuthoringPath) => {
    setAuthoringPath(nextAuthoringPath);
  }, []);
  const value = (0, import_react2.useMemo)(() => ({ authoringPath, setAuthoringPath: handleSetAuthoringPath }), [authoringPath, handleSetAuthoringPath]);
  return (0, import_jsx_runtime.jsx)(CommentsAuthoringPathContext.Provider, { value, children });
}
var CommentsContext = (0, import_react2.createContext)(null);
function getSchemaField(schemaType, fieldPath) {
  var _a2;
  const paths = fromString(fieldPath);
  const firstPath = paths[0];
  if (firstPath && isObjectSchemaType(schemaType)) {
    const field = (_a2 = schemaType == null ? void 0 : schemaType.fields) == null ? void 0 : _a2.find((f) => f.name === firstPath);
    if (field) {
      const nextPath = toString(paths.slice(1));
      if (nextPath) {
        return getSchemaField(field.type, nextPath);
      }
      return field;
    }
  }
  return void 0;
}
function findArrayItemIndex(array, pathSegment) {
  if (typeof pathSegment === "number") {
    return pathSegment;
  }
  const index = (0, import_findIndex.default)(array, pathSegment);
  return index === -1 ? false : index;
}
function buildCommentBreadcrumbs(props) {
  const { currentUser, schemaType, fieldPath, documentValue } = props;
  const paths = fromString(fieldPath);
  const fieldPaths = [];
  let currentSchemaType = null;
  paths.forEach((seg, index) => {
    var _a2, _b2, _c2, _d2, _e2;
    const currentPath = paths.slice(0, index + 1);
    const previousPath = paths.slice(0, index);
    const field = getSchemaField(schemaType, toString(currentPath));
    const isKeySegment2 = seg.hasOwnProperty("_key");
    const parentValue = getValueAtPath(documentValue, previousPath);
    const currentValue = getValueAtPath(documentValue, currentPath);
    const conditionalContext = { document: documentValue, currentUser, parent: parentValue, value: currentValue };
    if (isKeySegment2 && Array.isArray(parentValue)) {
      const arrayItemIndex = findArrayItemIndex(parentValue, seg);
      const isNumber2 = typeof arrayItemIndex === "number";
      fieldPaths.push({ invalid: arrayItemIndex === false, isArrayItem: true, title: isNumber2 ? "#".concat(Number(arrayItemIndex) + 1) : "Unknown array item" });
      return;
    }
    if (field == null ? void 0 : field.type) {
      const hidden = resolveConditionalProperty(field.type.hidden, conditionalContext);
      fieldPaths.push({ invalid: hidden, isArrayItem: false, title: getSchemaTypeTitle(field.type) });
      currentSchemaType = field.type;
      return;
    }
    if (isArraySchemaType(currentSchemaType)) {
      const arrayValue = getValueAtPath(documentValue, previousPath);
      const objectType = arrayValue == null ? void 0 : arrayValue._type;
      const objectField = (_a2 = currentSchemaType == null ? void 0 : currentSchemaType.of) == null ? void 0 : _a2.find((type) => type.name === objectType);
      const currentField = (_b2 = objectField == null ? void 0 : objectField.fields) == null ? void 0 : _b2.find((f) => f.name === seg);
      if (!objectType && currentValue) {
        const allCurrentFields = (_c2 = currentSchemaType == null ? void 0 : currentSchemaType.of) == null ? void 0 : _c2.map((o) => o == null ? void 0 : o.fields).filter(Boolean).flat();
        const anonymousField = allCurrentFields == null ? void 0 : allCurrentFields.find((f) => (f == null ? void 0 : f.name) === seg);
        const hidden = resolveConditionalProperty((_d2 = anonymousField == null ? void 0 : anonymousField.type) == null ? void 0 : _d2.hidden, conditionalContext);
        if (anonymousField) {
          fieldPaths.push({ invalid: hidden, isArrayItem: false, title: getSchemaTypeTitle(anonymousField == null ? void 0 : anonymousField.type) });
          currentSchemaType = anonymousField == null ? void 0 : anonymousField.type;
        }
        return;
      }
      if (!currentField) {
        fieldPaths.push({ invalid: true, isArrayItem: false, title: "Unknown field" });
        return;
      }
      const currentTitle = getSchemaTypeTitle(currentField == null ? void 0 : currentField.type);
      const objectFieldHidden = resolveConditionalProperty((_e2 = objectField == null ? void 0 : objectField.type) == null ? void 0 : _e2.hidden, conditionalContext);
      const currentFieldHidden = resolveConditionalProperty(currentField == null ? void 0 : currentField.type.hidden, conditionalContext);
      const isHidden = objectFieldHidden || currentFieldHidden;
      fieldPaths.push({ invalid: isHidden, isArrayItem: false, title: currentTitle });
      currentSchemaType = currentField == null ? void 0 : currentField.type;
      return;
    }
    fieldPaths.push({ invalid: true, isArrayItem: false, title: "Unknown field" });
  });
  return fieldPaths;
}
function useCommentHasChanged(message) {
  const prevMessage = (0, import_react2.useRef)(message);
  return (0, import_react2.useMemo)(() => !(0, import_isEqual2.default)(prevMessage.current, message), [message]);
}
function hasCommentMessageValue(value) {
  if (!value)
    return false;
  return value == null ? void 0 : value.some((block) => {
    var _a2;
    return isPortableTextTextBlock(block) && ((_a2 = (block == null ? void 0 : block.children) || []) == null ? void 0 : _a2.some((c) => isPortableTextSpan(c) ? c.text : c.userId));
  });
}
function commentIntentIfDiffers(parent, comment) {
  var _a2, _b2;
  const parentIntent = (_a2 = parent == null ? void 0 : parent.context) == null ? void 0 : _a2.intent;
  const intent = (_b2 = comment == null ? void 0 : comment.context) == null ? void 0 : _b2.intent;
  if (!intent)
    return void 0;
  if (!parentIntent)
    return intent;
  if ("preview" in intent.params && "preview" in parentIntent.params && intent.params.preview !== parentIntent.params.preview) {
    return intent;
  }
  return void 0;
}
function isTextSelectionComment(comment) {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  if (!comment)
    return false;
  return Boolean(((_c2 = (_b2 = (_a2 = comment == null ? void 0 : comment.target) == null ? void 0 : _a2.path) == null ? void 0 : _b2.selection) == null ? void 0 : _c2.type) === "text" && ((_f2 = (_e2 = (_d2 = comment == null ? void 0 : comment.target) == null ? void 0 : _d2.path) == null ? void 0 : _e2.selection) == null ? void 0 : _f2.value));
}
var EMPTY_ARRAY$h = [];
function buildCommentThreadItems(props) {
  const { comments: comments2, currentUser, documentValue, schemaType, type } = props;
  const parentComments = comments2 == null ? void 0 : comments2.filter((c) => !c.parentCommentId);
  if (type === "task") {
    const taskCommentItems = parentComments.map((parentComment) => {
      const replies = comments2 == null ? void 0 : comments2.filter((r) => r.parentCommentId === parentComment._id);
      const commentsCount = [parentComment, ...replies].length;
      const hasReferencedValue = false;
      const item = { commentsCount, parentComment, replies, threadId: parentComment.threadId, hasReferencedValue, breadcrumbs: EMPTY_ARRAY$h, fieldPath: "" };
      return item;
    });
    return taskCommentItems;
  }
  if (type === "field") {
    const fieldCommentItems = parentComments.map((parentComment) => {
      var _a2, _b2, _c2;
      const crumbs = buildCommentBreadcrumbs({ currentUser, documentValue, fieldPath: ((_a2 = parentComment.target.path) == null ? void 0 : _a2.field) || "", schemaType });
      let hasTextSelection = false;
      if (isTextSelectionComment(parentComment)) {
        hasTextSelection = Boolean(((_b2 = parentComment.target.path) == null ? void 0 : _b2.selection) && parentComment.target.path.selection.value.some((v) => v.text));
      }
      const hasInvalidBreadcrumb = crumbs.some((bc) => bc.invalid);
      if (hasInvalidBreadcrumb)
        return void 0;
      const replies = comments2 == null ? void 0 : comments2.filter((r) => r.parentCommentId === parentComment._id);
      const commentsCount = [parentComment, ...replies].length;
      const hasReferencedValue = hasTextSelection;
      const item = { breadcrumbs: crumbs, commentsCount, fieldPath: ((_c2 = parentComment.target.path) == null ? void 0 : _c2.field) || "", parentComment, replies, threadId: parentComment.threadId, hasReferencedValue };
      return item;
    });
    return fieldCommentItems.filter(Boolean);
  }
  return EMPTY_ARRAY$h;
}
var DMP_MARGIN = 15;
function diffText(current, next) {
  const diff2 = diff(current, next);
  const diffs = cleanupEfficiency(diff2);
  const levenshtein = diffsLevenshtein(diffs);
  return { patches: make(current, diffs, { margin: DMP_MARGIN }), levenshtein };
}
function diffApply(current, patches) {
  return apply(patches, current, { allowExceedingIndices: true, margin: DMP_MARGIN })[0];
}
var CHILD_SYMBOL = "";
function toPlainTextWithChildSeparators(inputBlock) {
  return inputBlock.children.map((child) => isPortableTextSpan(child) ? child.text.replaceAll(CHILD_SYMBOL, " ") : "").join(CHILD_SYMBOL);
}
var COMMENT_INDICATORS = ["", ""];
var COMMENT_INDICATORS_REGEX = new RegExp("[".concat(COMMENT_INDICATORS.join(""), "]"), "g");
var EMPTY_ARRAY$g = [];
function buildRangeDecorationSelectionsFromComments(props) {
  const { value, comments: comments2 } = props;
  if (!value || value.length === 0)
    return EMPTY_ARRAY$g;
  const textSelections = comments2.filter(isTextSelectionComment);
  const decorators = [];
  textSelections.forEach((comment) => {
    var _a2, _b2;
    (_b2 = (_a2 = comment.target.path) == null ? void 0 : _a2.selection) == null ? void 0 : _b2.value.forEach((selectionMember) => {
      const matchedBlock = value.find((block) => block._key === selectionMember._key);
      if (!matchedBlock || !isPortableTextTextBlock(matchedBlock)) {
        return;
      }
      const selectionText = selectionMember.text.replaceAll(COMMENT_INDICATORS_REGEX, "");
      const textWithChildSeparators = toPlainTextWithChildSeparators(matchedBlock);
      const { patches } = diffText(selectionText, selectionMember.text);
      const diffedText = diffApply(textWithChildSeparators, patches);
      const startIndex = diffedText.indexOf(COMMENT_INDICATORS[0]);
      const endIndex = diffedText.replaceAll(COMMENT_INDICATORS[0], "").indexOf(COMMENT_INDICATORS[1]);
      const textWithoutCommentTags = diffedText.replaceAll(COMMENT_INDICATORS_REGEX, "");
      const oldCommentedText = selectionMember.text.substring(selectionMember.text.indexOf(COMMENT_INDICATORS[0]) + 1, selectionMember.text.indexOf(COMMENT_INDICATORS[1]));
      const newCommentedText = textWithoutCommentTags.substring(startIndex, endIndex);
      const { levenshtein } = diffText(newCommentedText, oldCommentedText);
      const threshold = Math.round(newCommentedText.length + oldCommentedText.length / 2);
      let nullSelection = false;
      if (newCommentedText.length === 0) {
        nullSelection = true;
      }
      if (levenshtein > threshold) {
        nullSelection = true;
      }
      if (startIndex + 1 === endIndex) {
        nullSelection = true;
      }
      if (startIndex !== -1 && endIndex !== -1) {
        let childIndexAnchor = 0;
        let anchorOffset = 0;
        let childIndexFocus = 0;
        let focusOffset = 0;
        for (let i = 0; i < textWithoutCommentTags.length; i++) {
          if (textWithoutCommentTags[i] === CHILD_SYMBOL) {
            if (i <= startIndex) {
              anchorOffset = -1;
              childIndexAnchor++;
            }
            focusOffset = -1;
            childIndexFocus++;
          }
          if (i < startIndex) {
            anchorOffset++;
          }
          if (i < startIndex + newCommentedText.length) {
            focusOffset++;
          }
          if (i === startIndex + newCommentedText.length) {
            break;
          }
        }
        decorators.push({ selection: { anchor: { path: [{ _key: matchedBlock._key }, "children", { _key: matchedBlock.children[childIndexAnchor]._key }], offset: anchorOffset }, focus: { path: [{ _key: matchedBlock._key }, "children", { _key: matchedBlock.children[childIndexFocus]._key }], offset: focusOffset } }, comment, range: { _key: matchedBlock._key, text: nullSelection ? "" : diffedText } });
      }
    });
  });
  if (decorators.length === 0)
    return EMPTY_ARRAY$g;
  return decorators;
}
function diffsLevenshtein(diffs) {
  let levenshtein = 0;
  let insertions = 0;
  let deletions = 0;
  for (let x = 0; x < diffs.length; x++) {
    const op = diffs[x][0];
    const data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        levenshtein += Math.max(insertions, deletions);
        insertions = 0;
        deletions = 0;
        break;
    }
  }
  levenshtein += Math.max(insertions, deletions);
  return levenshtein;
}
var CommentRangeDecoration = (0, import_react2.memo)(function CommentRangeDecoration2(props) {
  const { children, commentId, currentHoveredCommentId, onClick, onHoverEnd, onHoverStart, selectedThreadId, threadId } = props;
  const decoratorRef = (0, import_react2.useRef)(null);
  const isNestedRef = (0, import_react2.useRef)(false);
  const parentCommentId = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    var _a2, _b2;
    const prevEl = (_a2 = decoratorRef.current) == null ? void 0 : _a2.previousSibling;
    const nextEl = (_b2 = decoratorRef.current) == null ? void 0 : _b2.nextSibling;
    if (!prevEl || !nextEl) {
      isNestedRef.current = false;
      return;
    }
    const [key] = Object.keys(applyInlineCommentIdAttr(""));
    const prevId = prevEl.getAttribute(key);
    const nextId = nextEl.getAttribute(key);
    const isEqual2 = prevId === nextId;
    const isNestedDecorator = Boolean(prevId && nextId && isEqual2);
    parentCommentId.current = isNestedDecorator ? prevId : null;
    isNestedRef.current = isNestedDecorator;
  }, []);
  const handleMouseEnter = (0, import_react2.useCallback)(() => onHoverStart(commentId), [commentId, onHoverStart]);
  const handleMouseLeave = (0, import_react2.useCallback)(() => onHoverEnd(null), [onHoverEnd]);
  const handleClick = (0, import_react2.useCallback)(() => onClick(commentId), [commentId, onClick]);
  const hovered = currentHoveredCommentId === commentId || currentHoveredCommentId === parentCommentId.current && isNestedRef.current;
  const selected = selectedThreadId === threadId;
  return (0, import_jsx_runtime.jsx)(CommentInlineHighlightSpan, { isAdded: true, isHovered: hovered || selected, isNested: isNestedRef.current, onClick: handleClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, ref: decoratorRef, ...applyInlineCommentIdAttr(threadId), children });
});
function buildRangeDecorations(props) {
  const { comments: comments2, currentHoveredCommentId, onDecorationClick, onDecorationHoverEnd, onDecorationHoverStart, onDecorationMoved, selectedThreadId, value } = props;
  const rangeSelections = buildRangeDecorationSelectionsFromComments({ comments: comments2, value });
  const decorations = rangeSelections.map((_ref) => {
    let { selection, comment, range } = _ref;
    const decoration = { component: (_ref2) => {
      let { children } = _ref2;
      return (0, import_jsx_runtime.jsx)(CommentRangeDecoration, { commentId: comment._id, currentHoveredCommentId, onClick: onDecorationClick, onHoverEnd: onDecorationHoverEnd, onHoverStart: onDecorationHoverStart, selectedThreadId, threadId: comment.threadId, children });
    }, onMoved: onDecorationMoved, selection, payload: { commentId: comment._id, range } };
    return decoration;
  });
  return decorations;
}
function buildTextSelectionFromFragment(props) {
  const { fragment, value, selection } = props;
  if (!selection) {
    throw new Error("Selection is required");
  }
  const normalizedSelection = selection.backward ? { backward: false, anchor: selection.focus, focus: selection.anchor } : selection;
  const textSelection = { type: "text", value: fragment.map((fragmentBlock) => {
    const originalBlock = value.find((b) => b._key === fragmentBlock._key);
    if (!isPortableTextTextBlock(originalBlock)) {
      return { _key: fragmentBlock._key, text: "" };
    }
    const anchorBlockKey = isKeySegment(normalizedSelection.anchor.path[0]) && normalizedSelection.anchor.path[0]._key;
    const focusBlockKey = isKeySegment(normalizedSelection.focus.path[0]) && normalizedSelection.focus.path[0]._key;
    const fragmentBlockText = toPlainText([fragmentBlock]);
    const fragmentStartSpan = isPortableTextTextBlock(fragmentBlock) ? fragmentBlock.children[0] : void 0;
    const fragmentEndSpan = isPortableTextTextBlock(fragmentBlock) ? fragmentBlock.children[fragmentBlock.children.length - 1] : void 0;
    let originalTextBeforeSelection = "";
    let startChildIndex = -1;
    if (anchorBlockKey === originalBlock._key) {
      for (const child of originalBlock.children) {
        startChildIndex++;
        if (child._key === (fragmentStartSpan == null ? void 0 : fragmentStartSpan._key)) {
          originalTextBeforeSelection += isPortableTextSpan(child) && child.text.substring(0, normalizedSelection.anchor.offset) || "";
          break;
        }
        originalTextBeforeSelection += child.text;
      }
    }
    let originalTextAfterSelection = "";
    if (focusBlockKey === originalBlock._key) {
      for (const child of originalBlock.children.slice(startChildIndex).reverse()) {
        if (child._key === (fragmentEndSpan == null ? void 0 : fragmentEndSpan._key)) {
          originalTextAfterSelection = (isPortableTextSpan(child) && child.text.substring(normalizedSelection.focus.offset, child.text.length) || "") + originalTextAfterSelection;
          break;
        }
        originalTextAfterSelection = child.text + originalTextAfterSelection;
      }
    }
    return { _key: originalBlock._key, text: "".concat(originalTextBeforeSelection).concat(COMMENT_INDICATORS[0]).concat(fragmentBlockText).concat(COMMENT_INDICATORS[1]).concat(originalTextAfterSelection) };
  }) };
  return textSelection;
}
function mergeCommentReactions(reactionsA, reactionsB) {
  const mergedReactions = {};
  for (const reaction of reactionsA) {
    mergedReactions[reaction._key] = { ...reaction };
  }
  for (const reaction of reactionsB) {
    mergedReactions[reaction._key] = { ...mergedReactions[reaction._key], ...reaction };
  }
  const result = Object.values(mergedReactions);
  return result;
}
function createCommentsSet(comments2) {
  const commentsById = comments2.reduce((acc, comment) => ({ ...acc, [comment._id]: comment }), {});
  return commentsById;
}
function commentsReducer(state2, action) {
  var _a2;
  switch (action.type) {
    case "COMMENTS_SET": {
      const commentsById = createCommentsSet(action.comments);
      return { ...state2, comments: commentsById };
    }
    case "COMMENT_ADDED": {
      const nextCommentResult = action.payload;
      const nextCommentValue = nextCommentResult;
      const nextComment = { [nextCommentResult._id]: {
        ...state2.comments[nextCommentResult._id],
        ...nextCommentValue,
        _state: nextCommentResult._state || void 0,
        // If the comment is created optimistically, it won't have a createdAt date as this is set on the server.
        // However, we need to set a createdAt date to be able to sort the comments correctly.
        // Therefore, we set the createdAt date to the current date here if it's missing while creating the comment.
        // Once the comment is created and received from the server, the createdAt date will be updated to the correct value.
        _createdAt: nextCommentResult._createdAt || (/* @__PURE__ */ new Date()).toISOString()
      } };
      return { ...state2, comments: { ...state2.comments, ...nextComment } };
    }
    case "COMMENT_RECEIVED": {
      const nextCommentResult = action.payload;
      return { ...state2, comments: { ...state2.comments, [nextCommentResult._id]: nextCommentResult } };
    }
    case "COMMENT_DELETED": {
      const { [action.id]: _, ...restComments } = state2.comments;
      Object.keys(restComments).forEach((commentId) => {
        if (restComments[commentId].parentCommentId === action.id) {
          delete restComments[commentId];
        }
      });
      return { ...state2, comments: restComments };
    }
    case "COMMENT_UPDATED": {
      const updatedComment = action.payload;
      const id = updatedComment._id;
      const comment = state2.comments[id];
      const optimisticReactions = ((_a2 = comment == null ? void 0 : comment.reactions) == null ? void 0 : _a2.filter((v) => v == null ? void 0 : v._optimisticState)) || [];
      const incomingReactions = updatedComment.reactions || [];
      const nextReactions = mergeCommentReactions(optimisticReactions, incomingReactions);
      const nextComment = {
        // Add existing comment data
        ...comment,
        // Add incoming comment data
        ...updatedComment,
        // Add reactions merged with optimistic reactions
        reactions: nextReactions
      };
      return { ...state2, comments: { ...state2.comments, [id]: nextComment } };
    }
    default:
      return state2;
  }
}
var INITIAL_STATE$2 = { comments: {} };
var LISTEN_OPTIONS$1 = { events: ["welcome", "mutation", "reconnect"], includeResult: true, visibility: "query" };
var SORT_FIELD$1 = "_createdAt";
var SORT_ORDER$1 = "desc";
var QUERY_FILTERS$1 = ['_type == "comment"', "target.document._ref == $documentId"];
var QUERY_PROJECTION$1 = "{\n  _createdAt,\n  _id,\n  authorId,\n  contentSnapshot,\n  context,\n  lastEditedAt,\n  message,\n  parentCommentId,\n  reactions,\n  status,\n  target,\n  threadId\n}";
var QUERY_SORT_ORDER$1 = "order(".concat(SORT_FIELD$1, " ").concat(SORT_ORDER$1, ")");
var QUERY$1 = "*[".concat(QUERY_FILTERS$1.join(" && "), "] ").concat(QUERY_PROJECTION$1, " | ").concat(QUERY_SORT_ORDER$1);
function useCommentsStore(opts) {
  const { client, documentId, onLatestTransactionIdReceived, transactionsIdMap } = opts;
  const [state2, dispatch] = (0, import_react2.useReducer)(commentsReducer, INITIAL_STATE$2);
  const [loading, setLoading] = (0, import_react2.useState)(client !== null);
  const [error, setError] = (0, import_react2.useState)(null);
  const didInitialFetch = (0, import_react2.useRef)(false);
  const params = (0, import_react2.useMemo)(() => ({ documentId: getPublishedId(documentId) }), [documentId]);
  const initialFetch = (0, import_react2.useCallback)(async () => {
    if (!client) {
      setLoading(false);
      return;
    }
    try {
      const res = await client.fetch(QUERY$1, params);
      dispatch({ type: "COMMENTS_SET", comments: res });
      setLoading(false);
    } catch (err) {
      setError(err);
    }
  }, [client, params]);
  const handleListenerEvent = (0, import_react2.useCallback)(async (event) => {
    var _a2;
    if (event.type === "welcome" && !didInitialFetch.current) {
      setLoading(true);
      await initialFetch();
      setLoading(false);
      didInitialFetch.current = true;
    }
    if (event.type === "reconnect") {
      setLoading(true);
      didInitialFetch.current = false;
    }
    if (event.type === "mutation") {
      if (event.transition === "appear") {
        const nextComment = event.result;
        if (nextComment) {
          dispatch({ type: "COMMENT_RECEIVED", payload: nextComment });
        }
      }
      if (event.transition === "disappear") {
        dispatch({ type: "COMMENT_DELETED", id: event.documentId });
      }
      if (event.transition === "update") {
        const updatedComment = event.result;
        const id = ((_a2 = event.result) == null ? void 0 : _a2._id) || "";
        const transactionId = event.transactionId;
        const latestTransactionId = transactionsIdMap.get(id);
        const isLatestTransaction = transactionId === latestTransactionId;
        if (!isLatestTransaction && latestTransactionId)
          return;
        if (updatedComment) {
          dispatch({ type: "COMMENT_UPDATED", payload: updatedComment });
          if (isLatestTransaction) {
            onLatestTransactionIdReceived(id);
          }
        }
      }
    }
  }, [initialFetch, onLatestTransactionIdReceived, transactionsIdMap]);
  const listener$ = (0, import_react2.useMemo)(() => {
    if (!client)
      return of();
    const events$ = client.observable.listen(QUERY$1, params, LISTEN_OPTIONS$1).pipe(catchError((err) => {
      setError(err);
      return of(err);
    }));
    return events$;
  }, [client, params]);
  (0, import_react2.useEffect)(() => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub == null ? void 0 : sub.unsubscribe();
    };
  }, [handleListenerEvent, listener$]);
  const commentsAsArray = (0, import_react2.useMemo)(() => Object.values(state2.comments), [state2.comments]);
  return { data: commentsAsArray, dispatch, error, loading };
}
var EMPTY_ARRAY$f = [];
var EMPTY_COMMENTS_DATA = { open: EMPTY_ARRAY$f, resolved: EMPTY_ARRAY$f };
var CommentsProvider = (0, import_react2.memo)(function CommentsProvider2(props) {
  const { children, documentId, documentType, isCommentsOpen, onCommentsOpen, sortOrder, type } = props;
  const commentsEnabled = useCommentsEnabled();
  const [status, setStatus] = (0, import_react2.useState)("open");
  const { client, createAddonDataset, isCreatingDataset } = useAddonDataset();
  const publishedId = getPublishedId(documentId);
  const editState = useEditState(publishedId, documentType, "low");
  const schemaType = useSchema().get(documentType);
  const currentUser = useCurrentUser();
  const { name: workspaceName, dataset, projectId } = useWorkspace();
  const transactionsIdMap = (0, import_react2.useMemo)(() => /* @__PURE__ */ new Map(), []);
  const handleOnLatestTransactionIdReceived = (0, import_react2.useCallback)((commentDocumentId) => {
    transactionsIdMap.delete(commentDocumentId);
  }, [transactionsIdMap]);
  const { dispatch, data = EMPTY_ARRAY$f, error, loading } = useCommentsStore({ documentId: publishedId, client, transactionsIdMap, onLatestTransactionIdReceived: handleOnLatestTransactionIdReceived });
  const handleOnTransactionStart = (0, import_react2.useCallback)((commentDocumentId, transactionId) => {
    transactionsIdMap.set(commentDocumentId, transactionId);
  }, [transactionsIdMap]);
  const documentValue = (0, import_react2.useMemo)(() => {
    return editState.draft || editState.published;
  }, [editState.draft, editState.published]);
  const documentRevisionId = (0, import_react2.useMemo)(() => documentValue == null ? void 0 : documentValue._rev, [documentValue]);
  const handleSetStatus = (0, import_react2.useCallback)((newStatus) => {
    if (commentsEnabled.mode === "upsell" && newStatus === "resolved") {
      return null;
    }
    return setStatus(newStatus);
  }, [setStatus, commentsEnabled]);
  const mentionOptions = useUserListWithPermissions((0, import_react2.useMemo)(() => ({ documentValue, permission: "read" }), [documentValue]));
  const threadItemsByStatus = (0, import_react2.useMemo)(() => {
    if (!schemaType || !currentUser)
      return EMPTY_COMMENTS_DATA;
    const sorted = (0, import_orderBy.default)(data, ["_createdAt"], [sortOrder]);
    const items = buildCommentThreadItems({ comments: sorted, currentUser, documentValue, schemaType, type });
    return { open: items.filter((item) => item.parentComment.status === "open"), resolved: items.filter((item) => item.parentComment.status === "resolved") };
  }, [currentUser, data, documentValue, schemaType, sortOrder, type]);
  const getThreadLength = (0, import_react2.useCallback)((threadId) => {
    return threadItemsByStatus.open.filter((item) => item.threadId === threadId).length;
  }, [threadItemsByStatus.open]);
  const getComment = (0, import_react2.useCallback)((id) => data == null ? void 0 : data.find((c) => c._id === id), [data]);
  const handleOnCreate = (0, import_react2.useCallback)((payload) => {
    var _a2, _b2;
    const hasError = ((_b2 = (_a2 = data == null ? void 0 : data.find((c) => c._id === payload._id)) == null ? void 0 : _a2._state) == null ? void 0 : _b2.type) === "createError";
    dispatch({ type: "COMMENT_ADDED", payload: { ...payload, _state: hasError ? { type: "createRetrying" } : void 0 } });
  }, [data, dispatch]);
  const handleOnUpdate = (0, import_react2.useCallback)((id, payload) => {
    dispatch({ type: "COMMENT_UPDATED", payload: { _id: id, ...payload } });
  }, [dispatch]);
  const handleOnCreateError = (0, import_react2.useCallback)((id, err) => {
    dispatch({ type: "COMMENT_UPDATED", payload: { _id: id, _state: { error: err, type: "createError" } } });
  }, [dispatch]);
  const { operation } = useCommentOperations((0, import_react2.useMemo)(() => ({
    client,
    currentUser,
    dataset,
    documentId: publishedId,
    documentRevisionId,
    documentType,
    getComment,
    getThreadLength,
    projectId,
    schemaType,
    workspace: workspaceName,
    // This function runs when the first comment creation is executed.
    // It is used to create the addon dataset and configure a client for
    // the addon dataset.
    createAddonDataset,
    // The following callbacks runs when the comment operation are executed.
    // They are used to update the local state of the comments immediately after
    // a comment operation has been executed. This is done to avoid waiting for
    // the real time listener to update the comments and make the UI feel more
    // responsive. The comment will be updated again when we receive an mutation
    // event from the real time listener.
    onCreate: handleOnCreate,
    onCreateError: handleOnCreateError,
    onUpdate: handleOnUpdate,
    onTransactionStart: handleOnTransactionStart
  }), [client, currentUser, dataset, documentRevisionId, documentType, getComment, createAddonDataset, getThreadLength, handleOnCreate, handleOnCreateError, handleOnTransactionStart, handleOnUpdate, projectId, publishedId, schemaType, workspaceName]));
  const ctxValue = (0, import_react2.useMemo)(() => ({ isCreatingDataset, status, setStatus: handleSetStatus, getComment, isCommentsOpen, onCommentsOpen, comments: { data: threadItemsByStatus, error, loading: loading || isCreatingDataset }, operation: { create: operation.create, react: operation.react, remove: operation.remove, update: operation.update }, mentionOptions }), [error, getComment, isCommentsOpen, isCreatingDataset, loading, mentionOptions, onCommentsOpen, operation.create, operation.react, operation.remove, operation.update, status, handleSetStatus, threadItemsByStatus]);
  return (0, import_jsx_runtime.jsx)(CommentsContext.Provider, { value: ctxValue, children });
});
var CommentsEnabledContext = (0, import_react2.createContext)(null);
var CommentsEnabledProvider = React.memo(function CommentsEnabledProvider2(props) {
  const { children, documentId, documentType } = props;
  const value = useResolveCommentsEnabled(documentId, documentType);
  return (0, import_jsx_runtime.jsx)(CommentsEnabledContext.Provider, { value, children });
});
var CommentsIntentContext = (0, import_react2.createContext)(void 0);
var CommentsIntentProvider = (0, import_react2.memo)(function CommentsIntentProvider2(props) {
  const { children, getIntent: getIntent2 } = props;
  return (0, import_jsx_runtime.jsx)(CommentsIntentContext.Provider, { value: getIntent2, children });
});
var CommentsOnboardingContext = (0, import_react2.createContext)(null);
var VERSION = 1;
var LOCAL_STORAGE_KEY = "sanityStudio:comments:inspector:onboarding:dismissed:v".concat(VERSION);
var setLocalStorage = (value) => {
  try {
    window.localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(value));
  } catch (_) {
  }
};
var getLocalStorage = () => {
  try {
    const value = window.localStorage.getItem(LOCAL_STORAGE_KEY);
    return value ? JSON.parse(value) : false;
  } catch (_) {
    return false;
  }
};
function CommentsOnboardingProvider(props) {
  const { children } = props;
  const [dismissed, setDismissed] = (0, import_react2.useState)(getLocalStorage());
  const handleDismiss = (0, import_react2.useCallback)(() => {
    setDismissed(true);
    setLocalStorage(true);
  }, [setDismissed]);
  const ctxValue = (0, import_react2.useMemo)(() => ({ setDismissed: handleDismiss, isDismissed: dismissed }), [handleDismiss, dismissed]);
  return (0, import_jsx_runtime.jsx)(CommentsOnboardingContext.Provider, { value: ctxValue, children });
}
var CommentsSelectedPathContext = (0, import_react2.createContext)(null);
var CommentsSelectedPathProvider = import_react2.default.memo(function CommentsSelectedPathProvider2(props) {
  const { children } = props;
  const [selectedPath, setSelectedPath] = (0, import_react2.useState)(null);
  const handleSelectPath = (0, import_react2.useCallback)((nextPath) => {
    if ((0, import_isEqual2.default)(selectedPath, nextPath))
      return;
    setSelectedPath(nextPath);
  }, [selectedPath]);
  const ctxValue = (0, import_react2.useMemo)(() => ({ selectedPath, setSelectedPath: handleSelectPath }), [selectedPath, handleSelectPath]);
  return (0, import_jsx_runtime.jsx)(CommentsSelectedPathContext.Provider, { value: ctxValue, children });
});
var CommentsUpsellContext = (0, import_react2.createContext)(null);
var UPSELL_CLIENT_OPTIONS = { apiVersion: "2023-12-11", useProjectHostname: false, withCredentials: false, useCdn: true };
var FEATURE = "comments";
var TEMPLATE_OPTIONS = { interpolate: /{{([\s\S]+?)}}/g };
var BASE_URL = "www.sanity.io";
function CommentsUpsellProvider(props) {
  const [upsellDialogOpen, setUpsellDialogOpen] = (0, import_react2.useState)(false);
  const [upsellData, setUpsellData] = (0, import_react2.useState)(null);
  const projectId = useProjectId();
  const telemetry = useTelemetry();
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const telemetryLogs = (0, import_react2.useMemo)(() => ({ dialogSecondaryClicked: () => telemetry.log(UpsellDialogLearnMoreCtaClicked, { feature: FEATURE, type: "modal" }), dialogPrimaryClicked: () => telemetry.log(UpsellDialogUpgradeCtaClicked, { feature: FEATURE, type: "modal" }), panelViewed: (source) => telemetry.log(UpsellDialogViewed, { feature: FEATURE, type: "inspector", source }), panelDismissed: () => telemetry.log(UpsellDialogDismissed, { feature: FEATURE, type: "inspector" }), panelPrimaryClicked: () => telemetry.log(UpsellDialogUpgradeCtaClicked, { feature: FEATURE, type: "inspector" }), panelSecondaryClicked: () => telemetry.log(UpsellDialogLearnMoreCtaClicked, { feature: FEATURE, type: "inspector" }) }), [telemetry]);
  const handlePrimaryButtonClick = (0, import_react2.useCallback)(() => {
    telemetryLogs.dialogPrimaryClicked();
  }, [telemetryLogs]);
  const handleSecondaryButtonClick = (0, import_react2.useCallback)(() => {
    telemetryLogs.dialogSecondaryClicked();
  }, [telemetryLogs]);
  const handleClose = (0, import_react2.useCallback)(() => {
    setUpsellDialogOpen(false);
    telemetry.log(UpsellDialogDismissed, { feature: FEATURE, type: "modal" });
  }, [telemetry]);
  (0, import_react2.useEffect)(() => {
    const data$ = client.withConfig(UPSELL_CLIENT_OPTIONS).observable.request({ uri: "/journey/comments" });
    const sub = data$.subscribe({ next: (data) => {
      if (!data)
        return;
      try {
        const ctaUrl = (0, import_template.default)(data.ctaButton.url, TEMPLATE_OPTIONS);
        data.ctaButton.url = ctaUrl({ baseUrl: BASE_URL, projectId });
        const secondaryUrl = (0, import_template.default)(data.secondaryButton.url, TEMPLATE_OPTIONS);
        data.secondaryButton.url = secondaryUrl({ baseUrl: BASE_URL, projectId });
        setUpsellData(data);
      } catch (e2) {
      }
    }, error: () => {
    } });
    return () => {
      sub.unsubscribe();
    };
  }, [client, projectId]);
  const handleOpenDialog = (0, import_react2.useCallback)((source) => {
    setUpsellDialogOpen(true);
    telemetry.log(UpsellDialogViewed, { feature: FEATURE, type: "modal", source });
  }, [telemetry]);
  const ctxValue = (0, import_react2.useMemo)(() => ({ upsellDialogOpen, handleOpenDialog, upsellData, telemetryLogs }), [handleOpenDialog, upsellDialogOpen, upsellData, telemetryLogs]);
  return (0, import_jsx_runtime.jsxs)(CommentsUpsellContext.Provider, { value: ctxValue, children: [props.children, upsellData && upsellDialogOpen && (0, import_jsx_runtime.jsx)(CommentsUpsellDialog, { data: upsellData, onClose: handleClose, onPrimaryClick: handlePrimaryButtonClick, onSecondaryClick: handleSecondaryButtonClick })] });
}
function useCommentsIntent() {
  return (0, import_react2.useContext)(CommentsIntentContext);
}
var structureLocaleNamespace = "structure";
var structureUsEnglishLocaleBundle = defineLocaleResourceBundle({ locale: "en-US", namespace: structureLocaleNamespace, resources: () => import("./resources-B_y3iqGc-VQPFCNND.js") });
function DocTitle(props) {
  const { document: documentValue } = props;
  const schema2 = useSchema();
  const schemaType = schema2.get(documentValue._type);
  const { t } = useTranslation2(structureLocaleNamespace);
  const { error, value } = useDocumentPreview({ schemaType, value: documentValue });
  if (!schemaType) {
    return (0, import_jsx_runtime.jsx)("code", { children: t("doc-title.unknown-schema-type.text", { schemaType: documentValue._type }) });
  }
  if (error) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: t("doc-title.error.text", { errorMessage: error.message }) });
  }
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (value == null ? void 0 : value.title) || (0, import_jsx_runtime.jsx)("span", { style: { color: "var(--card-muted-fg-color)" }, children: t("doc-title.fallback.text") }) });
}
var __freeze$12 = Object.freeze;
var __defProp$12 = Object.defineProperty;
var __template$12 = (cooked, raw) => __freeze$12(__defProp$12(cooked, "raw", { value: __freeze$12(raw || cooked.slice()) }));
var _a$12;
var _b$q;
var _c$b;
var _d$5;
var _e$3;
var ChevronWrapper = ut(Box)(_a$12 || (_a$12 = __template$12(["\n  margin-left: auto;\n"])));
var CrossDatasetReferencesDetails = ut.details(_b$q || (_b$q = __template$12(["\n  flex: none;\n\n  &[open] ", " {\n    transform: rotate(180deg);\n  }\n"])), ChevronWrapper);
var CrossDatasetReferencesSummary = ut.summary(_c$b || (_c$b = __template$12(["\n  list-style: none;\n\n  &::-webkit-details-marker {\n    display: none;\n  }\n"])));
var Table = ut.table(_d$5 || (_d$5 = __template$12(["\n  width: 100%;\n  text-align: left;\n  padding: 0 ", ";\n  border-collapse: collapse;\n\n  th {\n    padding: ", ";\n  }\n\n  td {\n    padding: 0 ", ";\n  }\n\n  tr > *:last-child {\n    text-align: right;\n  }\n"])), (_ref3) => {
  let { theme } = _ref3;
  return rem(theme.sanity.space[2]);
}, (_ref4) => {
  let { theme } = _ref4;
  return rem(theme.sanity.space[1]);
}, (_ref5) => {
  let { theme } = _ref5;
  return rem(theme.sanity.space[1]);
});
var DocumentIdFlex = ut(Flex)(_e$3 || (_e$3 = __template$12(["\n  min-height: 33px;\n"])));
var OtherReferenceCount = (props) => {
  const { t } = useTranslation2(structureLocaleNamespace);
  const difference = props.totalCount - props.references.length;
  if (!difference)
    return null;
  return (0, import_jsx_runtime.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime.jsxs)(Inline, { space: 2, children: [(0, import_jsx_runtime.jsx)(Text, { size: 1, muted: true, children: t("confirm-delete-dialog.other-reference-count.title", { count: difference }) }), (0, import_jsx_runtime.jsx)(Tooltip, { portal: true, placement: "top", content: t("confirm-delete-dialog.other-reference-count.tooltip"), children: (0, import_jsx_runtime.jsx)(Text, { size: 1, muted: true, children: (0, import_jsx_runtime.jsx)(InfoOutlineIcon, {}) }) })] }) });
};
function PaneItemPreview(props) {
  const { icon, layout, presence, schemaType, value } = props;
  const title = isRecord$4(value.title) && (0, import_react2.isValidElement)(value.title) || (0, import_isString.default)(value.title) || (0, import_isNumber.default)(value.title) ? value.title : null;
  const { draft, published, isLoading } = useMemoObservable(() => getPreviewStateObservable(props.documentPreviewStore, schemaType, value._id, title), [props.documentPreviewStore, schemaType, value._id, title]);
  const status = isLoading ? null : (0, import_jsx_runtime.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [presence && presence.length > 0 && (0, import_jsx_runtime.jsx)(DocumentPreviewPresence, { presence }), (0, import_jsx_runtime.jsx)(DocumentStatusIndicator, { draft, published })] }) });
  const tooltip = (0, import_jsx_runtime.jsx)(DocumentStatus, { draft, published });
  return (0, import_jsx_runtime.jsx)(SanityDefaultPreview, { ...getPreviewValueWithFallback({ value, draft, published }), isPlaceholder: isLoading, icon, layout, status, tooltip });
}
function missingContext() {
  throw new Error("Pane is missing router context");
}
var PaneRouterContext = (0, import_react2.createContext)({ index: 0, groupIndex: 0, siblingIndex: 0, payload: void 0, params: {}, hasGroupSiblings: false, groupLength: 0, routerPanesState: [], BackLink: () => missingContext(), ChildLink: () => missingContext(), ReferenceChildLink: () => missingContext(), handleEditReference: () => missingContext(), ParameterizedLink: () => missingContext(), replaceCurrent: () => missingContext(), closeCurrentAndAfter: () => missingContext(), closeCurrent: () => missingContext(), duplicateCurrent: () => missingContext(), setView: () => missingContext(), setParams: () => missingContext(), setPayload: () => missingContext(), navigateIntent: () => missingContext(), createPathWithParams: () => missingContext() });
var BackLink = (0, import_react2.forwardRef)(function BackLink2(props, ref) {
  const { routerPanesState, groupIndex } = (0, import_react2.useContext)(PaneRouterContext);
  const panes = (0, import_react2.useMemo)(() => routerPanesState.slice(0, groupIndex), [groupIndex, routerPanesState]);
  const state2 = (0, import_react2.useMemo)(() => ({ panes }), [panes]);
  return (0, import_jsx_runtime.jsx)(StateLink, { ...props, ref, state: state2 });
});
var PaneLayoutContext = (0, import_react2.createContext)(null);
function usePaneLayout() {
  const pane = (0, import_react2.useContext)(PaneLayoutContext);
  if (!pane) {
    throw new Error("PaneLayout: missing context value");
  }
  return pane;
}
var ChildLink = (0, import_react2.forwardRef)(function ChildLink2(props, ref) {
  const { childId, childPayload, childParameters, ...rest } = props;
  const { routerPanesState, groupIndex } = (0, import_react2.useContext)(PaneRouterContext);
  return (0, import_jsx_runtime.jsx)(StateLink, { ...rest, ref, state: { panes: [...routerPanesState.slice(0, groupIndex + 1), [{ id: childId, params: childParameters, payload: childPayload }]] } });
});
var ParameterizedLink = (0, import_react2.forwardRef)(function ParameterizedLink2(props, ref) {
  const { routerPanesState: currentPanes, groupIndex, siblingIndex } = (0, import_react2.useContext)(PaneRouterContext);
  const { params, payload, ...rest } = props;
  const nextParams = useUnique(params);
  const nextPayload = useUnique(payload);
  const nextState = (0, import_react2.useMemo)(() => {
    const currentGroup = currentPanes[groupIndex];
    const currentSibling = currentGroup[siblingIndex];
    const nextSibling = { ...currentSibling, params: nextParams != null ? nextParams : currentSibling.params, payload: nextPayload != null ? nextPayload : currentSibling.payload };
    const nextGroup = [...currentGroup.slice(0, siblingIndex), nextSibling, ...currentGroup.slice(siblingIndex + 1)];
    const nextPanes = [...currentPanes.slice(0, groupIndex), nextGroup, ...currentPanes.slice(groupIndex + 1)];
    return { panes: nextPanes };
  }, [currentPanes, groupIndex, nextParams, nextPayload, siblingIndex]);
  return (0, import_jsx_runtime.jsx)(StateLink, { ref, ...rest, state: nextState });
});
var ReferenceChildLink = (0, import_react2.forwardRef)(function ReferenceChildLink2(_ref6, ref) {
  let { documentId, documentType, parentRefPath, children, template: template2, ...rest } = _ref6;
  return (0, import_jsx_runtime.jsx)(ChildLink, { ...rest, ref, childId: documentId, childPayload: template2 == null ? void 0 : template2.params, childParameters: { type: documentType, parentRefPath: toString(parentRefPath), ...template2 && { template: template2 == null ? void 0 : template2.id } }, children });
});
function usePaneRouter() {
  return (0, import_react2.useContext)(PaneRouterContext);
}
var EMPTY_ARRAY$e = [];
function ReferencePreviewLink(props) {
  const { onClick, type, value } = props;
  const publishedId = getPublishedId(value == null ? void 0 : value._id);
  const documentPresence = useDocumentPresence(publishedId);
  const documentPreviewStore = useDocumentPreviewStore();
  const { ReferenceChildLink: ReferenceChildLink3 } = usePaneRouter();
  const Link2 = (0, import_react2.useCallback)(function LinkComponent(linkProps) {
    return (0, import_jsx_runtime.jsx)(ReferenceChildLink3, { documentId: value == null ? void 0 : value._id, documentType: type == null ? void 0 : type.name, parentRefPath: EMPTY_ARRAY$e, ...linkProps });
  }, [ReferenceChildLink3, type == null ? void 0 : type.name, value == null ? void 0 : value._id]);
  return (0, import_jsx_runtime.jsx)(PreviewCard, { __unstable_focusRing: true, as: Link2, "data-as": "a", onClick, radius: 2, children: (0, import_jsx_runtime.jsx)(PaneItemPreview, { documentPreviewStore, icon: type == null ? void 0 : type.icon, layout: "compact", presence: (documentPresence == null ? void 0 : documentPresence.length) > 0 ? documentPresence : EMPTY_ARRAY$e, schemaType: type, value }) });
}
function ConfirmDeleteDialogBody(_ref7) {
  let { crossDatasetReferences, internalReferences, documentTitle, totalCount, action, datasetNames, hasUnknownDatasetNames, onReferenceLinkClick } = _ref7;
  const schema2 = useSchema();
  const toast = useToast();
  const { t } = useTranslation2(structureLocaleNamespace);
  const renderPreviewItem = (0, import_react2.useCallback)((item) => {
    const type = schema2.get(item._type);
    if (type) {
      return (0, import_jsx_runtime.jsx)(ReferencePreviewLink, { type, value: item, onClick: onReferenceLinkClick });
    }
    return (
      // Padding added to match the ReferencePreviewLink styling
      (0, import_jsx_runtime.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime.jsx)(SanityDefaultPreview, { icon: UnknownIcon, title: t("confirm-delete-dialog.preview-item.preview-unavailable.title"), subtitle: t("confirm-delete-dialog.preview-item.preview-unavailable.subtitle", { documentId: item._id }), layout: "default" }) })
    );
  }, [schema2, t, onReferenceLinkClick]);
  if ((internalReferences == null ? void 0 : internalReferences.totalCount) === 0 && (crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) === 0) {
    return (0, import_jsx_runtime.jsx)(Text, { as: "p", size: 1, children: (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "confirm-delete-dialog.confirmation.text", context: action, components: { DocumentTitle: () => (0, import_jsx_runtime.jsx)("strong", { children: documentTitle }) } }) });
  }
  const normalizedDatasetNames = [...datasetNames, ...hasUnknownDatasetNames ? ["unavailable"] : []];
  const datasetSubtitle = t("confirm-delete-dialog.cdr-summary.subtitle", { count: normalizedDatasetNames.length, datasets: normalizedDatasetNames.join(", "), context: hasUnknownDatasetNames && normalizedDatasetNames.length ? "unavailable" : "" });
  return (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", gap: 4, children: [(0, import_jsx_runtime.jsx)(Card, { padding: 3, radius: 2, tone: "caution", flex: "none", children: (0, import_jsx_runtime.jsxs)(Flex, { children: [(0, import_jsx_runtime.jsx)(Text, { "aria-hidden": "true", size: 1, children: (0, import_jsx_runtime.jsx)(WarningOutlineIcon, {}) }), (0, import_jsx_runtime.jsx)(Box, { flex: 1, marginLeft: 3, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(Translate, { i18nKey: "confirm-delete-dialog.referring-document-count.text", components: { DocumentTitle: () => documentTitle }, t, values: { count: totalCount } }) }) })] }) }), (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(Translate, { i18nKey: "confirm-delete-dialog.referring-documents-descriptor.text", t, context: action, components: { DocumentTitle: () => documentTitle } }) }) }), (0, import_jsx_runtime.jsx)(Card, { radius: 2, shadow: 1, flex: "auto", padding: 2, children: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", children: [internalReferences.totalCount > 0 && (0, import_jsx_runtime.jsxs)(Stack, { as: "ul", marginBottom: 2, space: 2, "data-testid": "internal-references", children: [internalReferences == null ? void 0 : internalReferences.references.map((item) => (0, import_jsx_runtime.jsx)(Box, { as: "li", children: renderPreviewItem(item) }, item._id)), internalReferences.totalCount > internalReferences.references.length && (0, import_jsx_runtime.jsx)(Box, { as: "li", padding: 3, children: (0, import_jsx_runtime.jsx)(OtherReferenceCount, { ...internalReferences }) })] }), crossDatasetReferences.totalCount > 0 && (0, import_jsx_runtime.jsxs)(CrossDatasetReferencesDetails, { "data-testid": "cross-dataset-references", style: {
    // only add the border if needed
    borderTop: internalReferences.totalCount > 0 ? "1px solid var(--card-shadow-outline-color)" : void 0
  }, children: [(0, import_jsx_runtime.jsx)(CrossDatasetReferencesSummary, { children: (0, import_jsx_runtime.jsx)(Card, { as: "a", marginTop: internalReferences.totalCount > 0 ? 2 : 0, radius: 2, shadow: 1, paddingY: 1, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, paddingX: 3, paddingY: 1, children: [(0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(DocumentsIcon, {}) }), (0, import_jsx_runtime.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime.jsx)(Text, { textOverflow: "ellipsis", size: 1, children: t("confirm-delete-dialog.cdr-summary.title", { count: normalizedDatasetNames.length, documentCount: t("confirm-delete-dialog.cdr-summary.document-count", { count: crossDatasetReferences.totalCount }) }) }), (0, import_jsx_runtime.jsx)(Text, { title: datasetSubtitle, textOverflow: "ellipsis", size: 1, muted: true, children: datasetSubtitle })] }), (0, import_jsx_runtime.jsx)(ChevronWrapper, { children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime.jsx)(ChevronDownIcon, {}) }) })] }) }) }), (0, import_jsx_runtime.jsxs)(Box, { overflow: "auto", paddingTop: 2, children: [(0, import_jsx_runtime.jsxs)(Table, { children: [(0, import_jsx_runtime.jsx)("thead", { children: (0, import_jsx_runtime.jsxs)("tr", { children: [(0, import_jsx_runtime.jsx)("th", { children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, style: { minWidth: "5rem" }, weight: "medium", children: t("confirm-delete-dialog.cdr-table.project-id.label") }) }), (0, import_jsx_runtime.jsx)("th", { children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.dataset.label") }) }), (0, import_jsx_runtime.jsx)("th", { children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, weight: "medium", children: t("confirm-delete-dialog.cdr-table.document-id.label") }) })] }) }), (0, import_jsx_runtime.jsx)("tbody", { children: crossDatasetReferences.references.filter((reference) => {
    return "projectId" in reference;
  }).map((_ref8, index) => {
    let { projectId, datasetName, documentId } = _ref8;
    return (
      // eslint-disable-next-line react/no-array-index-key
      (0, import_jsx_runtime.jsxs)("tr", { children: [(0, import_jsx_runtime.jsx)("td", { children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: projectId }) }), (0, import_jsx_runtime.jsx)("td", { children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: datasetName || "unavailable" }) }), (0, import_jsx_runtime.jsx)("td", { children: (0, import_jsx_runtime.jsxs)(DocumentIdFlex, { align: "center", gap: 2, justify: "flex-end", children: [(0, import_jsx_runtime.jsx)(Text, { textOverflow: "ellipsis", size: 1, children: documentId || "unavailable" }), documentId && (0, import_jsx_runtime.jsx)(import_react_copy_to_clipboard.default, { text: documentId, onCopy: () => {
        toast.push({ title: t("confirm-delete-dialog.cdr-table.id-copied-toast.title"), status: "success" });
      }, children: (0, import_jsx_runtime.jsx)(Button2, { mode: "bleed", icon: CopyIcon, tooltipProps: { content: t("confirm-delete-dialog.cdr-table.copy-id-button.tooltip") } }) })] }) })] }, "".concat(documentId, "-").concat(index))
    );
  }) })] }), (0, import_jsx_runtime.jsx)(OtherReferenceCount, { ...crossDatasetReferences })] })] })] }) }), (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(Translate, { i18nKey: "confirm-delete-dialog.referential-integrity-disclaimer.text", t, context: action, components: { DocumentTitle: () => documentTitle } }) }) })] });
}
function isClientError(e2) {
  if (typeof e2 !== "object")
    return false;
  if (!e2)
    return false;
  return "statusCode" in e2 && "response" in e2;
}
var POLL_INTERVAL = 5e3;
var visiblePoll$;
var getVisiblePoll$ = () => {
  if (!visiblePoll$) {
    visiblePoll$ = fromEvent(document, "visibilitychange").pipe(
      // add empty emission to have this fire on creation
      startWith(null),
      map(() => document.visibilityState === "visible"),
      distinctUntilChanged(),
      switchMap((visible) => visible ? (
        // using timer instead of interval since timer will emit on creation
        timer(0, POLL_INTERVAL)
      ) : EMPTY),
      shareReplay({ refCount: true, bufferSize: 1 })
    );
  }
  return visiblePoll$;
};
function getDocumentExistence(documentId, _ref9) {
  let { versionedClient } = _ref9;
  const draftId = getDraftId(documentId);
  const publishedId = getPublishedId(documentId);
  const requestOptions = { uri: versionedClient.getDataUrl("doc", "".concat(draftId, ",").concat(publishedId)), json: true, query: { excludeContent: "true" }, tag: "use-referring-documents.document-existence" };
  return versionedClient.observable.request(requestOptions).pipe(map((_ref10) => {
    let { omitted } = _ref10;
    const nonExistant = omitted.filter((doc) => doc.reason === "existence");
    if (nonExistant.length === 2) {
      return void 0;
    }
    if (nonExistant.length === 0) {
      return publishedId;
    }
    return nonExistant.some((doc) => doc.id === draftId) ? publishedId : draftId;
  }));
}
function fetchCrossDatasetReferences(documentId, context) {
  const { versionedClient } = context;
  return getVisiblePoll$().pipe(switchMap(() => getDocumentExistence(documentId, context)), switchMap((checkDocumentId) => {
    if (!checkDocumentId) {
      return of({ totalCount: 0, references: [] });
    }
    const currentDataset = versionedClient.config().dataset;
    return versionedClient.observable.request({ url: "/data/references/".concat(currentDataset, "/documents/").concat(checkDocumentId, "/to?excludeInternalReferences=true&excludePaths=true"), tag: "use-referring-documents.external" }).pipe(catchError((e2) => {
      if (isClientError(e2) && e2.statusCode === 404) {
        return of({ totalCount: 0, references: [] });
      }
      throw e2;
    }));
  }));
}
var useInternalReferences = createHookFromObservableFactory((_ref11) => {
  let [documentId, documentStore] = _ref11;
  const referencesClause = "*[references($documentId)][0...100]{_id,_type}";
  const totalClause = "count(*[references($documentId)])";
  const fetchQuery = '{"references":'.concat(referencesClause, ',"totalCount":').concat(totalClause, "}");
  const listenQuery = "*[references($documentId)]";
  return documentStore.listenQuery({ fetch: fetchQuery, listen: listenQuery }, { documentId }, { tag: "use-referring-documents", transitions: ["appear", "disappear"], throttleTime: 5e3 });
});
var useCrossDatasetReferences = createHookFromObservableFactory((_ref12) => {
  let [documentId, versionedClient] = _ref12;
  return getVisiblePoll$().pipe(switchMap(() => fetchCrossDatasetReferences(documentId, { versionedClient })));
});
function useReferringDocuments(documentId) {
  const versionedClient = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const documentStore = useDocumentStore();
  const publishedId = getPublishedId(documentId);
  const [internalReferences, isInternalReferencesLoading] = useInternalReferences((0, import_react2.useMemo)(() => [publishedId, documentStore], [documentStore, publishedId]));
  const [crossDatasetReferences, isCrossDatasetReferencesLoading] = useCrossDatasetReferences((0, import_react2.useMemo)(() => [publishedId, versionedClient], [publishedId, versionedClient]));
  const projectIds = (0, import_react2.useMemo)(() => {
    return Array.from(new Set(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => crossDatasetReference.projectId).filter(Boolean))).sort();
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  const datasetNames = (0, import_react2.useMemo)(() => {
    return Array.from(new Set(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.map((crossDatasetReference) => (crossDatasetReference == null ? void 0 : crossDatasetReference.datasetName) || "").filter((datasetName) => Boolean(datasetName) && datasetName !== ""))).sort();
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  const hasUnknownDatasetNames = (0, import_react2.useMemo)(() => {
    return Boolean(crossDatasetReferences == null ? void 0 : crossDatasetReferences.references.some((crossDatasetReference) => typeof crossDatasetReference.datasetName !== "string"));
  }, [crossDatasetReferences == null ? void 0 : crossDatasetReferences.references]);
  return { totalCount: ((internalReferences == null ? void 0 : internalReferences.totalCount) || 0) + ((crossDatasetReferences == null ? void 0 : crossDatasetReferences.totalCount) || 0), projectIds, datasetNames, hasUnknownDatasetNames, internalReferences, crossDatasetReferences, isLoading: isInternalReferencesLoading || isCrossDatasetReferencesLoading };
}
var __freeze$11 = Object.freeze;
var __defProp$11 = Object.defineProperty;
var __template$11 = (cooked, raw) => __freeze$11(__defProp$11(cooked, "raw", { value: __freeze$11(raw || cooked.slice()) }));
var _a$11;
var _b$p;
var DialogBody = ut(Box)(_a$11 || (_a$11 = __template$11(["\n  box-sizing: border-box;\n"])));
var LoadingContainer = ut(Flex).attrs({ align: "center", direction: "column", justify: "center" })(_b$p || (_b$p = __template$11(["\n  height: 110px;\n"])));
function ConfirmDeleteDialog(_ref13) {
  let { id, type, action = "delete", onCancel, onConfirm } = _ref13;
  const { t } = useTranslation2(structureLocaleNamespace);
  const dialogId = "deletion-confirmation-".concat((0, import_react2.useId)());
  const { internalReferences, crossDatasetReferences, isLoading, totalCount, projectIds, datasetNames, hasUnknownDatasetNames } = useReferringDocuments(id);
  const documentTitle = (0, import_jsx_runtime.jsx)(DocTitle, { document: (0, import_react2.useMemo)(() => ({ _id: id, _type: type }), [id, type]) });
  const showConfirmButton = !isLoading;
  return (0, import_jsx_runtime.jsx)(Dialog2, { width: 1, id: dialogId, header: t("confirm-delete-dialog.header.text", { context: action }), footer: { cancelButton: { onClick: onCancel, text: t("confirm-delete-dialog.cancel-button.text") }, confirmButton: showConfirmButton ? { text: totalCount > 0 ? t("confirm-delete-dialog.confirm-anyway-button.text", { context: action }) : t("confirm-delete-dialog.confirm-button.text", { context: action }), onClick: onConfirm } : void 0 }, onClose: onCancel, onClickOutside: onCancel, children: (0, import_jsx_runtime.jsx)(DialogBody, { children: crossDatasetReferences && internalReferences && !isLoading ? (0, import_jsx_runtime.jsx)(ConfirmDeleteDialogBody, { crossDatasetReferences, internalReferences, documentTitle, isLoading, totalCount, action, projectIds, datasetNames, hasUnknownDatasetNames, onReferenceLinkClick: onCancel }) : (0, import_jsx_runtime.jsx)(LoadingContainer, { "data-testid": "loading-container", children: (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true, title: t("confirm-delete-dialog.loading.text") }) }) }) });
}
function ConfirmDeleteDialogContainer(props) {
  const { t } = useTranslation2(structureLocaleNamespace);
  const id = (0, import_react2.useId)();
  const [error, setError] = (0, import_react2.useState)(null);
  const handleRetry = (0, import_react2.useCallback)(() => setError(null), []);
  return error ? (0, import_jsx_runtime.jsx)(Dialog2, { id: "dialog-error-".concat(id), "data-testid": "confirm-delete-error-dialog", header: t("confirm-delete-dialog.error.title.text"), footer: { confirmButton: { text: t("confirm-delete-dialog.error.retry-button.text"), onClick: handleRetry, tone: "default" } }, onClose: props.onCancel, children: (0, import_jsx_runtime.jsx)(Box, { padding: 4, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: t("confirm-delete-dialog.error.message.text") }) }) }) : (0, import_jsx_runtime.jsx)(ErrorBoundary, { onCatch: setError, children: (0, import_jsx_runtime.jsx)(ConfirmDeleteDialog, { ...props }) });
}
function Delay(_ref14) {
  let { children, ms = 0 } = _ref14;
  const [ready, setReady] = (0, import_react2.useState)(ms <= 0);
  (0, import_react2.useEffect)(() => {
    if (ms <= 0) {
      return void 0;
    }
    const timeoutId = setTimeout(() => setReady(true), ms);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [ms]);
  if (!ready || !children) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
  }
  return typeof children === "function" ? children() : children;
}
var PANE_DEBUG = false;
var PANE_COLLAPSED_WIDTH = 51;
var PANE_DEFAULT_MIN_WIDTH = PANE_COLLAPSED_WIDTH * 4;
var PaneContext = (0, import_react2.createContext)(null);
var __freeze$10 = Object.freeze;
var __defProp$10 = Object.defineProperty;
var __template$10 = (cooked, raw) => __freeze$10(__defProp$10(cooked, "raw", { value: __freeze$10(raw || cooked.slice()) }));
var _a$10;
var Root$f = ut(Layer)(_a$10 || (_a$10 = __template$10(["\n  position: relative;\n  width: 1px;\n  min-width: 1px;\n\n  &:before {\n    content: '';\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    width: 1px;\n    background-color: var(--card-border-color);\n  }\n\n  &:not([data-disabled]) {\n    cursor: ew-resize;\n    width: 9px;\n    min-width: 9px;\n    margin: 0 -4px;\n\n    &:before {\n      left: 4px;\n    }\n\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      left: 0;\n      width: 9px;\n      bottom: 0;\n      background-color: var(--card-border-color);\n      opacity: 0;\n      transition: opacity 150ms;\n    }\n\n    &[data-dragging]:after,\n    &:hover:after {\n      opacity: 0.2;\n    }\n  }\n"])));
function PaneDivider(_ref15) {
  let { disabled, element } = _ref15;
  const { resize } = usePaneLayout();
  const [dragging, setDragging] = (0, import_react2.useState)(false);
  const handleMouseDown = (0, import_react2.useCallback)((event) => {
    if (!element)
      return;
    setDragging(true);
    event.preventDefault();
    const startX = event.pageX;
    resize("start", element, 0);
    const handleMouseMove = (e2) => {
      e2.preventDefault();
      const deltaX = e2.pageX - startX;
      resize("move", element, deltaX);
    };
    const handleMouseUp = (e2) => {
      e2.preventDefault();
      setDragging(false);
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
      resize("end", element, 0);
    };
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
  }, [element, resize]);
  return (0, import_jsx_runtime.jsx)(Root$f, { "data-disabled": disabled ? "" : void 0, "data-dragging": dragging ? "" : void 0, onMouseDown: handleMouseDown });
}
var __freeze$$ = Object.freeze;
var __defProp$$ = Object.defineProperty;
var __template$$ = (cooked, raw) => __freeze$$(__defProp$$(cooked, "raw", { value: __freeze$$(raw || cooked.slice()) }));
var _a$$;
var Root$e = ut(Card)(_a$$ || (_a$$ = __template$$(["\n  outline: none;\n\n  // NOTE: This will render a border to the right side of each pane\n  // without taking up physical space.\n  box-shadow: 1px 0 0 var(--card-border-color);\n"])));
var Pane = (0, import_react2.forwardRef)(function Pane2(props, ref) {
  var _a2, _b2, _c2;
  const { children, currentMinWidth: currentMinWidthProp, currentMaxWidth: currentMaxWidthProp, flex: flexProp = 1, id, minWidth: minWidthProp, maxWidth: maxWidthProp, selected = false, ...restProps } = props;
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const { collapse, collapsed: layoutCollapsed, expand, expandedElement, mount, panes } = usePaneLayout();
  const pane = panes.find((p) => p.element === rootElement);
  const paneIndex = pane && panes.indexOf(pane);
  const nextPane = typeof paneIndex === "number" ? panes[paneIndex + 1] : void 0;
  const isLast = paneIndex === panes.length - 1;
  const collapsed = layoutCollapsed ? false : (pane == null ? void 0 : pane.collapsed) || false;
  const nextCollapsed = (nextPane == null ? void 0 : nextPane.collapsed) || false;
  const forwardedRef = useForwardedRef(ref);
  const flex = (_a2 = pane == null ? void 0 : pane.flex) != null ? _a2 : flexProp;
  const currentMinWidth = (_b2 = pane == null ? void 0 : pane.currentMinWidth) != null ? _b2 : currentMinWidthProp;
  const currentMaxWidth = (_c2 = pane == null ? void 0 : pane.currentMaxWidth) != null ? _c2 : currentMaxWidthProp;
  const setRef = (0, import_react2.useCallback)((refValue) => {
    setRootElement(refValue);
    forwardedRef.current = refValue;
  }, [forwardedRef]);
  (0, import_react2.useEffect)(() => {
    if (!rootElement)
      return void 0;
    return mount(rootElement, { currentMinWidth: currentMinWidthProp, currentMaxWidth: currentMaxWidthProp, flex: flexProp, id, minWidth: minWidthProp, maxWidth: maxWidthProp });
  }, [currentMinWidthProp, currentMaxWidthProp, flexProp, id, minWidthProp, maxWidthProp, mount, rootElement]);
  const handleCollapse = (0, import_react2.useCallback)(() => {
    if (!rootElement)
      return;
    collapse(rootElement);
  }, [collapse, rootElement]);
  const handleExpand = (0, import_react2.useCallback)(() => {
    if (!rootElement)
      return;
    expand(rootElement);
  }, [expand, rootElement]);
  const contextValue = (0, import_react2.useMemo)(() => ({ collapse: handleCollapse, collapsed: layoutCollapsed ? false : collapsed, expand: handleExpand, index: paneIndex, isLast, rootElement }), [collapsed, handleCollapse, handleExpand, isLast, layoutCollapsed, paneIndex, rootElement]);
  const minWidth = (0, import_react2.useMemo)(() => {
    if (layoutCollapsed) {
      return void 0;
    }
    if (collapsed)
      return PANE_COLLAPSED_WIDTH;
    if (currentMinWidth === 0) {
      return minWidthProp || PANE_DEFAULT_MIN_WIDTH;
    }
    if (isLast) {
      return minWidthProp || PANE_DEFAULT_MIN_WIDTH;
    }
    return currentMinWidth || minWidthProp || PANE_DEFAULT_MIN_WIDTH;
  }, [collapsed, currentMinWidth, isLast, layoutCollapsed, minWidthProp]);
  const maxWidth = (0, import_react2.useMemo)(() => {
    if (collapsed)
      return PANE_COLLAPSED_WIDTH;
    if (layoutCollapsed && isLast) {
      return void 0;
    }
    if (isLast) {
      if (maxWidthProp) {
        return currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
      }
      return void 0;
    }
    return currentMaxWidth != null ? currentMaxWidth : maxWidthProp;
  }, [collapsed, currentMaxWidth, isLast, layoutCollapsed, maxWidthProp]);
  const hidden = layoutCollapsed && !isLast;
  const divider = (0, import_react2.useMemo)(() => !isLast && !layoutCollapsed && (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "paneResizer", children: (0, import_jsx_runtime.jsx)(PaneDivider, { disabled: collapsed || nextCollapsed, element: rootElement }) }), [collapsed, isLast, layoutCollapsed, nextCollapsed, rootElement]);
  const style = (0, import_react2.useMemo)(() => ({ flex, minWidth, maxWidth: maxWidth === Infinity ? void 0 : maxWidth }), [flex, minWidth, maxWidth]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "pane", children: (0, import_jsx_runtime.jsx)(PaneContext.Provider, { value: contextValue, children: (0, import_jsx_runtime.jsxs)(Root$e, { "data-testid": "pane", "data-ui": "Pane", tone: "inherit", hidden, id, overflow: layoutCollapsed ? void 0 : "hidden", ...restProps, "data-pane-collapsed": collapsed ? "" : void 0, "data-pane-index": paneIndex, "data-pane-selected": selected ? "" : void 0, ref: setRef, style, children: [PANE_DEBUG, (0, import_jsx_runtime.jsx)(BoundaryElementProvider, { element: rootElement, children: !hidden && (0, import_jsx_runtime.jsx)(Flex, { direction: "column", height: "fill", children }) })] }) }) }), divider] });
});
var __freeze$_ = Object.freeze;
var __defProp$_ = Object.defineProperty;
var __template$_ = (cooked, raw) => __freeze$_(__defProp$_(cooked, "raw", { value: __freeze$_(raw || cooked.slice()) }));
var _a$_;
var Root$d = ut(Card)(_a$_ || (_a$_ = __template$_(["\n  position: relative;\n  outline: none;\n"])));
Root$d.displayName = "PaneContent__root";
function usePane() {
  const pane = (0, import_react2.useContext)(PaneContext);
  if (!pane) {
    throw new Error("Pane: missing context value");
  }
  return pane;
}
var PaneContent = (0, import_react2.forwardRef)(function PaneContent2(props, ref) {
  const { as, children, overflow, padding, ...restProps } = props;
  const { collapsed } = usePane();
  const { collapsed: layoutCollapsed } = usePaneLayout();
  return (0, import_jsx_runtime.jsx)(Root$d, { "data-testid": "pane-content", forwardedAs: as, ...restProps, flex: 1, hidden: collapsed, overflow: layoutCollapsed ? void 0 : overflow, padding, ref, tone: "inherit", children });
});
var MENU_GROUP_POPOVER_PROPS = { constrainSize: true, placement: "left-start", portal: true };
function PaneMenuButtonItem(props) {
  const { disabled, isAfterGroup, node } = props;
  const getI18nText = useGetI18nText("i18n" in node ? node : void 0);
  if (node.type === "divider") {
    return (0, import_jsx_runtime.jsx)(MenuDivider, {});
  }
  const { title } = getI18nText(node);
  if (node.type === "group") {
    if (node.children.length === 0) {
      return null;
    }
    if (node.expanded) {
      return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [isAfterGroup && (0, import_jsx_runtime.jsx)(MenuDivider, {}), node.children.map((child, childIndex) => {
        var _a2;
        return (0, import_jsx_runtime.jsx)(PaneMenuButtonItem, { disabled: disabled || Boolean(node.disabled), isAfterGroup: ((_a2 = node.children[childIndex - 1]) == null ? void 0 : _a2.type) === "group", node: child }, child.key);
      })] });
    }
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [isAfterGroup && (0, import_jsx_runtime.jsx)(MenuDivider, {}), (0, import_jsx_runtime.jsx)(MenuGroup, { disabled, icon: node.icon, popover: MENU_GROUP_POPOVER_PROPS, text: title, children: node.children.map((child, childIndex) => {
      var _a2;
      return (0, import_jsx_runtime.jsx)(PaneMenuButtonItem, { disabled: disabled || Boolean(node.disabled), isAfterGroup: ((_a2 = node.children[childIndex - 1]) == null ? void 0 : _a2.type) === "group", node: child }, child.key);
    }) })] });
  }
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [isAfterGroup && (0, import_jsx_runtime.jsx)(MenuDivider, {}), (0, import_jsx_runtime.jsx)(PaneContextMenuItemResolver, { disabled, node })] });
}
function PaneContextMenuItemResolver(props) {
  const { node } = props;
  if (node.intent) {
    return (0, import_jsx_runtime.jsx)(PaneContextIntentMenuItem, { ...props, intent: node.intent });
  }
  return (0, import_jsx_runtime.jsx)(PaneContextMenuItem, { ...props });
}
function PaneContextMenuItem(props) {
  var _a2;
  const { disabled, node } = props;
  const tooltipContent = typeof node.disabled === "object" && (0, import_jsx_runtime.jsx)(Text, { size: 1, children: node.disabled.reason });
  const { title } = useI18nText(node);
  return (0, import_jsx_runtime.jsx)(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: (0, import_jsx_runtime.jsx)(MenuItem2, { disabled: disabled || Boolean(node.disabled), hotkeys: (_a2 = node.hotkey) == null ? void 0 : _a2.split("+"), icon: node.icon, iconRight: node.iconRight || node.selected && CheckmarkIcon, onClick: node.onAction, pressed: node.selected, text: title, tone: node.tone }) });
}
function PaneContextIntentMenuItem(props) {
  var _a2;
  const { disabled, intent, node } = props;
  const tooltipContent = typeof node.disabled === "object" && (0, import_jsx_runtime.jsx)(Text, { size: 1, children: node.disabled.reason });
  const intentLink = useIntentLink({ intent: intent.type, params: intent.params });
  const handleClick = (0, import_react2.useCallback)((event) => {
    intentLink.onClick(event);
    node.onAction();
  }, [intentLink, node]);
  const { title } = useI18nText(node);
  return (0, import_jsx_runtime.jsx)(TooltipOfDisabled, { content: tooltipContent, placement: "left", children: (0, import_jsx_runtime.jsx)(MenuItem2, { as: "a", disabled: disabled || Boolean(node.disabled), hotkeys: (_a2 = node.hotkey) == null ? void 0 : _a2.split("+"), href: intentLink.href, icon: node.icon, iconRight: node.selected ? CheckmarkIcon : void 0, onClick: handleClick, pressed: node.selected, text: title, tone: node.tone }) });
}
var CONTEXT_MENU_POPOVER_PROPS = { constrainSize: true, placement: "bottom", portal: true };
function nodesHasTone(nodes, tone) {
  return nodes.some((node) => {
    return node.type === "item" && node.tone === tone || node.type === "group" && nodesHasTone(node.children, tone);
  });
}
function PaneContextMenuButton(props) {
  const { nodes, actionsNodes } = props;
  const id = (0, import_react2.useId)();
  const hasCritical = nodesHasTone(nodes, "critical");
  const hasCaution = nodesHasTone(nodes, "caution");
  return (0, import_jsx_runtime.jsx)(MenuButton, { button: (0, import_jsx_runtime.jsx)(ContextMenuButton, { tone: hasCritical ? "critical" : hasCaution ? "caution" : void 0, "data-testid": "pane-context-menu-button" }), id, menu: (0, import_jsx_runtime.jsxs)(Menu, { children: [actionsNodes && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [actionsNodes, (0, import_jsx_runtime.jsx)(MenuDivider, {})] }), nodes.map((node, nodeIndex) => {
    var _a2;
    const isAfterGroup = ((_a2 = nodes[nodeIndex - 1]) == null ? void 0 : _a2.type) === "group";
    return (0, import_jsx_runtime.jsx)(PaneMenuButtonItem, { isAfterGroup, node }, node.key);
  })] }), popover: CONTEXT_MENU_POPOVER_PROPS });
}
var __freeze$Z = Object.freeze;
var __defProp$Z = Object.defineProperty;
var __template$Z = (cooked, raw) => __freeze$Z(__defProp$Z(cooked, "raw", { value: __freeze$Z(raw || cooked.slice()) }));
var _a$Z;
var _b$o;
var Root$c = ut(Layer)(_a$Z || (_a$Z = __template$Z(["\n  position: sticky;\n  bottom: 0;\n\n  &:before {\n    content: '';\n    display: block;\n    position: absolute;\n    left: 0;\n    right: 0;\n    top: -1px;\n    border-bottom: 1px solid var(--card-border-color);\n  }\n"])));
var RootCard$1 = ut(Card)(_b$o || (_b$o = __template$Z(["\n  padding-bottom: env(safe-area-inset-bottom);\n"])));
var PaneFooter = (0, import_react2.forwardRef)(function PaneFooter2(props, ref) {
  const { children, padding } = props;
  const { collapsed } = usePane();
  return (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "paneFooter", children: (0, import_jsx_runtime.jsx)(Root$c, { "data-testid": "pane-footer", hidden: collapsed, ref, children: (0, import_jsx_runtime.jsx)(RootCard$1, { tone: "inherit", children: (0, import_jsx_runtime.jsx)(Box, { padding, children }) }) }) });
});
var __freeze$Y = Object.freeze;
var __defProp$Y = Object.defineProperty;
var __template$Y = (cooked, raw) => __freeze$Y(__defProp$Y(cooked, "raw", { value: __freeze$Y(raw || cooked.slice()) }));
var _a$Y;
var _b$n;
var _c$a;
var _d$4;
var _e$2;
var _f$2;
var Root$b = ut(Layer)((_ref16) => {
  let { $border } = _ref16;
  return at(_a$Y || (_a$Y = __template$Y(["\n    line-height: 0;\n    position: sticky;\n    top: 0;\n\n    &:not([data-collapsed]):after {\n      content: '';\n      display: block;\n      position: absolute;\n      left: 0;\n      right: 0;\n      bottom: -1px;\n      border-bottom: 1px solid ", ";\n      opacity: 1;\n    }\n  "])), $border ? "var(--card-border-color)" : "transparent");
});
var Layout = ut(Flex)(_b$n || (_b$n = __template$Y(["\n  transform-origin: calc(51px / 2);\n\n  [data-collapsed] > div > & {\n    transform: rotate(90deg);\n  }\n"])));
var TitleCard = ut(Card)((_ref17) => {
  let { theme } = _ref17;
  const { fg, bg } = theme.sanity.color.card.enabled;
  return at(_c$a || (_c$a = __template$Y(["\n    background-color: ", ";\n\n    [data-ui='Text'] {\n      color: ", ";\n    }\n  "])), bg, fg);
});
var TitleTextSkeleton = ut(TextSkeleton)(_d$4 || (_d$4 = __template$Y(["\n  width: 66%;\n  max-width: 175px;\n"])));
var TitleText = ut(Text)(_e$2 || (_e$2 = __template$Y(["\n  cursor: default;\n  outline: none;\n"])));
var TabsBox = ut(Box)((_ref18) => {
  let { theme } = _ref18;
  const { color, space } = theme.sanity;
  return at(_f$2 || (_f$2 = __template$Y(["\n    overflow: hidden;\n    overflow: clip;\n    position: relative;\n\n    & > div {\n      white-space: nowrap;\n      overflow: auto;\n      /* Hide scrollbars */\n      scrollbar-width: none;\n      &::-webkit-scrollbar {\n        width: 0;\n        height: 0;\n      }\n    }\n\n    /* right padding */\n    & > div:after {\n      content: '';\n      display: inline-block;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      width: ", "px;\n      height: 1px;\n    }\n\n    /* Gradient that makes it look like tabs disappear into nothing (looks nicer) */\n    &:after {\n      content: '';\n      display: block;\n      position: absolute;\n      top: 0;\n      right: 0;\n      bottom: 0;\n      background: linear-gradient(to right, ", ", var(--card-bg-color));\n      width: ", "px;\n      pointer-events: none;\n    }\n  "])), space[3], rgba(color.base.bg, 0), space[3]);
});
var PaneHeader = (0, import_react2.forwardRef)(function PaneHeader2(props, ref) {
  const { actions, backButton, border, contentAfter, loading, subActions, tabs, tabIndex, title } = props;
  const { collapse, collapsed, expand, rootElement: paneElement } = usePane();
  const paneRect = useElementRect(paneElement || null);
  const layoutStyle = (0, import_react2.useMemo)(() => ({ width: collapsed ? (paneRect == null ? void 0 : paneRect.height) || window.innerHeight : void 0 }), [collapsed, paneRect]);
  const handleTitleClick = (0, import_react2.useCallback)(() => {
    if (collapsed)
      return;
    collapse();
  }, [collapse, collapsed]);
  const handleLayoutClick = (0, import_react2.useCallback)(() => {
    if (!collapsed)
      return;
    expand();
  }, [collapsed, expand]);
  const showTabsOrSubActions = Boolean(!collapsed && (tabs || subActions));
  return (0, import_jsx_runtime.jsx)(LayerProvider, { zOffset: 100, children: (0, import_jsx_runtime.jsx)(Root$b, { $border: border, "data-collapsed": collapsed ? "" : void 0, "data-testid": "pane-header", ref, children: (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "paneHeader", children: (0, import_jsx_runtime.jsxs)(Card, { "data-collapsed": collapsed ? "" : void 0, tone: "inherit", children: [(0, import_jsx_runtime.jsxs)(Layout, { gap: 1, onClick: handleLayoutClick, padding: 3, paddingBottom: collapsed ? 3 : 2, sizing: "border", style: layoutStyle, children: [backButton && (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: backButton }), (0, import_jsx_runtime.jsxs)(TitleCard, { __unstable_focusRing: true, flex: 1, forwardedAs: "button", onClick: handleTitleClick, paddingLeft: backButton ? 1 : 2, padding: 2, tabIndex, children: [loading && (0, import_jsx_runtime.jsx)(TitleTextSkeleton, { animated: true, radius: 1, size: 1 }), !loading && (0, import_jsx_runtime.jsx)(TitleText, { size: 1, textOverflow: "ellipsis", weight: "semibold", children: title })] }), actions && (0, import_jsx_runtime.jsx)(Flex, { align: "center", hidden: collapsed, children: (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "paneHeader", children: actions }) })] }), showTabsOrSubActions && (0, import_jsx_runtime.jsxs)(Flex, { align: "center", hidden: collapsed, overflow: "auto", paddingBottom: 3, paddingX: 3, children: [(0, import_jsx_runtime.jsx)(TabsBox, { flex: 1, marginRight: subActions ? 3 : 0, children: tabs }), subActions && subActions] }), !collapsed && contentAfter && contentAfter] }) }) }) });
});
function getDisabledReason$1(node) {
  var _a2;
  if (!node.disabled) {
    return { disabledReason: void 0, ariaLabel: void 0, isDisabled: false };
  }
  const disabledReason = typeof node.disabled === "object" ? node.disabled.reason : void 0;
  const ariaLabel = typeof node.disabled === "object" && typeof ((_a2 = node.disabled) == null ? void 0 : _a2.reason) === "string" ? node.disabled.reason : "This is disabled";
  return { disabledReason, ariaLabel, isDisabled: Boolean(node.disabled) };
}
function PaneHeaderActionButton(props) {
  const { node } = props;
  if (node.type === "item") {
    return (0, import_jsx_runtime.jsx)(PaneHeaderMenuItemActionButton, { node });
  }
  if (node.type === "group") {
    return (0, import_jsx_runtime.jsx)(PaneHeaderMenuGroupActionButton, { node });
  }
  console.warn('unknown menu node (expected `type: "item" | "group"`):', node);
  return null;
}
function PaneHeaderMenuItemActionButton(props) {
  const { node } = props;
  const { title } = useI18nText(node);
  if (node.intent) {
    return (0, import_jsx_runtime.jsx)(PaneHeaderActionIntentButton, { ...props, intent: node.intent });
  }
  const { disabledReason, ariaLabel, isDisabled } = getDisabledReason$1(node);
  return (0, import_jsx_runtime.jsx)(StatusButton, { disabled: isDisabled, icon: node.icon, onClick: node.onAction, selected: node.selected, tone: node.tone, "aria-label": ariaLabel, tooltipProps: { hotkeys: !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0, content: isDisabled ? disabledReason : title } });
}
function PaneHeaderActionIntentButton(props) {
  const { intent, node } = props;
  const intentLink = useIntentLink({ intent: intent.type, params: intent.params });
  const handleClick = (0, import_react2.useCallback)((event) => {
    intentLink.onClick(event);
    node.onAction();
  }, [intentLink, node]);
  const { disabledReason, ariaLabel, isDisabled } = getDisabledReason$1(node);
  return (0, import_jsx_runtime.jsx)(StatusButton, { forwardedAs: "a", disabled: isDisabled, href: intentLink.href, icon: node.icon, onClick: handleClick, selected: node.selected, tone: node.tone, "aria-label": ariaLabel, tooltipProps: { hotkeys: !isDisabled && node.hotkey ? node.hotkey.split("+") : void 0, content: isDisabled ? disabledReason : node.title, placement: "bottom", portal: true } });
}
function PaneHeaderMenuGroupActionButton(props) {
  var _a2;
  const { node } = props;
  const { title } = useI18nText(node);
  return (0, import_jsx_runtime.jsx)(MenuButton, { button: (0, import_jsx_runtime.jsx)(Button2, { disabled: !!node.disabled, icon: (_a2 = node.icon) != null ? _a2 : UnknownIcon, label: title, mode: "bleed", tooltipProps: { content: node.title, portal: true } }), id: (0, import_react2.useId)(), menu: (0, import_jsx_runtime.jsx)(Menu, { children: node.children.map((child, idx) => {
    var _a22;
    return (0, import_jsx_runtime.jsx)(PaneMenuButtonItem, { disabled: Boolean(node.disabled), isAfterGroup: ((_a22 = node.children[idx - 1]) == null ? void 0 : _a22.type) === "group", node: child }, child.key);
  }) }) });
}
var __freeze$X = Object.freeze;
var __defProp$X = Object.defineProperty;
var __template$X = (cooked, raw) => __freeze$X(__defProp$X(cooked, "raw", { value: __freeze$X(raw || cooked.slice()) }));
var _a$X;
var Root$a = ut(Card)(_a$X || (_a$X = __template$X(["\n  transition: opacity 200ms;\n  position: relative;\n  z-index: 1;\n  padding-left: env(safe-area-inset-left);\n  padding-right: env(safe-area-inset-right);\n  opacity: 0;\n\n  &:not([hidden]) {\n    display: flex;\n  }\n\n  &:not([data-collapsed]) {\n    overflow: auto;\n  }\n\n  &[data-mounted] {\n    opacity: 1;\n  }\n\n  &[data-resizing] {\n    pointer-events: none;\n  }\n"])));
function _calcPaneResize(cache, left, right, deltaX) {
  var _a2, _b2;
  const sum = { flex: cache.left.flex + cache.right.flex, width: cache.left.width + cache.right.width };
  const leftMinWidth = (_a2 = left.minWidth) != null ? _a2 : PANE_DEFAULT_MIN_WIDTH;
  const rightMinWidth = (_b2 = right.minWidth) != null ? _b2 : PANE_DEFAULT_MIN_WIDTH;
  const leftMaxWidth = Math.min(left.maxWidth || Infinity, sum.width - rightMinWidth);
  const rightMaxWidth = Math.min(right.maxWidth || Infinity, sum.width - leftMinWidth);
  let minDeltaX = leftMinWidth - cache.left.width;
  const rightMinDeltaX = cache.right.width - rightMaxWidth;
  if (minDeltaX < rightMinDeltaX) {
    minDeltaX = rightMinDeltaX;
  }
  let maxDeltaX = cache.right.width - rightMinWidth;
  const leftMaxDeltaX = leftMaxWidth - cache.left.width;
  if (maxDeltaX > leftMaxDeltaX) {
    maxDeltaX = leftMaxDeltaX;
  }
  const _deltaX = Math.min(Math.max(deltaX, minDeltaX), maxDeltaX);
  const leftW = cache.left.width + _deltaX;
  const rightW = cache.right.width - _deltaX;
  const leftFlex = leftW / sum.width * sum.flex;
  const rightFlex = rightW / sum.width * sum.flex;
  return { leftFlex, leftW, rightFlex, rightW };
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e2 = el;
  while (e2 !== rootElement) {
    const parentElement = e2.parentElement;
    if (!parentElement)
      return path;
    const children = Array.from(parentElement.childNodes);
    const index = children.indexOf(e2);
    path.unshift(index);
    if (parentElement === rootElement) {
      return path;
    }
    e2 = parentElement;
  }
  return path;
}
var EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  const map2 = /* @__PURE__ */ new WeakMap();
  for (const element of elements) {
    map2.set(element, _getDOMPath(rootElement, element));
  }
  const _sortByElementPath = (a, b) => {
    const _a2 = map2.get(a) || EMPTY_PATH;
    const _b2 = map2.get(b) || EMPTY_PATH;
    const len = Math.max(_a2.length, _b2.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a2[i] || -1;
      const bIndex = _b2[i] || -1;
      if (aIndex !== bIndex) {
        return aIndex - bIndex;
      }
    }
    return 0;
  };
  elements.sort(_sortByElementPath);
}
function createPaneLayoutController() {
  const observers = [];
  const elements = [];
  const optionsMap = /* @__PURE__ */ new WeakMap();
  const userCollapsedElementSet = /* @__PURE__ */ new Set();
  const cache = {};
  let rootElement = null;
  let rootWidth = 0;
  let expandedElement = null;
  let resizeDataMap = /* @__PURE__ */ new Map();
  let resizing = false;
  function collapse(element) {
    userCollapsedElementSet.add(element);
    if (expandedElement === element) {
      expandedElement = null;
    }
    _notifyObservers();
  }
  function expand(element) {
    userCollapsedElementSet.delete(element);
    expandedElement = element;
    _notifyObservers();
  }
  function mount(element, options) {
    optionsMap.set(element, { ...options, original: options });
    elements.push(element);
    if (rootElement) {
      _sortElements(rootElement, elements);
    }
    expand(element);
    return () => {
      const idx = elements.indexOf(element);
      if (idx > -1) {
        elements.splice(idx, 1);
      }
      optionsMap.delete(element);
      _notifyObservers();
    };
  }
  function resize(type, leftElement, deltaX) {
    var _a2, _b2, _c2, _d2;
    const leftIndex = elements.indexOf(leftElement);
    const leftOptions = optionsMap.get(leftElement);
    if (!leftOptions)
      return;
    const rightElement = elements[leftIndex + 1];
    const rightOptions = optionsMap.get(rightElement);
    if (!rightOptions)
      return;
    if (type === "start") {
      resizing = true;
      cache.left = { element: leftElement, flex: leftOptions.flex || 1, width: leftElement.offsetWidth };
      cache.right = { element: rightElement, flex: rightOptions.flex || 1, width: rightElement.offsetWidth };
      _notifyObservers();
    }
    if (type === "move" && cache.left && cache.right) {
      resizeDataMap = /* @__PURE__ */ new Map();
      const { leftW, rightW, leftFlex, rightFlex } = _calcPaneResize(cache, leftOptions, rightOptions, deltaX);
      resizeDataMap.set(leftElement, { flex: leftFlex, width: leftW });
      resizeDataMap.set(rightElement, { flex: rightFlex, width: rightW });
      _notifyObservers();
    }
    if (type === "end") {
      resizing = false;
      const leftResizeData = resizeDataMap.get(leftElement);
      const rightResizeData = resizeDataMap.get(rightElement);
      optionsMap.set(leftElement, { ...leftOptions, currentMinWidth: 0, currentMaxWidth: (_a2 = leftOptions.maxWidth) != null ? _a2 : Infinity, flex: (_b2 = leftResizeData == null ? void 0 : leftResizeData.flex) != null ? _b2 : leftOptions.flex });
      optionsMap.set(rightElement, { ...rightOptions, currentMinWidth: 0, currentMaxWidth: (_c2 = leftOptions.maxWidth) != null ? _c2 : Infinity, flex: (_d2 = rightResizeData == null ? void 0 : rightResizeData.flex) != null ? _d2 : rightOptions.flex });
      resizeDataMap = /* @__PURE__ */ new Map();
      delete cache.left;
      delete cache.right;
      _notifyObservers();
    }
  }
  function setRootElement(nextRootElement) {
    rootElement = nextRootElement;
  }
  function setRootWidth(nextRootWidth) {
    rootWidth = nextRootWidth;
    _notifyObservers();
  }
  function subscribe(observer) {
    observers.push(observer);
    return () => {
      const idx = observers.push(observer);
      if (idx > -1) {
        observers.splice(idx, 1);
      }
    };
  }
  return { collapse, expand, mount, resize, setRootElement, setRootWidth, subscribe };
  function _notifyObservers() {
    var _a2, _b2, _c2, _d2;
    if (!rootWidth)
      return;
    const _elements = [];
    for (const element of elements) {
      if (element !== expandedElement) {
        _elements.unshift(element);
      }
    }
    if (expandedElement) {
      _elements.unshift(expandedElement);
    }
    const dataMap = /* @__PURE__ */ new WeakMap();
    const len = _elements.length;
    const lastElement = _elements[0];
    const collapsedWidth = (len - 1) * PANE_COLLAPSED_WIDTH;
    let remaingWidth = rootWidth - collapsedWidth;
    for (const element of _elements) {
      const options = optionsMap.get(element);
      if (!options) {
        continue;
      }
      const minWidth = options.currentMinWidth || options.minWidth || PANE_DEFAULT_MIN_WIDTH;
      const isLast = element === lastElement;
      const userCollapsed = userCollapsedElementSet.has(element);
      const sizeCollapsed = minWidth > remaingWidth;
      const collapsed = isLast ? false : userCollapsed || sizeCollapsed;
      const resizeData = resizeDataMap.get(element);
      dataMap.set(element, { element, collapsed, currentMinWidth: (_a2 = resizeData == null ? void 0 : resizeData.width) != null ? _a2 : options.currentMinWidth, currentMaxWidth: (_b2 = resizeData == null ? void 0 : resizeData.width) != null ? _b2 : options.currentMaxWidth, flex: (_d2 = (_c2 = resizeData == null ? void 0 : resizeData.flex) != null ? _c2 : options.flex) != null ? _d2 : 1 });
      if (collapsed) {
        remaingWidth -= PANE_COLLAPSED_WIDTH;
      } else {
        remaingWidth -= minWidth - PANE_COLLAPSED_WIDTH;
      }
    }
    const panes = [];
    for (const element of elements) {
      const data = dataMap.get(element);
      if (data)
        panes.push(data);
    }
    for (const observer of observers) {
      observer({ expandedElement: expandedElement || elements[elements.length - 1] || null, panes, resizing });
    }
  }
}
function PaneLayout(props) {
  const { children, minWidth, onCollapse, onExpand, ...restProps } = props;
  const controller = (0, import_react2.useMemo)(() => createPaneLayoutController(), []);
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const rootRect = useElementRect(rootElement);
  const width = (rootRect == null ? void 0 : rootRect.width) || 0;
  const collapsed = width === void 0 || !minWidth ? void 0 : width < minWidth;
  const [state2, setState] = (0, import_react2.useState)({ expandedElement: null, panes: [], resizing: false });
  (0, import_react2.useEffect)(() => controller.setRootElement(rootElement), [controller, rootElement]);
  (0, import_react2.useEffect)(() => controller.setRootWidth(width), [controller, width]);
  (0, import_react2.useEffect)(() => controller.subscribe(setState), [controller]);
  (0, import_react2.useEffect)(() => {
    if (collapsed === void 0)
      return;
    if (collapsed && onCollapse)
      onCollapse();
    if (!collapsed && onExpand)
      onExpand();
  }, [collapsed, onCollapse, onExpand]);
  const paneLayout = (0, import_react2.useMemo)(() => ({ collapse: controller.collapse, collapsed, expand: controller.expand, expandedElement: state2.expandedElement, mount: controller.mount, panes: state2.panes, resize: controller.resize, resizing: state2.resizing }), [collapsed, controller, state2.expandedElement, state2.panes, state2.resizing]);
  return (0, import_jsx_runtime.jsx)(PaneLayoutContext.Provider, { value: paneLayout, children: (0, import_jsx_runtime.jsx)(Root$a, { "data-ui": "PaneLayout", ...restProps, "data-collapsed": collapsed ? "" : void 0, "data-resizing": state2.resizing ? "" : void 0, "data-mounted": width ? "" : void 0, ref: setRootElement, children }) });
}
function isMenuNodeButton(node) {
  return (node.type === "item" || node.type === "group") && node.renderAsButton;
}
var isNotMenuNodeButton = (0, import_negate.default)(isMenuNodeButton);
function resolveMenuNodes(params) {
  var _a2, _b2;
  const { fieldActions = [], menuItems, menuItemGroups } = params;
  const nodes = [];
  let keyOffset = 0;
  for (let i = 0; i < fieldActions.length; i += 1) {
    const a = fieldActions[i];
    nodes.push(mapFieldActionToPaneMenuNode(a, "".concat(i, "-").concat(a.type)));
  }
  keyOffset += nodes.length;
  const groups = [];
  for (const itemGroup of menuItemGroups) {
    const group = groups.find((g) => g.key === itemGroup.id);
    if (!group) {
      groups.push({ type: "group", key: itemGroup.id, children: [], expanded: true, renderAsButton: false, title: itemGroup.title, i18n: itemGroup.i18n });
    }
  }
  const ungroupedItems = [];
  for (let i = 0; i < menuItems.length; i += 1) {
    const item = menuItems[i];
    let group = item.group && groups.find((g) => g.key === item.group);
    if (item.group && !group) {
      group = { type: "group", key: item.group, expanded: true, icon: item.icon, title: item.group, children: [], renderAsButton: false };
      groups.push(group);
    }
    if (group) {
      group.children.push({ type: "item", key: "".concat(keyOffset + i, "-item"), hotkey: item.shortcut, icon: item.icon, intent: item.intent, onAction: () => params.actionHandler(item), renderAsButton: (_a2 = item.showAsAction) != null ? _a2 : false, selected: item.selected, title: item.title, i18n: item.i18n, tone: item.tone });
    } else {
      ungroupedItems.push({ type: "item", key: "".concat(keyOffset + i, "-item"), hotkey: item.shortcut, icon: item.icon, intent: item.intent, onAction: () => params.actionHandler(item), renderAsButton: (_b2 = item.showAsAction) != null ? _b2 : false, selected: item.selected, title: item.title, i18n: item.i18n, tone: item.tone });
    }
  }
  return [...ungroupedItems, ...groups, ...nodes];
}
function mapFieldActionToPaneMenuNode(a, key) {
  var _a2, _b2, _c2;
  if (a.type === "divider") {
    return { type: "divider", key };
  }
  if (a.type === "group") {
    return { type: "group", key, children: a.children.map((child, childIdx) => mapFieldActionToPaneMenuNode(child, "".concat(key, "-").concat(childIdx, "-").concat(child.type))), disabled: a.disabled, expanded: (_a2 = a.expanded) != null ? _a2 : true, icon: a.icon, title: a.title, i18n: a.i18n, renderAsButton: (_b2 = a.renderAsButton) != null ? _b2 : false };
  }
  return { type: "item", key, intent: a.intent, disabled: a.disabled, icon: a.icon, iconRight: a.iconRight, onAction: a.onAction, renderAsButton: (_c2 = a.renderAsButton) != null ? _c2 : false, selected: a.selected, title: a.title, i18n: a.i18n, tone: a.tone };
}
var IntentButton = (0, import_react2.forwardRef)(function IntentButton2(props, ref) {
  const { intent, ...restProps } = props;
  const Link2 = (0, import_react2.useMemo)(() => (
    // eslint-disable-next-line @typescript-eslint/no-shadow
    (0, import_react2.forwardRef)(function Link22(linkProps, linkRef) {
      return (0, import_jsx_runtime.jsx)(IntentLink, { ...linkProps, intent: intent.type, params: intent.params, ref: linkRef });
    })
  ), [intent]);
  return props.disabled ? (0, import_jsx_runtime.jsx)(Button2, { ...restProps, as: "a", role: "link", "aria-disabled": "true" }) : (0, import_jsx_runtime.jsx)(Button2, { ...restProps, as: Link2, "data-as": "a", ref });
});
function InsufficientPermissionsMessageTooltip(_ref19) {
  let { reveal, context, loading, children } = _ref19;
  const currentUser = useCurrentUser();
  const { t } = useTranslation2(structureLocaleNamespace);
  if (!reveal) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  }
  return (0, import_jsx_runtime.jsx)(Tooltip, { content: loading ? t("insufficient-permissions-message-tooltip.loading-text") : (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, { context, currentUser }), portal: true, children: (0, import_jsx_runtime.jsx)("div", { children }) });
}
var POPOVER_PROPS$1 = { constrainSize: true, placement: "bottom", portal: true };
var getIntent = (schema2, templates, item) => {
  var _a2;
  const typeName = (_a2 = templates.find((t) => t.id === item.templateId)) == null ? void 0 : _a2.schemaType;
  if (!typeName)
    return null;
  const baseParams = { template: item.templateId, type: typeName, id: item.initialDocumentId };
  return { type: "create", params: item.parameters ? [baseParams, item.parameters] : baseParams };
};
function PaneHeaderCreateButton(_ref20) {
  let { templateItems } = _ref20;
  const schema2 = useSchema();
  const templates = useTemplates();
  const { t } = useTranslation2(structureLocaleNamespace);
  const getI18nText = useGetI18nText([...templateItems, ...templates]);
  const [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({ templateItems });
  const nothingGranted = (0, import_react2.useMemo)(() => {
    return !isTemplatePermissionsLoading && (templatePermissions == null ? void 0 : templatePermissions.every((permission) => !permission.granted));
  }, [isTemplatePermissionsLoading, templatePermissions]);
  const permissionsById = (0, import_react2.useMemo)(() => {
    if (!templatePermissions)
      return {};
    return templatePermissions.reduce((acc, permission) => {
      acc[permission.id] = permission;
      return acc;
    }, {});
  }, [templatePermissions]);
  if (nothingGranted) {
    return (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessageTooltip, { context: "create-document-type", reveal: true, loading: isTemplatePermissionsLoading, children: (0, import_jsx_runtime.jsx)(Button2, { "aria-label": t("pane-header.disabled-created-button.aria-label"), icon: AddIcon, "data-testid": "action-intent-button", disabled: true, mode: "bleed", tooltipProps: null }) });
  }
  if (templateItems.length === 1) {
    const firstItem = templateItems[0];
    const permissions = permissionsById[firstItem.id];
    const disabled = !(permissions == null ? void 0 : permissions.granted);
    const intent = getIntent(schema2, templates, firstItem);
    if (!intent)
      return null;
    return (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessageTooltip, { reveal: disabled, loading: isTemplatePermissionsLoading, context: "create-document-type", children: (0, import_jsx_runtime.jsx)(IntentButton, { "aria-label": getI18nText(firstItem).title, icon: firstItem.icon || AddIcon, intent, mode: "bleed", disabled, "data-testid": "action-intent-button", tooltipProps: disabled ? null : { content: t("pane-header.create-new-button.tooltip") } }) });
  }
  return (0, import_jsx_runtime.jsx)(MenuButton, { button: (0, import_jsx_runtime.jsx)(Button2, { icon: AddIcon, mode: "bleed", "data-testid": "multi-action-intent-button", tooltipProps: { content: t("pane-header.create-new-button.tooltip") } }), id: "create-menu", menu: (0, import_jsx_runtime.jsx)(Menu, { children: templateItems.map((item, itemIndex) => {
    const permissions = permissionsById[item.id];
    const disabled = !(permissions == null ? void 0 : permissions.granted);
    const intent = getIntent(schema2, templates, item);
    const template2 = templates.find((i) => i.id === item.templateId);
    if (!template2 || !intent)
      return null;
    const Link2 = (0, import_react2.forwardRef)((linkProps, linkRef) => disabled ? (0, import_jsx_runtime.jsx)("button", { type: "button", disabled: true, ...linkProps, ref: linkRef }) : (0, import_jsx_runtime.jsx)(IntentLink, { ...linkProps, intent: intent.type, params: intent.params, ref: linkRef }));
    Link2.displayName = "Link";
    const { title } = getI18nText({
      ...item,
      // replace the title with the template title
      title: item.title || getI18nText(template2).title
    });
    return (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessageTooltip, { context: "create-document-type", reveal: disabled, loading: isTemplatePermissionsLoading, children: (0, import_jsx_runtime.jsx)(MenuItem2, { as: Link2, "data-as": disabled ? "button" : "a", text: title, "aria-label": disabled ? t("pane-header.disabled-created-button.aria-label") : title, disabled, "data-testid": "action-intent-button-".concat(itemIndex) }) }, item.id);
  }) }), popover: POPOVER_PROPS$1 });
}
function isNonNullable(value) {
  return value !== null && value !== void 0;
}
var hashObject = (value) => {
  const sortObject = (v) => {
    if (typeof v !== "object" || !v)
      return v;
    if (Array.isArray(v))
      return v.map(sortObject);
    return Object.entries(v).sort((_ref21, _ref22) => {
      let [keyA] = _ref21;
      let [keyB] = _ref22;
      return keyA.localeCompare(keyB, "en");
    });
  };
  const normalize = (v) => JSON.parse(JSON.stringify(v));
  return JSON.stringify(sortObject(normalize(value)));
};
var PaneHeaderActions = (0, import_react2.memo)(function PaneHeaderActions2(props) {
  const { initialValueTemplateItems: initialValueTemplateItemsFromStructure = EMPTY_ARRAY$b, menuItems = EMPTY_ARRAY$b, menuItemGroups = EMPTY_ARRAY$b, actionHandlers = EMPTY_OBJECT } = props;
  const templates = useTemplates();
  const handleAction = (0, import_react2.useCallback)((item) => {
    if (typeof item.action === "string" && !(item.action in actionHandlers)) {
      console.warn("No handler for action:", item.action);
      return false;
    }
    const handler = (
      // eslint-disable-next-line no-nested-ternary
      typeof item.action === "function" ? item.action : typeof item.action === "string" ? actionHandlers[item.action] : null
    );
    if (handler) {
      handler(item.params);
      return true;
    }
    return false;
  }, [actionHandlers]);
  const menuNodes = (0, import_react2.useMemo)(() => resolveMenuNodes({ actionHandler: handleAction, menuItemGroups, menuItems: menuItems.filter((item) => {
    var _a2;
    return ((_a2 = item.intent) == null ? void 0 : _a2.type) !== "create";
  }) }), [handleAction, menuItemGroups, menuItems]);
  const actionNodes = (0, import_react2.useMemo)(() => menuNodes.filter(isMenuNodeButton), [menuNodes]);
  const contextMenuNodes = (0, import_react2.useMemo)(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]);
  const initialValueTemplateItemFromMenuItems = (0, import_react2.useMemo)(() => {
    return menuItems.map((item, menuItemIndex) => {
      var _a2;
      if (((_a2 = item.intent) == null ? void 0 : _a2.type) !== "create")
        return null;
      const { params } = item.intent;
      if (!params)
        return null;
      const intentParams = Array.isArray(params) ? params[0] : params;
      const templateParams = Array.isArray(params) ? params[1] : void 0;
      const templateId = intentParams.template || intentParams.type;
      if (!templateId)
        return null;
      const template2 = templates.find((t) => t.id === templateId);
      if (!template2)
        return null;
      const initialDocumentId = intentParams.id;
      return { item, template: template2, templateParams, menuItemIndex, initialDocumentId };
    }).filter(isNonNullable).map((_ref23) => {
      let { initialDocumentId, item, template: template2, menuItemIndex, templateParams } = _ref23;
      const initialValueTemplateItem = { id: "menuItem".concat(menuItemIndex), initialDocumentId, templateId: template2.id, type: "initialValueTemplateItem", title: item.title || template2.title, i18n: item.i18n || template2.i18n, icon: item.icon, description: template2.description, parameters: templateParams, schemaType: template2.schemaType };
      return initialValueTemplateItem;
    });
  }, [menuItems, templates]);
  const combinedInitialValueTemplates = (0, import_react2.useMemo)(() => {
    return (0, import_uniqBy.default)([...initialValueTemplateItemFromMenuItems, ...initialValueTemplateItemsFromStructure], (item) => hashObject([item.initialDocumentId, item.templateId, item.parameters]));
  }, [initialValueTemplateItemFromMenuItems, initialValueTemplateItemsFromStructure]);
  return (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, children: [combinedInitialValueTemplates.length > 0 && (0, import_jsx_runtime.jsx)(PaneHeaderCreateButton, { templateItems: combinedInitialValueTemplates }), actionNodes.map((node) => (0, import_jsx_runtime.jsx)(PaneHeaderActionButton, { node }, node.key)), contextMenuNodes.length > 0 && (0, import_jsx_runtime.jsx)(PaneContextMenuButton, { nodes: contextMenuNodes })] });
});
function MissingSchemaType(props) {
  const { t } = useTranslation2(structureLocaleNamespace);
  const { layout, value } = props;
  return (0, import_jsx_runtime.jsx)(SanityDefaultPreview, { title: (0, import_jsx_runtime.jsx)("em", { children: (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "pane-item.missing-schema-type.title", components: { Code: "code" }, values: { documentType: value._type } }) }), subtitle: (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "pane-item.missing-schema-type.subtitle", components: { Code: "code" }, values: { documentId: value._id } }), media: () => (0, import_jsx_runtime.jsx)(WarningOutlineIcon, {}), layout });
}
function getIconWithFallback(icon, schemaType, defaultIcon) {
  if (icon === false) {
    return false;
  }
  return icon || schemaType && schemaType.icon || defaultIcon || false;
}
function PaneItem(props) {
  const { icon, id, layout = "default", pressed, schemaType, selected, title, value, margin, marginBottom, marginTop } = props;
  const schema2 = useSchema();
  const documentPreviewStore = useDocumentPreviewStore();
  const { ChildLink: ChildLink3 } = usePaneRouter();
  const documentPresence = useDocumentPresence(id);
  const hasSchemaType = Boolean(schemaType && schemaType.name && schema2.get(schemaType.name));
  const [clicked, setClicked] = (0, import_react2.useState)(false);
  const preview = (0, import_react2.useMemo)(() => {
    if (value && isSanityDocument(value)) {
      if (!schemaType || !hasSchemaType) {
        return (0, import_jsx_runtime.jsx)(MissingSchemaType, { value });
      }
      return (0, import_jsx_runtime.jsx)(PaneItemPreview, { documentPreviewStore, icon: getIconWithFallback(icon, schemaType, DocumentIcon), layout, schemaType, value, presence: documentPresence });
    }
    return (0, import_jsx_runtime.jsx)(SanityDefaultPreview, { status: (0, import_jsx_runtime.jsx)(Box, { style: { opacity: 0.5 }, children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime.jsx)(ChevronRightIcon, {}) }) }), icon: getIconWithFallback(icon, schemaType, FolderIcon), layout: "compact", title });
  }, [documentPreviewStore, hasSchemaType, icon, layout, schemaType, title, value, documentPresence]);
  const Link2 = (0, import_react2.useMemo)(() => function LinkComponent(linkProps) {
    return (0, import_jsx_runtime.jsx)(ChildLink3, { ...linkProps, childId: id });
  }, [ChildLink3, id]);
  const handleClick = (0, import_react2.useCallback)((e2) => {
    if (e2.metaKey) {
      setClicked(false);
      return;
    }
    setClicked(true);
  }, []);
  (0, import_react2.useEffect)(() => setClicked(false), [selected]);
  return (0, import_jsx_runtime.jsx)(PreviewCard, { __unstable_focusRing: true, as: Link2, "data-as": "a", margin, marginBottom, marginTop, onClick: handleClick, pressed, radius: 2, selected: selected || clicked, sizing: "border", tabIndex: -1, tone: "inherit", children: preview });
}
var RenderActionCollectionState = (props) => {
  const { actions, children, actionProps, onActionComplete, group } = props;
  return (0, import_jsx_runtime.jsx)(GetHookCollectionState, { onReset: onActionComplete, hooks: actions, args: actionProps, group, children });
};
var RenderBadgeCollectionState = (props) => {
  const { badges, children, badgeProps, ...rest } = props;
  return (0, import_jsx_runtime.jsx)(GetHookCollectionState, { ...rest, hooks: badges, args: badgeProps, children });
};
function useNotificationTarget(opts) {
  const { documentId, documentType } = opts || {};
  const schemaType = useSchema().get(documentType);
  const { title: workspaceTitle } = useWorkspace();
  const { createPathWithParams, params } = usePaneRouter();
  const documentPreviewStore = useDocumentPreviewStore();
  const previewState = useMemoObservable(() => {
    if (!documentId || !schemaType)
      return of(null);
    return getPreviewStateObservable(documentPreviewStore, schemaType, documentId, "");
  }, [documentId, documentPreviewStore, schemaType]);
  const { published, draft } = previewState || {};
  const documentTitle = (draft == null ? void 0 : draft.title) || (published == null ? void 0 : published.title) || "Sanity document";
  const handleGetNotificationValue = (0, import_react2.useCallback)((_ref24) => {
    let { commentId } = _ref24;
    const path = createPathWithParams({ ...params, comment: commentId, inspect: COMMENTS_INSPECTOR_NAME });
    const url = "".concat(window.location.origin).concat(path);
    return { documentTitle, url, workspaceTitle };
  }, [createPathWithParams, documentTitle, params, workspaceTitle]);
  return { getNotificationValue: handleGetNotificationValue };
}
async function createOperation(props) {
  const { activeTool, client, comment, currentUser, dataset, documentId, documentRevisionId, documentType, getIntent: getIntent2, getNotificationValue, getThreadLength, onCreate, onCreateError, projectId, createAddonDataset, workspace } = props;
  const commentId = (comment == null ? void 0 : comment.id) || v4_default();
  const authorId = currentUser.id;
  const currentThreadLength = ((getThreadLength == null ? void 0 : getThreadLength(comment.threadId)) || 0) + 1;
  let nextComment;
  if (comment.type === "task") {
    nextComment = { _id: commentId, _type: "comment", authorId, message: comment.message, lastEditedAt: void 0, parentCommentId: comment.parentCommentId, status: comment.status, threadId: comment.threadId, reactions: comment.reactions, context: { payload: { workspace }, notification: comment.context.notification, tool: (activeTool == null ? void 0 : activeTool.name) || "" }, target: { document: { _ref: documentId, _type: "reference", _weak: true }, documentType } };
  }
  if (comment.type === "field") {
    const { documentTitle = "", url = "", workspaceTitle = "" } = getNotificationValue({ commentId }) || {};
    const notification = { currentThreadLength, documentTitle, url, workspaceTitle };
    const intent = getIntent2 == null ? void 0 : getIntent2({ id: documentId, type: documentType, path: comment.fieldPath });
    nextComment = { _id: commentId, _type: "comment", authorId, message: comment.message, lastEditedAt: void 0, parentCommentId: comment.parentCommentId, status: comment.status, threadId: comment.threadId, reactions: comment.reactions, context: { payload: { workspace }, intent, notification, tool: (activeTool == null ? void 0 : activeTool.name) || "" }, contentSnapshot: comment.contentSnapshot, target: { documentRevisionId: documentRevisionId || "", path: { field: comment.fieldPath, selection: comment.selection }, document: { _dataset: dataset, _projectId: projectId, _ref: documentId, _type: "crossDatasetReference", _weak: true }, documentType } };
  }
  if (!nextComment)
    return;
  onCreate == null ? void 0 : onCreate(nextComment);
  if (!client) {
    try {
      const newAddonClient = await createAddonDataset();
      if (!newAddonClient) {
        throw new Error("Failed to create addon dataset client");
      }
      await newAddonClient.create(nextComment);
    } catch (err) {
      onCreateError == null ? void 0 : onCreateError(nextComment._id, err);
      throw err;
    }
    return;
  }
  try {
    await client.create(nextComment);
  } catch (err) {
    onCreateError == null ? void 0 : onCreateError(nextComment._id, err);
    throw err;
  }
}
function createReactionKey(userId, shortName) {
  return "".concat(userId, "-").concat(shortName);
}
async function reactOperation(props) {
  var _a2;
  const { client, currentUser, id, reaction, getComment, onUpdate } = props;
  const reactions = ((_a2 = getComment == null ? void 0 : getComment(id)) == null ? void 0 : _a2.reactions) || [];
  const currentUserReactions = reactions.filter((r) => r.userId === currentUser.id);
  const _key = createReactionKey(currentUser.id, reaction.shortName);
  const currentReaction = currentUserReactions.find((r) => r._key === _key && r._optimisticState !== "removed");
  if (currentReaction) {
    const next = reactions.map((r) => {
      if (r._key === currentReaction._key) {
        return { ...r, _optimisticState: "removed" };
      }
      return r;
    });
    onUpdate == null ? void 0 : onUpdate(id, { reactions: next });
    await client.patch(id).unset(['reactions[_key=="'.concat(_key, '"]')]).commit();
    return;
  }
  if (!currentReaction) {
    const reactionItem = { _key, addedAt: (/* @__PURE__ */ new Date()).toISOString(), shortName: reaction.shortName, userId: currentUser.id };
    const optimisticReactionItem = { ...reactionItem, _optimisticState: "added" };
    const next = reactions.concat(optimisticReactionItem).filter((r) => !(r._key === reactionItem._key && r._optimisticState === "removed"));
    onUpdate == null ? void 0 : onUpdate(id, { reactions: next });
    await client.patch(id).setIfMissing({ reactions: [] }).append("reactions", [reactionItem]).commit();
  }
}
async function removeOperation(props) {
  const { client, id, onRemove } = props;
  onRemove == null ? void 0 : onRemove(id);
  await Promise.all([client.delete({ query: '*[_type == "comment" && parentCommentId == "'.concat(id, '"]') }), client.delete(id)]);
}
var THROTTLE_TIME_MS = 1e3;
var THROTTLE_SETTINGS = { trailing: true, leading: false };
var throttleFunctionsMap = /* @__PURE__ */ new Map();
function getThrottledFunction(id) {
  if (!throttleFunctionsMap.has(id)) {
    const throttledFunction = (0, import_throttle2.default)(postCommentUpdate, THROTTLE_TIME_MS, THROTTLE_SETTINGS);
    throttleFunctionsMap.set(id, throttledFunction);
    return throttledFunction;
  }
  return throttleFunctionsMap.get(id);
}
async function postCommentUpdate(props) {
  const { client, id, comment, transactionId: transactionIdProp, onUpdate } = props;
  const transactionId = transactionIdProp || v4_default();
  const patch = client == null ? void 0 : client.patch(id).set(comment);
  const transaction = client.transaction().transactionId(transactionId).patch(patch);
  onUpdate == null ? void 0 : onUpdate(id, comment);
  if (comment.status) {
    await transaction.commit();
    await client.patch({ query: '*[_type == "comment" && parentCommentId == "'.concat(id, '"]') }).set({ status: comment.status }).commit();
  } else {
    await transaction.commit();
  }
  throttleFunctionsMap.delete(id);
}
async function updateOperation(props) {
  const { id, comment, throttled: throttledProp } = props;
  const hasEditedMessage = "message" in comment;
  const editedComment = { ...comment, lastEditedAt: (/* @__PURE__ */ new Date()).toISOString() };
  const nextComment = hasEditedMessage ? editedComment : comment;
  if (!throttledProp) {
    await postCommentUpdate({ ...props, comment: nextComment });
    return;
  }
  const throttlePostCommentUpdate = getThrottledFunction(id);
  await throttlePostCommentUpdate({ ...props, comment: nextComment });
}
function useCommentOperations(opts) {
  const { client, currentUser, dataset, documentId, documentRevisionId, documentType, getComment, getThreadLength, onCreate, onCreateError, onRemove, onTransactionStart, onUpdate, projectId, createAddonDataset, workspace } = opts;
  const getIntent2 = useCommentsIntent();
  const activeToolName = useRouterState((0, import_react2.useCallback)((routerState) => typeof routerState.tool === "string" ? routerState.tool : void 0, []));
  const tools = useTools();
  const activeTool = (0, import_react2.useMemo)(() => tools.find((tool) => tool.name === activeToolName), [activeToolName, tools]);
  const { getNotificationValue } = useNotificationTarget({ documentId, documentType });
  const handleCreate = (0, import_react2.useCallback)(async (comment) => {
    if (!(currentUser == null ? void 0 : currentUser.id))
      return;
    await createOperation({ activeTool, client, comment, currentUser, dataset, documentId, documentRevisionId, documentType, getIntent: getIntent2, getNotificationValue, getThreadLength, onCreate, onCreateError, projectId, createAddonDataset, workspace });
  }, [activeTool, client, currentUser, dataset, documentId, documentRevisionId, documentType, getIntent2, getNotificationValue, getThreadLength, onCreate, onCreateError, projectId, createAddonDataset, workspace]);
  const handleRemove = (0, import_react2.useCallback)(async (id) => {
    if (!client)
      return;
    await removeOperation({ client, id, onRemove });
  }, [client, onRemove]);
  const handleUpdate = (0, import_react2.useCallback)(async (id, comment, updateOpts) => {
    if (!client)
      return;
    const { throttled } = updateOpts || {};
    const nextTransactionId = v4_default();
    onTransactionStart(id, nextTransactionId);
    await updateOperation({ client, comment, throttled, id, onUpdate, transactionId: nextTransactionId });
  }, [client, onTransactionStart, onUpdate]);
  const handleReact = (0, import_react2.useCallback)(async (id, reaction) => {
    if (!client || !(currentUser == null ? void 0 : currentUser.id))
      return;
    await reactOperation({ client, currentUser, id, reaction, getComment, onUpdate });
  }, [client, currentUser, getComment, onUpdate]);
  return (0, import_react2.useMemo)(() => ({ operation: { create: handleCreate, react: handleReact, remove: handleRemove, update: handleUpdate } }), [handleCreate, handleRemove, handleUpdate, handleReact]);
}
function useComments() {
  const value = (0, import_react2.useContext)(CommentsContext);
  if (!value) {
    throw new Error("useComments must be used within a CommentsProvider");
  }
  return value;
}
function useCommentsAuthoringPath() {
  const value = (0, import_react2.useContext)(CommentsAuthoringPathContext);
  if (!value) {
    throw new Error("useCommentsAuthoringPath: missing context value");
  }
  return value;
}
function useCommentsEnabled() {
  const ctx = (0, import_react2.useContext)(CommentsEnabledContext);
  if (ctx === null) {
    throw new Error("useCommentsEnabled: missing context value");
  }
  return ctx;
}
function useCommentsOnboarding() {
  const ctx = (0, import_react2.useContext)(CommentsOnboardingContext);
  if (!ctx) {
    throw new Error("useCommentsOnboarding: missing context value");
  }
  return ctx;
}
var BASE_SCROLL_OPTIONS = { behavior: "smooth", inline: "center", scrollMode: "if-needed" };
var GROUP_SCROLL_OPTIONS = { ...BASE_SCROLL_OPTIONS, block: "start" };
var INLINE_COMMENT_SCROLL_OPTIONS = { ...BASE_SCROLL_OPTIONS, block: "center" };
var SCROLL_TO_FIELD_OPTIONS = { ...BASE_SCROLL_OPTIONS, block: "center" };
var SCROLL_TO_COMMENT_OPTIONS = { ...BASE_SCROLL_OPTIONS, block: "center" };
var SCROLL_OPTIONS_BY_TYPE = { comment: SCROLL_TO_COMMENT_OPTIONS, field: SCROLL_TO_FIELD_OPTIONS, group: GROUP_SCROLL_OPTIONS, "inline-comment": INLINE_COMMENT_SCROLL_OPTIONS };
function generateValidAttrValue(id) {
  const symbolsToRemove = /[[\]_"_=.]/g;
  const result = id.replace(symbolsToRemove, "");
  return result;
}
function applyCommentIdAttr(id) {
  return { "data-comments-comment-id": generateValidAttrValue(id) };
}
function applyCommentsFieldAttr(id) {
  return { "data-comments-field-id": generateValidAttrValue(id) };
}
function applyCommentsGroupAttr(id) {
  return { "data-comments-group-id": generateValidAttrValue(id) };
}
function applyInlineCommentIdAttr(id) {
  return { "data-comments-inline-comment-id": generateValidAttrValue(id) };
}
function useCommentsScroll(opts) {
  const { boundaryElement } = opts || {};
  const [scrollTarget, setScrollTarget] = (0, import_react2.useState)(null);
  const scrollOpts = (0, import_react2.useMemo)(() => {
    const options = SCROLL_OPTIONS_BY_TYPE[(scrollTarget == null ? void 0 : scrollTarget.type) || "comment"];
    return { ...options, boundary: boundaryElement };
  }, [boundaryElement, scrollTarget == null ? void 0 : scrollTarget.type]);
  const handleScrollToComment = (0, import_react2.useCallback)((commentId) => {
    setScrollTarget({ type: "comment", id: commentId });
  }, []);
  const handleScrollToGroup = (0, import_react2.useCallback)((threadId) => {
    setScrollTarget({ type: "group", id: threadId });
  }, []);
  const handleScrollToField = (0, import_react2.useCallback)((fieldPath) => {
    setScrollTarget({ type: "field", id: fieldPath });
  }, []);
  const handleScrollToInlineComment = (0, import_react2.useCallback)((commentId) => {
    setScrollTarget({ type: "inline-comment", id: commentId });
  }, []);
  (0, import_react2.useEffect)(() => {
    const raf = requestAnimationFrame(() => {
      if (!scrollTarget)
        return;
      const { type, id } = scrollTarget;
      const element = document == null ? void 0 : document.querySelector("[data-comments-".concat(type, '-id="').concat(generateValidAttrValue(id), '"]'));
      if (element) {
        e(element, scrollOpts);
      }
    });
    return () => {
      cancelAnimationFrame(raf);
    };
  }, [scrollOpts, scrollTarget]);
  const value = (0, import_react2.useMemo)(() => ({ scrollToComment: handleScrollToComment, scrollToField: handleScrollToField, scrollToGroup: handleScrollToGroup, scrollToInlineComment: handleScrollToInlineComment }), [handleScrollToComment, handleScrollToField, handleScrollToGroup, handleScrollToInlineComment]);
  return value;
}
function useCommentsSelectedPath() {
  const ctx = (0, import_react2.useContext)(CommentsSelectedPathContext);
  if (!ctx) {
    throw new Error("useCommentsSelectedPath: missing context value");
  }
  return ctx;
}
function useCommentsUpsell() {
  const value = (0, import_react2.useContext)(CommentsUpsellContext);
  if (!value) {
    return { upsellData: null, handleOpenDialog: () => null, upsellDialogOpen: false, telemetryLogs: { dialogSecondaryClicked: () => null, dialogPrimaryClicked: () => null, panelViewed: () => null, panelDismissed: () => null, panelPrimaryClicked: () => null, panelSecondaryClicked: () => null } };
  }
  return value;
}
function useResolveCommentsEnabled(documentId, documentType) {
  const { enabled: featureEnabled, isLoading, error } = useFeatureEnabled("studioComments");
  const { enabled } = useSource().document.unstable_comments;
  const enabledFromConfig = (0, import_react2.useMemo)(() => enabled({ documentType, documentId: getPublishedId(documentId) }), [documentId, documentType, enabled]);
  const value = (0, import_react2.useMemo)(() => {
    if (isLoading || !enabledFromConfig || error) {
      return { enabled: false, mode: null };
    }
    return { enabled: true, mode: featureEnabled ? "default" : "upsell" };
  }, [isLoading, enabledFromConfig, error, featureEnabled]);
  return value;
}
var __freeze$W = Object.freeze;
var __defProp$W = Object.defineProperty;
var __template$W = (cooked, raw) => __freeze$W(__defProp$W(cooked, "raw", { value: __freeze$W(raw || cooked.slice()) }));
var _a$W;
var StyledAvatar = ut(Avatar)(_a$W || (_a$W = __template$W(["\n  svg > ellipse {\n    stroke: transparent;\n  }\n"])));
var SYMBOLS = /[^\p{Alpha}\p{White_Space}]/gu;
var WHITESPACE = new RegExp("\\p{White_Space}+", "u");
function nameToInitials(fullName) {
  const namesArray = fullName.replace(SYMBOLS, "").split(WHITESPACE);
  if (namesArray.length === 1) {
    return "".concat(namesArray[0].charAt(0)).toUpperCase();
  }
  return "".concat(namesArray[0].charAt(0)).concat(namesArray[namesArray.length - 1].charAt(0));
}
function CommentsAvatar(props) {
  const { user: userProp, ...restProps } = props;
  const user = userProp;
  const initials = (0, import_react2.useMemo)(() => nameToInitials((user == null ? void 0 : user.displayName) || ""), [user == null ? void 0 : user.displayName]);
  if (!user)
    return (0, import_jsx_runtime.jsx)(StyledAvatar, { ...restProps });
  return (0, import_jsx_runtime.jsx)(StyledAvatar, { initials, src: user == null ? void 0 : user.imageUrl, title: user == null ? void 0 : user.displayName, ...restProps });
}
var __freeze$V = Object.freeze;
var __defProp$V = Object.defineProperty;
var __template$V = (cooked, raw) => __freeze$V(__defProp$V(cooked, "raw", { value: __freeze$V(raw || cooked.slice()) }));
var _a$V;
var SpacerAvatar = ut.div((props) => {
  var _a2;
  const theme = getTheme_v2(props.theme);
  const { $size = 1 } = props;
  return at(_a$V || (_a$V = __template$V(["\n    min-width: ", "px;\n  "])), (_a2 = theme.avatar.sizes[$size]) == null ? void 0 : _a2.size);
});
var mentionObject = defineField({ name: "mention", type: "object", fields: [{ name: "userId", type: "string" }] });
var blockType = defineField({ type: "block", name: "block", of: [mentionObject], marks: { annotations: [] }, styles: [{ title: "Normal", value: "normal" }], lists: [] });
var portableTextType = defineArrayMember({ type: "array", name: "body", of: [blockType] });
var schema = Schema.compile({ name: "comments", types: [portableTextType] });
var editorSchemaType = schema.get("body");
var Z_OFFSET = 9999999;
function CommentInputDiscardDialog(props) {
  const { t } = useTranslation2(commentsLocaleNamespace);
  const { onClose, onConfirm } = props;
  const handleCancelClick = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    onClose();
  }, [onClose]);
  const handleConfirmClick = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    onConfirm();
  }, [onConfirm]);
  return (0, import_jsx_runtime.jsx)(ThemeColorProvider, { tone: "default", children: (0, import_jsx_runtime.jsx)(DialogProvider, { zOffset: Z_OFFSET, children: (0, import_jsx_runtime.jsx)(Dialog2, { header: t("discard.header"), id: "discard-comment-dialog", onClose, width: 0, onClickOutside: onClose, footer: { cancelButton: { onClick: handleCancelClick }, confirmButton: { onClick: handleConfirmClick, text: t("discard.button-confirm"), tone: "critical" } }, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: t("discard.text") }) }) }) });
}
var __freeze$U = Object.freeze;
var __defProp$U = Object.defineProperty;
var __template$U = (cooked, raw) => __freeze$U(__defProp$U(cooked, "raw", { value: __freeze$U(raw || cooked.slice()) }));
var _a$U;
var InnerFlex = ut(Flex)(_a$U || (_a$U = __template$U([""])));
var SKELETON_INLINE_STYLE$1 = { width: "50%" };
function MentionsMenuItem(props) {
  const { user, onSelect } = props;
  const [loadedUser] = useUser(user.id);
  const { t } = useTranslation2(commentsLocaleNamespace);
  const avatar = (0, import_jsx_runtime.jsx)(CommentsAvatar, { user: loadedUser, status: user.granted ? void 0 : "inactive" });
  const text = loadedUser ? (0, import_jsx_runtime.jsx)(Text, { size: 1, textOverflow: "ellipsis", title: loadedUser.displayName, children: loadedUser.displayName }) : (0, import_jsx_runtime.jsx)(TextSkeleton, { size: 1, style: SKELETON_INLINE_STYLE$1 });
  const handleSelect = (0, import_react2.useCallback)(() => {
    onSelect(user.id);
  }, [onSelect, user.id]);
  return (0, import_jsx_runtime.jsx)(Card, { as: "button", disabled: !user.granted, onClick: handleSelect, padding: 2, radius: 2, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [(0, import_jsx_runtime.jsxs)(InnerFlex, { align: "center", gap: 2, flex: 1, children: [avatar, (0, import_jsx_runtime.jsx)(Box, { children: text })] }), !user.granted && (0, import_jsx_runtime.jsx)(Badge, { fontSize: 1, mode: "outline", children: t("mentions.unauthorized-user") })] }) });
}
var EMPTY_ARRAY$d = [];
var Root$9 = ut(Stack)({
  maxWidth: "220px"
  // todo: improve
});
var ITEM_HEIGHT = 41;
var LIST_PADDING = 4;
var MAX_ITEMS = 7;
var FlexWrap = ut(Flex)({ maxHeight: ITEM_HEIGHT * MAX_ITEMS + LIST_PADDING * 2 + ITEM_HEIGHT / 2 });
var MentionsMenu$1 = React.forwardRef(function MentionsMenu2(props, ref) {
  const { t } = useTranslation2(commentsLocaleNamespace);
  const { loading, onSelect, options = [], inputElement } = props;
  const [searchTerm, setSearchTerm] = (0, import_react2.useState)("");
  const commandListRef = (0, import_react2.useRef)(null);
  (0, import_react2.useImperativeHandle)(ref, () => {
    return { setSearchTerm(term) {
      setSearchTerm(term);
    } };
  }, []);
  const renderItem2 = (0, import_react2.useCallback)((itemProps) => {
    return (0, import_jsx_runtime.jsx)(MentionsMenuItem, { user: itemProps, onSelect });
  }, [onSelect]);
  const getItemDisabled = (0, import_react2.useCallback)((index) => {
    var _a2;
    return !((_a2 = options == null ? void 0 : options[index]) == null ? void 0 : _a2.granted);
  }, [options]);
  const filteredOptions = (0, import_react2.useMemo)(() => {
    var _a2;
    if (!searchTerm)
      return options || EMPTY_ARRAY$d;
    const deburredSearchTerm = (0, import_deburr.default)(searchTerm).toLocaleLowerCase();
    const deburredOptions = options == null ? void 0 : options.map((option) => ({ ...option, displayName: (0, import_deburr.default)(option.displayName || "").toLocaleLowerCase() }));
    const filtered = (_a2 = deburredOptions == null ? void 0 : deburredOptions.filter((option) => {
      var _a22;
      return (_a22 = option == null ? void 0 : option.displayName) == null ? void 0 : _a22.includes(deburredSearchTerm);
    })) == null ? void 0 : _a2.sort((a, b) => {
      var _a22, _b2;
      const matchA = (_a22 = a.displayName) == null ? void 0 : _a22.startsWith(deburredSearchTerm);
      const matchB = (_b2 = b.displayName) == null ? void 0 : _b2.startsWith(deburredSearchTerm);
      if (matchA && !matchB)
        return -1;
      if (!matchA && matchB)
        return 1;
      return 0;
    });
    return filtered || EMPTY_ARRAY$d;
  }, [options, searchTerm]);
  if (loading) {
    return (0, import_jsx_runtime.jsx)(Root$9, { children: (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true }) });
  }
  const _inputElement = inputElement ? inputElement : void 0;
  return (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", height: "fill", "data-testid": "comments-mentions-menu", children: [filteredOptions.length === 0 && (0, import_jsx_runtime.jsx)(Box, { padding: 5, children: (0, import_jsx_runtime.jsx)(Text, { align: "center", size: 1, muted: true, children: t("mentions.no-users-found") }) }), filteredOptions.length > 0 && (0, import_jsx_runtime.jsx)(FlexWrap, { direction: "column", flex: 1, overflow: "hidden", children: (0, import_jsx_runtime.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t("mentions.user-list-aria-label"), fixedHeight: true, getItemDisabled, inputElement: _inputElement, itemHeight: 41, items: filteredOptions, padding: 1, ref: commandListRef, renderItem: renderItem2 }) })] });
});
var __freeze$T = Object.freeze;
var __defProp$T = Object.defineProperty;
var __template$T = (cooked, raw) => __freeze$T(__defProp$T(cooked, "raw", { value: __freeze$T(raw || cooked.slice()) }));
var _a$T;
var Span$1 = ut.span((_ref25) => {
  let { theme } = _ref25;
  var _a2, _b2, _c2;
  const { regular } = (_a2 = theme.sanity.fonts) == null ? void 0 : _a2.text.weights;
  const { hovered } = (_b2 = theme.sanity.color) == null ? void 0 : _b2.card;
  const { bg } = ((_c2 = theme.sanity.color.selectable) == null ? void 0 : _c2.caution.pressed) || {};
  return at(_a$T || (_a$T = __template$T(["\n    font-weight: ", ";\n    color: var(--card-link-fg-color);\n    border-radius: 2px;\n    background-color: ", ";\n    padding: 1px;\n    box-sizing: border-box;\n\n    &[data-active='true'] {\n      background-color: ", ";\n    }\n  "])), regular, hovered.bg, bg);
});
function MentionInlineBlock(props) {
  const { selected, userId } = props;
  const [user, loading] = useUser(userId);
  const currentUser = useCurrentUser();
  if (!user || loading)
    return (0, import_jsx_runtime.jsx)(TextSkeleton, { "data-testid": "comment-mentions-loading-skeleton", style: { width: "10ch" }, size: 0, muted: true, radius: 1, animated: true });
  return (0, import_jsx_runtime.jsx)(Tooltip, { portal: true, content: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, children: [(0, import_jsx_runtime.jsx)(Flex, { children: (0, import_jsx_runtime.jsx)(CommentsAvatar, { user }) }), (0, import_jsx_runtime.jsx)(Text, { size: 1, children: user.displayName })] }), children: (0, import_jsx_runtime.jsxs)(Span$1, { "data-selected": selected, "data-active": (currentUser == null ? void 0 : currentUser.id) === userId, children: ["@", user.displayName] }) });
}
var __freeze$S = Object.freeze;
var __defProp$S = Object.defineProperty;
var __template$S = (cooked, raw) => __freeze$S(__defProp$S(cooked, "raw", { value: __freeze$S(raw || cooked.slice()) }));
var _a$S;
var NormalText = ut(Text)(_a$S || (_a$S = __template$S(["\n  word-break: break-word;\n"])));
function NormalBlock(props) {
  const { children } = props;
  return (0, import_jsx_runtime.jsx)(NormalText, { size: 1, children });
}
var renderBlock = (blockProps) => {
  const { children } = blockProps;
  return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
};
var renderChild = (childProps) => {
  const { children, value, selected } = childProps;
  const isMention = value._type === "mention" && value.userId;
  if (isMention) {
    return (0, import_jsx_runtime.jsx)(MentionInlineBlock, { selected, userId: value == null ? void 0 : value.userId });
  }
  return children;
};
var CommentInputContext = import_react2.default.createContext(null);
function CommentInputProvider(props) {
  const { children, expandOnFocus = false, focused, focusOnMount = false, mentionOptions, onMentionMenuOpenChange, value, readOnly } = props;
  const editor = usePortableTextEditor();
  const [mentionsMenuOpen, setMentionsMenuOpen] = (0, import_react2.useState)(false);
  const [mentionsSearchTerm, setMentionsSearchTerm] = (0, import_react2.useState)("");
  const [selectionAtMentionInsert, setSelectionAtMentionInsert] = (0, import_react2.useState)(null);
  const canSubmit = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]);
  const hasChanges = useCommentHasChanged(value);
  const focusEditor = (0, import_react2.useCallback)(() => {
    if (readOnly)
      return;
    PortableTextEditor.focus(editor);
  }, [editor, readOnly]);
  const closeMentions = (0, import_react2.useCallback)(() => {
    setMentionsMenuOpen(false);
    setMentionsSearchTerm("");
    setSelectionAtMentionInsert(null);
  }, []);
  const openMentions = (0, import_react2.useCallback)(() => {
    setMentionsMenuOpen(true);
    setMentionsSearchTerm("");
    setMentionsMenuOpen(true);
    setSelectionAtMentionInsert(PortableTextEditor.getSelection(editor));
  }, [editor]);
  const onBeforeInput = (0, import_react2.useCallback)((event) => {
    const selection = PortableTextEditor.getSelection(editor);
    const cursorOffset = selection ? selection.focus.offset : 0;
    const focusChild = PortableTextEditor.focusChild(editor);
    const focusSpan = isPortableTextSpan(focusChild) && focusChild || void 0;
    const isInsertText = event.inputType === "insertText";
    const isDeleteText = event.inputType === "deleteContentBackward";
    const isInsertingAtChar = isInsertText && event.data === "@";
    const lastIndexOfAt = (focusSpan == null ? void 0 : focusSpan.text.substring(0, cursorOffset).lastIndexOf("@")) || 0;
    const isWhitespaceCharBeforeCursorPosition = (focusSpan == null ? void 0 : focusSpan.text.substring(cursorOffset - 1, cursorOffset)) === " ";
    const filterStartsWithSpaceChar = isInsertText && event.data === " " && !mentionsSearchTerm;
    if (isInsertingAtChar && (cursorOffset < 1 || isWhitespaceCharBeforeCursorPosition)) {
      openMentions();
      return;
    }
    if (filterStartsWithSpaceChar || isDeleteText && ((focusSpan == null ? void 0 : focusSpan.text.length) === 1 || lastIndexOfAt === ((focusSpan == null ? void 0 : focusSpan.text.length) || 0) - 1)) {
      closeMentions();
      return;
    }
    if (isPortableTextSpan(focusChild)) {
      let term = focusChild.text.substring(lastIndexOfAt + 1, cursorOffset);
      if (isInsertText) {
        term += event.data;
      }
      if (isDeleteText) {
        term = term.substring(0, term.length - 1);
      }
      setMentionsSearchTerm(term);
    }
  }, [closeMentions, editor, mentionsSearchTerm, openMentions]);
  const insertAtChar = (0, import_react2.useCallback)(() => {
    setMentionsMenuOpen(true);
    PortableTextEditor.focus(editor);
    PortableTextEditor.insertChild(editor, editor.schemaTypes.span, { text: "@" });
    setSelectionAtMentionInsert(PortableTextEditor.getSelection(editor));
  }, [editor]);
  useDidUpdate(mentionsMenuOpen, () => onMentionMenuOpenChange == null ? void 0 : onMentionMenuOpenChange(mentionsMenuOpen));
  const insertMention = (0, import_react2.useCallback)((userId) => {
    var _a2;
    const mentionSchemaType = editor.schemaTypes.inlineObjects.find((t) => t.name === "mention");
    const [span, spanPath] = selectionAtMentionInsert && PortableTextEditor.findByPath(editor, selectionAtMentionInsert.focus.path) || [];
    if (span && isPortableTextSpan(span) && spanPath && mentionSchemaType) {
      PortableTextEditor.focus(editor);
      const offset = (_a2 = PortableTextEditor.getSelection(editor)) == null ? void 0 : _a2.focus.offset;
      if (typeof offset !== "undefined") {
        PortableTextEditor.delete(editor, { anchor: { path: spanPath, offset: span.text.lastIndexOf("@") }, focus: { path: spanPath, offset } }, { mode: "selected" });
        PortableTextEditor.insertChild(editor, mentionSchemaType, { userId });
        PortableTextEditor.insertChild(editor, editor.schemaTypes.span, { text: " " });
      }
    }
  }, [editor, selectionAtMentionInsert]);
  const ctxValue = (0, import_react2.useMemo)(() => ({ canSubmit, closeMentions, editor, expandOnFocus, focused, focusEditor, focusOnMount, hasChanges, insertAtChar, insertMention, mentionOptions, mentionsMenuOpen, mentionsSearchTerm, onBeforeInput, openMentions, readOnly: Boolean(readOnly), value }), [canSubmit, closeMentions, editor, expandOnFocus, focused, focusEditor, focusOnMount, hasChanges, insertAtChar, insertMention, mentionOptions, mentionsMenuOpen, mentionsSearchTerm, onBeforeInput, openMentions, readOnly, value]);
  return (0, import_jsx_runtime.jsx)(CommentInputContext.Provider, { value: ctxValue, children });
}
function useCommentInput() {
  const ctx = (0, import_react2.useContext)(CommentInputContext);
  if (!ctx) {
    throw new Error("useCommentInputContext must be used within a CommentInputProvider");
  }
  return ctx;
}
var EVENT_LISTENER_OPTIONS = { passive: true };
function useCursorElement(opts) {
  const { disabled, rootElement } = opts;
  const [cursorRect, setCursorRect] = (0, import_react2.useState)(null);
  const cursorElement = (0, import_react2.useMemo)(() => {
    if (!cursorRect) {
      return null;
    }
    return { getBoundingClientRect: () => {
      return cursorRect;
    } };
  }, [cursorRect]);
  const handleSelectionChange = (0, import_react2.useCallback)(() => {
    if (disabled) {
      setCursorRect(null);
      return;
    }
    const sel = window.getSelection();
    if (!sel || !sel.isCollapsed || sel.rangeCount === 0)
      return;
    const range = sel.getRangeAt(0);
    const isWithinRoot = rootElement == null ? void 0 : rootElement.contains(range.commonAncestorContainer);
    if (!isWithinRoot) {
      setCursorRect(null);
      return;
    }
    const rect = range == null ? void 0 : range.getBoundingClientRect();
    if (rect) {
      setCursorRect(rect);
    }
  }, [disabled, rootElement]);
  (0, import_react2.useEffect)(() => {
    document.addEventListener("selectionchange", handleSelectionChange, EVENT_LISTENER_OPTIONS);
    return () => {
      document.removeEventListener("selectionchange", handleSelectionChange);
    };
  }, [handleSelectionChange]);
  return cursorElement;
}
var __freeze$R = Object.freeze;
var __defProp$R = Object.defineProperty;
var __template$R = (cooked, raw) => __freeze$R(__defProp$R(cooked, "raw", { value: __freeze$R(raw || cooked.slice()) }));
var _a$R;
var _b$m;
var POPOVER_FALLBACK_PLACEMENTS$4 = ["bottom", "top"];
var INLINE_STYLE = { outline: "none" };
var EMPTY_ARRAY$c = [];
var PlaceholderWrapper = ut.span((props) => {
  const { color } = getTheme_v2(props.theme);
  return at(_a$R || (_a$R = __template$R(["\n    color: ", ";\n    overflow: hidden;\n    text-overflow: ellipsis;\n    text-wrap: nowrap;\n    display: block;\n  "])), color.input.default.enabled.placeholder);
});
var StyledPopover$1 = ut(Popover2)((_ref26) => {
  let { theme } = _ref26;
  const { space, radius } = theme.sanity;
  return at(_b$m || (_b$m = __template$R(["\n    &[data-placement='bottom'] {\n      transform: translateY(", "px);\n    }\n\n    &[data-placement='top'] {\n      transform: translateY(-", "px);\n    }\n\n    [data-ui='Popover__wrapper'] {\n      border-radius: ", "px;\n      display: flex;\n      flex-direction: column;\n      overflow: clip;\n      overflow: hidden;\n      position: relative;\n      width: 300px; // todo: improve\n    }\n  "])), space[1], space[1], radius[3]);
});
function Editable(props) {
  const { t } = useTranslation2(commentsLocaleNamespace);
  const { focusLock, placeholder = t("compose.create-comment-placeholder"), onFocus, onBlur, onKeyDown, onSubmit } = props;
  const [popoverElement, setPopoverElement] = (0, import_react2.useState)(null);
  const rootElementRef = (0, import_react2.useRef)(null);
  const editableRef = (0, import_react2.useRef)(null);
  const mentionsMenuRef = (0, import_react2.useRef)(null);
  const selection = usePortableTextEditorSelection();
  const { canSubmit, closeMentions, insertMention, mentionOptions, mentionsMenuOpen, mentionsSearchTerm, onBeforeInput, value } = useCommentInput();
  const cursorElement = useCursorElement({ disabled: !mentionsMenuOpen, rootElement: rootElementRef.current });
  const renderPlaceholder = (0, import_react2.useCallback)(() => (0, import_jsx_runtime.jsx)(PlaceholderWrapper, { children: placeholder }), [placeholder]);
  const handleClickOutside = (0, import_react2.useCallback)(() => {
    if (mentionsMenuOpen) {
      closeMentions();
    }
  }, [closeMentions, mentionsMenuOpen]);
  useClickOutside(handleClickOutside, [popoverElement]);
  const handleKeyDown = (0, import_react2.useCallback)((event) => {
    switch (event.key) {
      case "Enter":
        if (event.shiftKey) {
          break;
        }
        event.preventDefault();
        event.stopPropagation();
        if (mentionsMenuOpen) {
          closeMentions();
          break;
        }
        if (onSubmit && canSubmit) {
          onSubmit();
        }
        break;
      case "Escape":
      case "ArrowLeft":
      case "ArrowRight":
        if (mentionsMenuOpen) {
          event.preventDefault();
          event.stopPropagation();
          closeMentions();
        }
        break;
    }
    if (onKeyDown)
      onKeyDown(event);
  }, [canSubmit, closeMentions, mentionsMenuOpen, onKeyDown, onSubmit]);
  const initialSelectionAtEndOfContent = (0, import_react2.useMemo)(() => {
    if (selection) {
      return void 0;
    }
    const lastBlock = (value || EMPTY_ARRAY$c).slice(-1)[0];
    const lastChild = isPortableTextTextBlock(lastBlock) ? lastBlock.children.slice(-1)[0] : void 0;
    if (!lastChild) {
      return void 0;
    }
    const point = { path: [{ _key: lastBlock._key }, "children", { _key: lastChild._key }], offset: isPortableTextSpan(lastChild) ? lastChild.text.length : 0 };
    return { focus: point, anchor: point };
  }, [value, selection]);
  (0, import_react2.useEffect)(() => {
    var _a2;
    (_a2 = mentionsMenuRef.current) == null ? void 0 : _a2.setSearchTerm(mentionsSearchTerm);
  }, [mentionsSearchTerm]);
  (0, import_react2.useEffect)(() => {
    if (mentionsMenuOpen && selection && !(0, import_isEqual2.default)(selection.anchor, selection.focus)) {
      closeMentions();
    }
  }, [mentionsMenuOpen, closeMentions, selection]);
  const popoverContent = (0, import_jsx_runtime.jsx)(MentionsMenu$1, { inputElement: editableRef.current, loading: mentionOptions.loading, onSelect: insertMention, options: mentionOptions.data || EMPTY_ARRAY$c, ref: mentionsMenuRef });
  return (0, import_jsx_runtime.jsxs)("div", { ref: rootElementRef, children: [(0, import_jsx_runtime.jsx)(StyledPopover$1, { arrow: false, constrainSize: true, content: popoverContent, disabled: !mentionsMenuOpen, fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$4, open: mentionsMenuOpen, placement: "bottom", ref: setPopoverElement, referenceElement: cursorElement }), (0, import_jsx_runtime.jsx)(PortableTextEditable, { "data-testid": "comment-input-editable", "data-ui": "EditableElement", onBeforeInput, onBlur, onFocus, onKeyDown: handleKeyDown, ref: editableRef, renderBlock, renderChild, renderPlaceholder, selection: initialSelectionAtEndOfContent, style: INLINE_STYLE, tabIndex: focusLock ? 0 : void 0 })] });
}
var __freeze$Q = Object.freeze;
var __defProp$Q = Object.defineProperty;
var __template$Q = (cooked, raw) => __freeze$Q(__defProp$Q(cooked, "raw", { value: __freeze$Q(raw || cooked.slice()) }));
var _a$Q;
var _b$l;
var EditableWrap = ut(Box)(_a$Q || (_a$Q = __template$Q(["\n  max-height: 20vh;\n  overflow-y: auto;\n"])));
var ButtonDivider = ut(MenuDivider)({ height: 20, width: 1 });
function focusRingBorderStyle(border) {
  return "inset 0 0 0 ".concat(border.width, "px ").concat(border.color);
}
var RootCard = ut(Card)((_ref27) => {
  let { theme } = _ref27;
  const { color, input, radius } = getTheme_v2(theme);
  const radii = radius[2];
  return at(_b$l || (_b$l = __template$Q(["\n    border-radius: ", "px;\n    box-shadow: var(--input-box-shadow);\n\n    --input-box-shadow: ", ";\n\n    &:not([data-expand-on-focus='false'], :focus-within) {\n      background: transparent;\n      box-shadow: unset;\n    }\n\n    &[data-focused='true']:focus-within {\n      ", " {\n        min-height: 1em;\n      }\n\n      /* box-shadow: inset 0 0 0 1px var(--card-focus-ring-color); */\n      --input-box-shadow: ", ";\n    }\n\n    &:focus-within {\n      ", " {\n        min-height: 1em;\n      }\n    }\n\n    &[data-expand-on-focus='false'] {\n      ", " {\n        min-height: 1em;\n      }\n    }\n\n    &[data-expand-on-focus='true'] {\n      [data-ui='CommentInputActions']:not([hidden]) {\n        display: none;\n      }\n\n      &:focus-within {\n        [data-ui='CommentInputActions'] {\n          display: flex;\n        }\n      }\n    }\n    &:hover {\n      --input-box-shadow: ", ";\n    }\n  "])), radii, focusRingBorderStyle({ color: color.input.default.enabled.border, width: input.border.width }), EditableWrap, focusRingBorderStyle({ color: "var(--card-focus-ring-color)", width: input.border.width }), EditableWrap, EditableWrap, focusRingBorderStyle({ color: color.input.default.hovered.border, width: input.border.width }));
});
var AvatarContainer = ut.div((props) => {
  var _a2;
  const theme = getTheme_v2(props.theme);
  return "\n    min-height: ".concat((_a2 = theme.avatar.sizes[1]) == null ? void 0 : _a2.size, "px;\n    display: flex;\n    align-items: center;\n  ");
});
function CommentInputInner(props) {
  const { avatarSize = 1, currentUser, focusLock, onBlur, onFocus, onKeyDown, onSubmit, placeholder, withAvatar } = props;
  const [user] = useUser(currentUser.id);
  const { canSubmit, expandOnFocus, focused, hasChanges, insertAtChar, openMentions, readOnly } = useCommentInput();
  const { t } = useTranslation2(commentsLocaleNamespace);
  const avatar = withAvatar ? (0, import_jsx_runtime.jsx)(AvatarContainer, { children: (0, import_jsx_runtime.jsx)(CommentsAvatar, { user, size: avatarSize }) }) : null;
  const handleMentionButtonClicked = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    insertAtChar();
    openMentions();
  }, [insertAtChar, openMentions]);
  return (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-start", gap: 2, children: [avatar, (0, import_jsx_runtime.jsx)(RootCard, { id: "comment-input-root", "data-expand-on-focus": expandOnFocus && !canSubmit ? "true" : "false", "data-focused": focused ? "true" : "false", flex: 1, sizing: "border", tone: readOnly ? "transparent" : "default", children: (0, import_jsx_runtime.jsxs)(Stack, { children: [(0, import_jsx_runtime.jsx)(EditableWrap, { paddingX: 1, paddingY: 2, sizing: "border", "data-ui": "editable-wrap", children: (0, import_jsx_runtime.jsx)(Editable, { focusLock, onBlur, onFocus, onKeyDown, onSubmit, placeholder }) }), (0, import_jsx_runtime.jsx)(Flex, { align: "center", "data-ui": "CommentInputActions", gap: 1, justify: "flex-end", padding: 1, children: (0, import_jsx_runtime.jsxs)(TooltipDelayGroupProvider, { children: [(0, import_jsx_runtime.jsx)(Button2, { "aria-label": t("compose.mention-user-aria-label"), "data-testid": "comment-input-mention-button", disabled: readOnly, icon: MentionIcon, mode: "bleed", type: "button", onClick: handleMentionButtonClicked, tooltipProps: { content: t("compose.mention-user-tooltip") } }), onSubmit && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(ButtonDivider, {}), (0, import_jsx_runtime.jsx)(Button2, { "aria-label": t("compose.send-comment-aria-label"), "data-testid": "comment-input-send-button", disabled: !canSubmit || !hasChanges || readOnly, icon: SendIcon, mode: hasChanges && canSubmit ? "default" : "bleed", onClick: onSubmit, tone: hasChanges && canSubmit ? "primary" : "default", tooltipProps: { content: t("compose.send-comment-tooltip") } })] })] }) })] }) })] });
}
var EMPTY_ARRAY$b2 = [];
var SCROLL_INTO_VIEW_OPTIONS = { behavior: "smooth", block: "center", inline: "center" };
var CommentInput = (0, import_react2.forwardRef)(function CommentInput2(props, ref) {
  const { avatarSize, currentUser, expandOnFocus, focusLock = false, focusOnMount, mentionOptions, onBlur, onChange, onDiscardCancel, onDiscardConfirm, onFocus, onKeyDown, onMentionMenuOpenChange, onSubmit, placeholder, readOnly, value = EMPTY_ARRAY$b2, withAvatar = true } = props;
  const [focused, setFocused] = (0, import_react2.useState)(false);
  const editorRef = (0, import_react2.useRef)(null);
  const editorContainerRef = (0, import_react2.useRef)(null);
  const [showDiscardDialog, setShowDiscardDialog] = (0, import_react2.useState)(false);
  const preDivRef = (0, import_react2.useRef)(null);
  const postDivRef = (0, import_react2.useRef)(null);
  const innerRef = (0, import_react2.useRef)(null);
  const [editorInstanceKey, setEditorInstanceKey] = (0, import_react2.useState)(defaultKeyGenerator());
  const requestFocus = (0, import_react2.useCallback)(() => {
    requestAnimationFrame(() => {
      if (!editorRef.current)
        return;
      PortableTextEditor.focus(editorRef.current);
    });
  }, []);
  const resetEditorInstance = (0, import_react2.useCallback)(() => {
    setEditorInstanceKey(defaultKeyGenerator());
  }, []);
  const handleChange = (0, import_react2.useCallback)((change) => {
    if (change.type === "ready") {
      if (focusOnMount) {
        requestFocus();
      }
    }
    if (change.type === "focus") {
      setFocused(true);
    }
    if (change.type === "blur") {
      setFocused(false);
    }
    if (change.type === "patch" && editorRef.current) {
      const editorStateValue = PortableTextEditor.getValue(editorRef.current);
      onChange(editorStateValue || EMPTY_ARRAY$b2);
    }
  }, [focusOnMount, onChange, requestFocus]);
  const scrollToEditor = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = editorContainerRef.current) == null ? void 0 : _a2.scrollIntoView(SCROLL_INTO_VIEW_OPTIONS);
  }, []);
  const handleSubmit = (0, import_react2.useCallback)(() => {
    onSubmit == null ? void 0 : onSubmit();
    resetEditorInstance();
    requestFocus();
    scrollToEditor();
  }, [onSubmit, requestFocus, resetEditorInstance, scrollToEditor]);
  const handleDiscardConfirm = (0, import_react2.useCallback)(() => {
    onDiscardConfirm();
    resetEditorInstance();
  }, [onDiscardConfirm, resetEditorInstance]);
  const discardDialogController = (0, import_react2.useMemo)(() => {
    return { open: () => {
      setShowDiscardDialog(true);
    }, close: () => {
      setShowDiscardDialog(false);
      requestFocus();
    } };
  }, [requestFocus]);
  (0, import_react2.useImperativeHandle)(ref, () => {
    return { focus: requestFocus, blur() {
      if (editorRef.current) {
        PortableTextEditor.blur(editorRef.current);
      }
    }, scrollTo: scrollToEditor, reset: resetEditorInstance, discardDialogController };
  }, [discardDialogController, requestFocus, resetEditorInstance, scrollToEditor]);
  const handleFocus = (0, import_react2.useCallback)((event) => {
    if (!focusLock)
      return;
    const target = event.target;
    const innerEl = innerRef.current;
    if (innerEl && target === preDivRef.current) {
      focusLastDescendant(innerEl);
      return;
    }
    if (innerEl && target === postDivRef.current) {
      focusFirstDescendant(innerEl);
    }
  }, [focusLock]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [showDiscardDialog && onDiscardCancel && (0, import_jsx_runtime.jsx)(CommentInputDiscardDialog, { onClose: onDiscardCancel, onConfirm: handleDiscardConfirm }), (0, import_jsx_runtime.jsx)(Stack, { ref: editorContainerRef, "data-testid": "comment-input", onFocus: handleFocus, children: (0, import_jsx_runtime.jsx)(PortableTextEditor, { onChange: handleChange, readOnly, ref: editorRef, schemaType: editorSchemaType, value: value || EMPTY_ARRAY$b2, children: (0, import_jsx_runtime.jsxs)(CommentInputProvider, { expandOnFocus, focused, focusOnMount, mentionOptions, onMentionMenuOpenChange, readOnly, value, children: [focusLock && (0, import_jsx_runtime.jsx)("div", { ref: preDivRef, tabIndex: 0 }), (0, import_jsx_runtime.jsx)(Stack, { ref: innerRef, children: (0, import_jsx_runtime.jsx)(CommentInputInner, { avatarSize, currentUser, focusLock, onBlur, onFocus, onKeyDown, onSubmit: onSubmit && handleSubmit, placeholder, withAvatar }) }), focusLock && (0, import_jsx_runtime.jsx)("div", { ref: postDivRef, tabIndex: 0 })] }) }, editorInstanceKey) })] });
});
var COMMENTS_HIGHLIGHT_HUE_KEY = "yellow";
var COMMENT_REACTION_OPTIONS = [{ shortName: ":+1:", title: "Thumbs up" }, { shortName: ":-1:", title: "Thumbs down" }, { shortName: ":heart:", title: "Heart" }, { shortName: ":rocket:", title: "Rocket" }, { shortName: ":heavy_plus_sign:", title: "Heavy plus sign" }, { shortName: ":eyes:", title: "Eyes" }];
var COMMENT_REACTION_EMOJIS = { ":-1:": "👎", ":+1:": "👍", ":eyes:": "👀", ":heart:": "❤️", ":heavy_plus_sign:": "➕", ":rocket:": "🚀" };
var __freeze$P = Object.freeze;
var __defProp$P = Object.defineProperty;
var __template$P = (cooked, raw) => __freeze$P(__defProp$P(cooked, "raw", { value: __freeze$P(raw || cooked.slice()) }));
var _a$P;
var HighlightSpan = ut.span((_ref28) => {
  let { theme } = _ref28;
  var _a2;
  const isDark = (_a2 = theme.sanity.v2) == null ? void 0 : _a2.color._dark;
  const addedBg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 800 : 100].hex;
  const addedBorder = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 300].hex;
  const addedHoverBg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 200].hex;
  const addedHoverBorder = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 600 : 400].hex;
  const addedNestedBg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 700 : 200].hex;
  const addedNesterBorder = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 600 : 400].hex;
  const authoringBg = addedBg;
  const authoringBorder = addedBorder;
  return at(_a$P || (_a$P = __template$P(["\n    box-sizing: border-box;\n    transition:\n      background-color 100ms ease,\n      border-color 100ms ease;\n\n    // Make sure that child elements appropriately blend with the\n    // background of the highlight span\n    * {\n      mix-blend-mode: ", ";\n    }\n\n    &[data-inline-comment-state='added'][data-inline-comment-nested='false'] {\n      background-color: ", ";\n      border-bottom: 2px solid ", ";\n    }\n\n    &[data-inline-comment-state='added'][data-inline-comment-nested='true'] {\n      background-color: ", ";\n      border-bottom: 2px solid ", ";\n    }\n\n    &[data-inline-comment-state='added'][data-inline-comment-nested='false'][data-hovered='true'] {\n      background-color: ", ";\n      border-bottom: 2px solid ", ";\n    }\n\n    &[data-inline-comment-state='authoring'] {\n      background-color: ", ";\n      border-bottom: 2px solid ", ";\n    }\n  "])), isDark ? "screen" : "multiply", addedBg, addedBorder, addedNestedBg, addedNesterBorder, addedHoverBg, addedHoverBorder, authoringBg, authoringBorder);
});
var CommentInlineHighlightSpan = (0, import_react2.forwardRef)(function CommentInlineHighlightSpan2(props, ref) {
  const { children, isAdded, isAuthoring, isHovered, isNested, ...rest } = props;
  const state2 = isAdded ? "added" : isAuthoring ? "authoring" : void 0;
  return (0, import_jsx_runtime.jsx)(HighlightSpan, { ...rest, "data-hovered": isHovered ? "true" : "false", "data-inline-comment-nested": isNested ? "true" : "false", "data-inline-comment-state": state2, ref, children });
});
var __freeze$O = Object.freeze;
var __defProp$O = Object.defineProperty;
var __template$O = (cooked, raw) => __freeze$O(__defProp$O(cooked, "raw", { value: __freeze$O(raw || cooked.slice()) }));
var _a$O;
var PortableTextWrap = ut(Stack)(() => {
  return at(_a$O || (_a$O = __template$O(["\n    & > [data-ui='Text']:not(:first-child) {\n      margin-top: 1em; // todo: improve\n    }\n\n    & > [data-ui='Text']:has(> span:empty) {\n      display: none;\n    }\n  "])));
});
var EMPTY_ARRAY$a = [];
var components = { block: {
  normal: (_ref29) => {
    let { children } = _ref29;
    return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
  },
  // Since we do not offer any formatting options, we can just use the normal block for all of these.
  h1: (_ref30) => {
    let { children } = _ref30;
    return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
  },
  h2: (_ref31) => {
    let { children } = _ref31;
    return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
  },
  h3: (_ref32) => {
    let { children } = _ref32;
    return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
  },
  h4: (_ref33) => {
    let { children } = _ref33;
    return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
  },
  h5: (_ref34) => {
    let { children } = _ref34;
    return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
  },
  h6: (_ref35) => {
    let { children } = _ref35;
    return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
  },
  blockquote: (_ref36) => {
    let { children } = _ref36;
    return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
  },
  code: (_ref37) => {
    let { children } = _ref37;
    return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
  }
}, list: { bullet: (_ref38) => {
  let { children } = _ref38;
  return children;
}, number: (_ref39) => {
  let { children } = _ref39;
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
}, checkmarks: (_ref40) => {
  let { children } = _ref40;
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
} }, listItem: { bullet: (_ref41) => {
  let { children } = _ref41;
  return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
}, number: (_ref42) => {
  let { children } = _ref42;
  return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
}, checkmarks: (_ref43) => {
  let { children } = _ref43;
  return (0, import_jsx_runtime.jsx)(NormalBlock, { children });
} }, marks: {
  // Since we do not offer any formatting options, we can just use the normal block for all of these.
  strong: (_ref44) => {
    let { children } = _ref44;
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  },
  em: (_ref45) => {
    let { children } = _ref45;
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  },
  code: (_ref46) => {
    let { children } = _ref46;
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  },
  underline: (_ref47) => {
    let { children } = _ref47;
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  },
  strikeThrough: (_ref48) => {
    let { children } = _ref48;
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  },
  link: (_ref49) => {
    let { children } = _ref49;
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  }
}, types: { mention: (props) => {
  var _a2;
  return (0, import_jsx_runtime.jsx)(MentionInlineBlock, { userId: (_a2 = props == null ? void 0 : props.value) == null ? void 0 : _a2.userId, selected: false });
} } };
function CommentMessageSerializer(props) {
  const { blocks } = props;
  return (0, import_jsx_runtime.jsx)(PortableTextWrap, { children: (0, import_jsx_runtime.jsx)(PortableText, { value: blocks || EMPTY_ARRAY$a, components }) });
}
var FLEX_GAP = 3;
var __freeze$N = Object.freeze;
var __defProp$N = Object.defineProperty;
var __template$N = (cooked, raw) => __freeze$N(__defProp$N(cooked, "raw", { value: __freeze$N(raw || cooked.slice()) }));
var _a$N;
var EmojiText = ut(Text)(_a$N || (_a$N = __template$N(["\n  font-family: 'Twemoji Mozilla', 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',\n    'Noto Color Emoji', 'EmojiOne Color', 'Android Emoji', sans-serif;\n"])));
var GRID_COLUMNS = 6;
function CommentReactionsMenu(props) {
  const { options, onSelect } = props;
  const { t } = useTranslation2(commentsLocaleNamespace);
  const [focusableElements, setFocusableElements] = (0, import_react2.useState)([]);
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const [focusedIndex, setFocusedIndex] = (0, import_react2.useState)(0);
  const handleRootKeyDown = (0, import_react2.useCallback)((event) => {
    const focusableLen = focusableElements.length;
    if (event.key === "ArrowRight") {
      setFocusedIndex((prev) => (prev + 1) % focusableLen);
    }
    if (event.key === "ArrowLeft") {
      setFocusedIndex((prev) => (prev - 1 + focusableLen) % focusableLen);
    }
  }, [focusableElements.length]);
  const handleOptionClick = (0, import_react2.useCallback)((event) => {
    const index = focusableElements.indexOf(event.currentTarget);
    setFocusedIndex(index);
    onSelect(options[index]);
  }, [focusableElements, onSelect, options]);
  (0, import_react2.useEffect)(() => {
    if (rootElement) {
      const buttons = rootElement.querySelectorAll("button");
      setFocusableElements(Array.from(buttons));
    }
  }, [rootElement]);
  (0, import_react2.useEffect)(() => {
    if (focusableElements.length > 0) {
      focusableElements[focusedIndex].focus();
    }
  }, [focusableElements, focusedIndex]);
  return (0, import_jsx_runtime.jsx)(Grid, { columns: GRID_COLUMNS, gap: 1, onKeyDown: handleRootKeyDown, ref: setRootElement, role: "menu", children: options.map((o) => {
    const emoji = COMMENT_REACTION_EMOJIS[o.shortName];
    return (0, import_jsx_runtime.jsx)(Button, { "aria-label": t("reactions.react-with-aria-label", { reactionName: o.title || o.shortName }), mode: "bleed", onClick: handleOptionClick, padding: 2, role: "menuitem", tabIndex: -1, children: (0, import_jsx_runtime.jsx)(EmojiText, { align: "center", size: 2, children: emoji }) }, o.shortName);
  }) });
}
var POPOVER_FALLBACK_PLACEMENTS$3 = ["top", "bottom"];
function CommentReactionsMenuButton(props) {
  const { onMenuClose, onMenuOpen, onSelect, options, readOnly, renderMenuButton: renderMenuButton2, mode } = props;
  const [buttonElement, setButtonElement] = (0, import_react2.useState)(null);
  const [popoverElement, setPopoverElement] = (0, import_react2.useState)(null);
  const [open, setOpen] = (0, import_react2.useState)(false);
  const { t } = useTranslation2(commentsLocaleNamespace);
  const handleClick = (0, import_react2.useCallback)(() => {
    const next = !open;
    setOpen(next);
    if (next) {
      onMenuOpen == null ? void 0 : onMenuOpen();
    } else {
      onMenuClose == null ? void 0 : onMenuClose();
    }
  }, [onMenuClose, onMenuOpen, open]);
  const handleClose = (0, import_react2.useCallback)(() => {
    if (!open)
      return;
    setOpen(false);
    onMenuClose == null ? void 0 : onMenuClose();
    buttonElement == null ? void 0 : buttonElement.focus();
  }, [buttonElement, onMenuClose, open]);
  const handleClickOutside = (0, import_react2.useCallback)(handleClose, [handleClose]);
  const handleKeyDown = (0, import_react2.useCallback)((event) => {
    const { key, shiftKey } = event;
    if (shiftKey && key === "Tab" || key === "Escape" || key === "Tab") {
      handleClose();
    }
  }, [handleClose]);
  useClickOutside(handleClickOutside, [popoverElement, buttonElement]);
  const handleSelect = (0, import_react2.useCallback)((option) => {
    onSelect(option);
    handleClose();
  }, [handleClose, onSelect]);
  const button = (0, import_react2.useMemo)(() => {
    const btn = renderMenuButton2({ open, tooltipContent: mode === "upsell" ? t("list-item.context-menu-add-reaction-upsell") : t("list-item.context-menu-add-reaction"), t });
    return (0, import_react2.cloneElement)(btn, { "aria-expanded": open, "aria-haspopup": "true", disabled: readOnly || mode === "upsell", id: "reactions-menu-button", onClick: handleClick, ref: setButtonElement });
  }, [handleClick, open, readOnly, renderMenuButton2, t, mode]);
  const popoverContent = (0, import_jsx_runtime.jsx)(Card, { "aria-labelledby": "reactions-menu-button", onKeyDown: handleKeyDown, padding: 1, radius: 3, tone: "default", children: (0, import_jsx_runtime.jsx)(CommentReactionsMenu, { onSelect: handleSelect, options }) });
  return (0, import_jsx_runtime.jsx)(Popover2, { constrainSize: true, content: popoverContent, fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$3, open, placement: "bottom", portal: true, ref: setPopoverElement, tone: "default", children: button });
}
var __freeze$M = Object.freeze;
var __defProp$M = Object.defineProperty;
var __template$M = (cooked, raw) => __freeze$M(__defProp$M(cooked, "raw", { value: __freeze$M(raw || cooked.slice()) }));
var _a$M;
var _b$k;
var _c$9;
var _d$3;
var TEXT_SIZE = 1;
var ContentStack$1 = ut(Stack)(_a$M || (_a$M = __template$M(["\n  max-width: 180px;\n"])));
var TextGroup = ut.div(_b$k || (_b$k = __template$M(["\n  display: inline-block;\n"])));
var InlineText = ut(Text).attrs({ size: TEXT_SIZE })(_c$9 || (_c$9 = __template$M(["\n  display: inline-block !important;\n\n  & > span {\n    white-space: break-spaces;\n  }\n"])));
var TextBox = ut(Box)(_d$3 || (_d$3 = __template$M(["\n  line-height: 1;\n  text-align: center;\n"])));
var LEADING_NON_WHITESPACE_RE = /^\S+/;
function UserDisplayName(props) {
  const { currentUserId, isFirst, userId } = props;
  const [user] = useUser(userId);
  const { t } = useTranslation2(commentsLocaleNamespace);
  const isCurrentUser = currentUserId === userId;
  if (isCurrentUser) {
    const context = isFirst ? "leading" : void 0;
    return t("reactions.user-list.you", { context, replace: { name: user == null ? void 0 : user.displayName } });
  }
  return (user == null ? void 0 : user.displayName) || t("reactions.user-list.unknown-user-fallback-name");
}
function CommentReactionsUsersTooltip(props) {
  const { children, ...restProps } = props;
  return (0, import_jsx_runtime.jsx)(Tooltip, { content: (0, import_jsx_runtime.jsx)(CommentReactionsUsersTooltipContent, { ...restProps }), placement: "bottom", portal: true, children: (0, import_jsx_runtime.jsx)("div", { children }) });
}
function FormattedUserList(_ref50) {
  let { currentUserId, userIds } = _ref50;
  const listFormat = useListFormat({ style: "long", type: "conjunction" });
  if (userIds.length === 0)
    return null;
  const parts = listFormat.formatToParts(userIds);
  const elements = [];
  for (let i = 0; i < parts.length; i++) {
    const item = parts[i];
    if (item.type === "literal") {
      elements.push((0, import_jsx_runtime.jsx)(InlineText, { children: item.value }, "literal-".concat(i)));
      continue;
    }
    const nextItem = parts[i + 1];
    const nextLeadsWithNonWhitespace = nextItem && nextItem.type === "literal" && LEADING_NON_WHITESPACE_RE.test(nextItem.value);
    if (nextLeadsWithNonWhitespace) {
      const [nonWhitespace = ""] = nextItem.value.match(LEADING_NON_WHITESPACE_RE) || [];
      elements.push(
        // Key (value) is user ID, thus unique
        (0, import_jsx_runtime.jsxs)(TextGroup, { children: [(0, import_jsx_runtime.jsx)(InlineText, { weight: "medium", children: (0, import_jsx_runtime.jsx)(UserDisplayName, { currentUserId, isFirst: i === 0, userId: item.value }) }), (0, import_jsx_runtime.jsx)(InlineText, { children: nonWhitespace })] }, item.value)
      );
      nextItem.value = nextItem.value.slice(nonWhitespace.length);
      continue;
    }
    elements.push(
      // Key (value) is user ID, thus unique
      (0, import_jsx_runtime.jsx)(InlineText, { weight: "medium", children: (0, import_jsx_runtime.jsx)(UserDisplayName, { currentUserId, isFirst: i === 0, userId: item.value }) }, item.value)
    );
  }
  return elements;
}
function CommentReactionsUsersTooltipContent(props) {
  const { currentUser, reactionName, userIds } = props;
  const { t } = useTranslation2(commentsLocaleNamespace);
  const UserList = (0, import_react2.useCallback)(() => {
    if (!currentUser)
      return null;
    return (0, import_jsx_runtime.jsx)(FormattedUserList, { currentUserId: currentUser.id, userIds });
  }, [currentUser, userIds]);
  return (0, import_jsx_runtime.jsxs)(ContentStack$1, { padding: 1, children: [(0, import_jsx_runtime.jsx)(Flex, { justify: "center", paddingBottom: 2, paddingTop: 1, children: (0, import_jsx_runtime.jsx)(EmojiText, { size: 4, children: COMMENT_REACTION_EMOJIS[reactionName] }) }), (0, import_jsx_runtime.jsx)(TextBox, { children: (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "reactions.users-reacted-with-reaction", values: { reactionName }, components: { UserList, ReactionName: () => (0, import_jsx_runtime.jsx)(InlineText, { muted: true, children: reactionName }), Text: (_ref51) => {
    let { children } = _ref51;
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(InlineText, { muted: true, children }), " ", (0, import_jsx_runtime.jsx)("wbr", {}), " "] });
  } } }) })] });
}
var __freeze$L = Object.freeze;
var __defProp$L = Object.defineProperty;
var __template$L = (cooked, raw) => __freeze$L(__defProp$L(cooked, "raw", { value: __freeze$L(raw || cooked.slice()) }));
var _a$L;
var TransparentCard = ut(Card)(_a$L || (_a$L = __template$L(["\n  background: none;\n"])));
function groupReactionsByName(reactions) {
  const grouped = reactions.reduce((acc, reaction) => {
    const { shortName } = reaction;
    if (!acc[shortName]) {
      acc[shortName] = [];
    }
    acc[shortName].push(reaction);
    return acc;
  }, {});
  const sorted = Object.entries(grouped).sort((_ref52, _ref53) => {
    let [nameA] = _ref52;
    let [nameB] = _ref53;
    const indexA = reactions.findIndex((r) => r.shortName === nameA);
    const indexB = reactions.findIndex((r) => r.shortName === nameB);
    return indexA - indexB;
  });
  return sorted;
}
var renderMenuButton$1 = (_ref54) => {
  let { open, tooltipContent } = _ref54;
  return (0, import_jsx_runtime.jsx)(Button, { fontSize: 1, mode: "ghost", padding: 0, radius: "full", selected: open, children: (0, import_jsx_runtime.jsx)(Flex, { paddingX: 3, paddingY: 2, children: (0, import_jsx_runtime.jsx)(Tooltip, { animate: true, content: tooltipContent, disabled: open, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(ReactionIcon, {}) }) }) }) });
};
var CommentReactionsBar = import_react2.default.memo(function CommentReactionsBar2(props) {
  const { currentUser, onSelect, reactions, readOnly, mode } = props;
  const handleSelect = (0, import_react2.useCallback)((name) => {
    const option = COMMENT_REACTION_OPTIONS.find((o) => o.shortName === name);
    if (option) {
      onSelect(option);
    }
  }, [onSelect]);
  const currentUserReactionNames = (0, import_react2.useMemo)(() => {
    return reactions.filter((r) => r.userId === (currentUser == null ? void 0 : currentUser.id)).map((r) => r.shortName);
  }, [currentUser == null ? void 0 : currentUser.id, reactions]);
  const groupedReactions = (0, import_react2.useMemo)(() => {
    const grouped = groupReactionsByName(reactions);
    return grouped.filter((_ref55) => {
      let [name] = _ref55;
      return COMMENT_REACTION_EMOJIS[name];
    });
  }, [reactions]);
  const sortOrder = (0, import_react2.useRef)(Object.keys(Object.fromEntries(groupedReactions)));
  const sortedReactions = (0, import_react2.useMemo)(() => {
    const sorted = groupedReactions.sort((_ref56, _ref57) => {
      let [nameA] = _ref56;
      let [nameB] = _ref57;
      const indexA = sortOrder.current.indexOf(nameA);
      const indexB = sortOrder.current.indexOf(nameB);
      if (indexA === -1) {
        return 1;
      }
      if (indexB === -1) {
        return -1;
      }
      return indexA - indexB;
    });
    sortOrder.current = sorted.map((_ref58) => {
      let [name] = _ref58;
      return name;
    });
    return sorted;
  }, [groupedReactions]);
  return (0, import_jsx_runtime.jsx)(Flex, { align: "center", gap: 1, wrap: "wrap", children: (0, import_jsx_runtime.jsxs)(TooltipDelayGroupProvider, { children: [sortedReactions.map((_ref59) => {
    let [name, reactionsList] = _ref59;
    const hasReacted = currentUserReactionNames.includes(name);
    const userIds = reactionsList.map((r) => r.userId);
    const emoji = COMMENT_REACTION_EMOJIS[name];
    return (0, import_jsx_runtime.jsx)(CommentReactionsUsersTooltip, { currentUser, reactionName: name, userIds, children: (0, import_jsx_runtime.jsx)(TransparentCard, { tone: "default", children: (0, import_jsx_runtime.jsx)(Button, { disabled: readOnly || mode === "upsell", mode: "ghost", onClick: () => handleSelect(name), padding: 2, radius: "full", selected: hasReacted, tone: hasReacted ? "primary" : "default", children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, children: [(0, import_jsx_runtime.jsx)(EmojiText, { size: 1, children: emoji }), (0, import_jsx_runtime.jsx)(Text, { size: 0, weight: hasReacted ? "semibold" : "medium", children: reactionsList == null ? void 0 : reactionsList.length })] }) }) }) }, name);
  }), (0, import_jsx_runtime.jsx)(TransparentCard, { tone: "default", children: (0, import_jsx_runtime.jsx)(CommentReactionsMenuButton, { mode, onSelect: (o) => handleSelect(o.shortName), options: COMMENT_REACTION_OPTIONS, readOnly, renderMenuButton: renderMenuButton$1 }) })] }) });
});
var __freeze$K = Object.freeze;
var __defProp$K = Object.defineProperty;
var __template$K = (cooked, raw) => __freeze$K(__defProp$K(cooked, "raw", { value: __freeze$K(raw || cooked.slice()) }));
var _a$K;
var renderMenuButton = (_ref60) => {
  let { open, tooltipContent, t } = _ref60;
  return (0, import_jsx_runtime.jsx)(Button2, { "aria-label": t("list-item.context-menu-add-reaction-aria-label"), icon: ReactionIcon, mode: "bleed", selected: open, tooltipProps: { content: tooltipContent } });
};
var POPOVER_PROPS = { placement: "bottom-end" };
var FloatingCard = ut(Card)(_a$K || (_a$K = __template$K(["\n  &:empty {\n    display: none;\n  }\n"])));
function CommentsListItemContextMenu(props) {
  const { canDelete, canEdit, isParent, mode, onCopyLink, onDeleteStart, onEditStart, onMenuClose, onMenuOpen, onReactionSelect, onStatusChange, readOnly, status } = props;
  const showMenuButton = Boolean(onCopyLink || onDeleteStart || onEditStart);
  const { t } = useTranslation2(commentsLocaleNamespace);
  const hasContextMenuOptions = Boolean(canDelete || canEdit || onCopyLink);
  return (0, import_jsx_runtime.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime.jsx)(Flex, { children: (0, import_jsx_runtime.jsxs)(FloatingCard, { display: "flex", shadow: 2, padding: 1, radius: 2, sizing: "border", children: [onReactionSelect && (0, import_jsx_runtime.jsx)(CommentReactionsMenuButton, { mode, onMenuClose, onMenuOpen, onSelect: onReactionSelect, options: COMMENT_REACTION_OPTIONS, readOnly, renderMenuButton }), isParent && (0, import_jsx_runtime.jsx)(Button2, { "aria-label": status === "open" ? t("list-item.resolved-tooltip-aria-label") : t("list-item.re-open-resolved-aria-label"), "data-testid": "comments-list-item-status-button", disabled: readOnly, icon: status === "open" ? CheckmarkCircleIcon : UndoIcon, mode: "bleed", onClick: onStatusChange, tooltipProps: { content: status === "open" ? t("list-item.resolved-tooltip-content") : t("list-item.re-open-resolved") } }), hasContextMenuOptions && (0, import_jsx_runtime.jsx)(MenuButton, { id: "comment-actions-menu", button: (0, import_jsx_runtime.jsx)(ContextMenuButton, { "aria-label": t("list-item.open-menu-aria-label"), disabled: readOnly, hidden: !showMenuButton }), onOpen: onMenuOpen, onClose: onMenuClose, menu: (0, import_jsx_runtime.jsxs)(Menu, { children: [(0, import_jsx_runtime.jsx)(MenuItem2, { hidden: !canEdit, icon: EditIcon, onClick: onEditStart, text: t("list-item.edit-comment"), tooltipProps: mode === "upsell" ? { content: t("list-item.edit-comment-upsell") } : void 0, disabled: mode === "upsell" }), (0, import_jsx_runtime.jsx)(MenuItem2, { hidden: !canDelete, icon: TrashIcon, onClick: onDeleteStart, text: t("list-item.delete-comment"), tone: "critical" }), (0, import_jsx_runtime.jsx)(MenuDivider, { hidden: !canDelete && !canEdit }), (0, import_jsx_runtime.jsx)(MenuItem2, { hidden: !onCopyLink, icon: LinkIcon, onClick: onCopyLink, text: t("list-item.copy-link") })] }), popover: POPOVER_PROPS })] }) }) });
}
var __freeze$J = Object.freeze;
var __defProp$J = Object.defineProperty;
var __template$J = (cooked, raw) => __freeze$J(__defProp$J(cooked, "raw", { value: __freeze$J(raw || cooked.slice()) }));
var _a$J;
var _b$j;
function truncate(str) {
  let length = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 250;
  if (str.length <= length)
    return str;
  return "".concat(str.slice(0, length), "...");
}
var InlineBox = ut(Box).attrs({ marginLeft: 1, marginRight: 2 })(_a$J || (_a$J = __template$J(["\n  &:not([data-hidden]) {\n    display: inline;\n  }\n"])));
var BlockQuoteStack = ut(Stack)((_ref61) => {
  let { theme, $hasReferencedValue } = _ref61;
  var _a2;
  const isDark = (_a2 = theme.sanity.v2) == null ? void 0 : _a2.color._dark;
  const hue = $hasReferencedValue ? COMMENTS_HIGHLIGHT_HUE_KEY : "gray";
  const borderColor = isDark ? hues[hue][700].hex : hues[hue][300].hex;
  return at(_b$j || (_b$j = __template$J(["\n    border-left: 2px solid ", ";\n    word-break: break-word;\n  "])), borderColor);
});
function CommentsListItemReferencedValue(props) {
  const { hasReferencedValue, value } = props;
  const { t } = useTranslation(commentsLocaleNamespace);
  const tooltipText = t("list-item.missing-referenced-value-tooltip-content");
  const resolvedValue = (0, import_react2.useMemo)(() => {
    if (Array.isArray(value) && (value == null ? void 0 : value.filter(isPortableTextTextBlock).length) > 0) {
      const text = value == null ? void 0 : value.map(toPlainText).join(" ");
      const truncated = truncate(text);
      return truncated;
    }
    return null;
  }, [value]);
  if (!resolvedValue)
    return null;
  return (0, import_jsx_runtime.jsx)(BlockQuoteStack, { $hasReferencedValue: Boolean(hasReferencedValue), "data-testid": "comments-list-item-referenced-value", flex: 1, forwardedAs: "blockquote", padding: 1, paddingLeft: 2, sizing: "border", children: (0, import_jsx_runtime.jsx)(Flex, { align: "flex-start", children: (0, import_jsx_runtime.jsxs)(Text, { size: 1, muted: true, children: [!hasReferencedValue && (0, import_jsx_runtime.jsx)(Tooltip, { content: tooltipText, children: (0, import_jsx_runtime.jsx)(InlineBox, { children: (0, import_jsx_runtime.jsx)(LinkRemovedIcon, {}) }) }), resolvedValue] }) }) });
}
var __freeze$I = Object.freeze;
var __defProp$I = Object.defineProperty;
var __template$I = (cooked, raw) => __freeze$I(__defProp$I(cooked, "raw", { value: __freeze$I(raw || cooked.slice()) }));
var _a$I;
var _b$i;
var _c$8;
var _d$2;
var _e$1;
var _f$1;
var _g;
var _h;
var stopPropagation = (e2) => e2.stopPropagation();
var ContextMenuBox = ut(Box)(_a$I || (_a$I = __template$I([""])));
var SKELETON_INLINE_STYLE = { width: "50%" };
var EMPTY_ARRAY$9 = [];
var TimeText = ut(Text)((_ref62) => {
  let { theme } = _ref62;
  const isDark = theme.sanity.color.dark;
  const fg = hues.gray[isDark ? 200 : 800].hex;
  return at(_b$i || (_b$i = __template$I(["\n    min-width: max-content;\n    --card-fg-color: ", ";\n    color: var(--card-fg-color);\n  "])), fg);
});
var HeaderFlex$1 = ut(Flex)((props) => {
  var _a2;
  const theme = getTheme_v2(props.theme);
  return at(_c$8 || (_c$8 = __template$I(["\n    min-height: ", "px;\n  "])), (_a2 = theme.avatar.sizes[props.$size]) == null ? void 0 : _a2.size);
});
var IntentText = ut(Text)((_ref63) => {
  let { theme } = _ref63;
  const isDark = theme.sanity.color.dark;
  const fg = hues.gray[isDark ? 200 : 800].hex;
  return at(_d$2 || (_d$2 = __template$I(["\n    --card-fg-color: ", ";\n    color: var(--card-fg-color);\n  "])), fg);
});
var InnerStack = ut(Stack)(_e$1 || (_e$1 = __template$I(["\n  transition: opacity 200ms ease;\n\n  &[data-muted='true'] {\n    transition: unset;\n    opacity: 0.5;\n  }\n"])));
var ErrorFlex = ut(Flex)((props) => {
  var _a2;
  const theme = getTheme_v2(props.theme);
  return at(_f$1 || (_f$1 = __template$I(["\n    min-height: ", "px;\n  "])), (_a2 = theme.avatar.sizes[props.$size]) == null ? void 0 : _a2.size);
});
var RetryCardButton = ut(Card)(_g || (_g = __template$I(["\n  // Add not on hover\n  &:not(:hover) {\n    background-color: transparent;\n  }\n"])));
var RootStack$1 = ut(Stack)((_ref64) => {
  let { theme } = _ref64;
  const { space } = theme.sanity;
  return at(_h || (_h = __template$I(["\n    position: relative;\n\n    // Only show the floating layer on hover when hover is supported.\n    // Else, the layer is always visible.\n    @media (hover: hover) {\n      ", " {\n        opacity: 0;\n        position: absolute;\n        right: 0;\n        top: 0;\n        transform: translate(", "px, -", "px);\n      }\n\n      ", " {\n        &:focus-within {\n          opacity: 1;\n        }\n      }\n\n      &:hover {\n        ", " {\n          opacity: 1;\n        }\n      }\n    }\n\n    &[data-menu-open='true'] {\n      ", " {\n        opacity: 1;\n      }\n    }\n  "])), ContextMenuBox, space[1], space[1], ContextMenuBox, ContextMenuBox, ContextMenuBox);
});
var RELATIVE_TIME_OPTIONS$1 = { useTemporalPhrase: true };
function CommentsListItemLayout(props) {
  var _a2;
  const { avatarSize = 1, canDelete, canEdit, comment, currentUser, hasError, hasReferencedValue, intent, isParent, isRetrying, mentionOptions, mode, onCopyLink, onCreateRetry, onDelete, onEdit, onInputKeyDown, onReactionSelect, onStatusChange, readOnly, withAvatar = true } = props;
  const { _createdAt, authorId, message, _id, lastEditedAt } = comment;
  const [user] = useUser(authorId);
  const { t } = useTranslation2(commentsLocaleNamespace);
  const [value, setValue] = (0, import_react2.useState)(message);
  const [isEditing, setIsEditing] = (0, import_react2.useState)(false);
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const startMessage = (0, import_react2.useRef)(message);
  const [menuOpen, setMenuOpen] = (0, import_react2.useState)(false);
  const commentInputRef = (0, import_react2.useRef)(null);
  const hasChanges = useCommentHasChanged(value);
  const hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]);
  const reactions = (0, import_react2.useMemo)(() => {
    var _a3;
    return (((_a3 = comment == null ? void 0 : comment.reactions) == null ? void 0 : _a3.filter((r) => (r == null ? void 0 : r._optimisticState) !== "removed")) || EMPTY_ARRAY$9).filter((r) => {
      return "userId" in r && "shortName" in r;
    });
  }, [comment == null ? void 0 : comment.reactions]);
  const hasReactions = Boolean(reactions == null ? void 0 : reactions.length);
  const createdDate = _createdAt ? new Date(_createdAt) : /* @__PURE__ */ new Date();
  const editedDate = lastEditedAt ? new Date(lastEditedAt) : null;
  const createdTimeAgo = useRelativeTime(createdDate, RELATIVE_TIME_OPTIONS$1);
  const dateTimeFormat = useDateTimeFormat({ dateStyle: "full", timeStyle: "medium" });
  const formattedCreatedAt = dateTimeFormat.format(createdDate);
  const formattedLastEditAt = editedDate ? dateTimeFormat.format(editedDate) : null;
  const displayError = hasError || isRetrying;
  (0, import_react2.useEffect)(() => {
    if (isEditing)
      return;
    startMessage.current = message;
    setValue(message);
  }, [isEditing, message]);
  const handleMenuOpen = (0, import_react2.useCallback)(() => setMenuOpen(true), []);
  const handleMenuClose = (0, import_react2.useCallback)(() => setMenuOpen(false), []);
  const handleCopyLink = (0, import_react2.useCallback)(() => onCopyLink == null ? void 0 : onCopyLink(_id), [_id, onCopyLink]);
  const handleCreateRetry = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    onCreateRetry == null ? void 0 : onCreateRetry(_id);
  }, [_id, onCreateRetry]);
  const handleDelete = (0, import_react2.useCallback)(() => onDelete(_id), [_id, onDelete]);
  const cancelEdit = (0, import_react2.useCallback)(() => {
    setIsEditing(false);
    setValue(startMessage.current);
  }, []);
  const startDiscard = (0, import_react2.useCallback)(() => {
    var _a3;
    if (!hasValue || !hasChanges) {
      cancelEdit();
      return;
    }
    (_a3 = commentInputRef.current) == null ? void 0 : _a3.discardDialogController.open();
  }, [cancelEdit, hasChanges, hasValue]);
  const handleInputKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      startDiscard();
    }
    if (onInputKeyDown)
      onInputKeyDown(event);
  }, [onInputKeyDown, startDiscard]);
  const cancelDiscard = (0, import_react2.useCallback)(() => {
    var _a3;
    (_a3 = commentInputRef.current) == null ? void 0 : _a3.discardDialogController.close();
  }, []);
  const confirmDiscard = (0, import_react2.useCallback)(() => {
    var _a3;
    (_a3 = commentInputRef.current) == null ? void 0 : _a3.discardDialogController.close();
    cancelEdit();
  }, [cancelEdit]);
  const handleReactionSelect = (0, import_react2.useCallback)((reaction) => {
    onReactionSelect == null ? void 0 : onReactionSelect(_id, reaction);
  }, [_id, onReactionSelect]);
  const handleEditSubmit = (0, import_react2.useCallback)(() => {
    onEdit(_id, { message: value });
    setIsEditing(false);
  }, [_id, onEdit, value]);
  const handleOpenStatusChange = (0, import_react2.useCallback)(() => {
    onStatusChange == null ? void 0 : onStatusChange(_id, comment.status === "open" ? "resolved" : "open");
  }, [_id, comment.status, onStatusChange]);
  const toggleEdit = (0, import_react2.useCallback)(() => {
    setIsEditing((v) => !v);
  }, []);
  const handleCloseMenu = (0, import_react2.useCallback)(() => setMenuOpen(false), []);
  const handleClickOutside = (0, import_react2.useCallback)(() => {
    if (!hasChanges) {
      cancelEdit();
    }
  }, [cancelEdit, hasChanges]);
  const handleRootKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "Escape" && !hasChanges) {
      cancelEdit();
    }
  }, [cancelEdit, hasChanges]);
  useDidUpdate(isEditing, handleCloseMenu);
  useClickOutside(handleClickOutside, [rootElement]);
  const name = (user == null ? void 0 : user.displayName) ? (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", textOverflow: "ellipsis", title: user.displayName, children: user.displayName }) : (0, import_jsx_runtime.jsx)(TextSkeleton, { size: 1, style: SKELETON_INLINE_STYLE });
  return (0, import_jsx_runtime.jsxs)(RootStack$1, { "data-menu-open": menuOpen ? "true" : "false", "data-testid": "comments-list-item-layout", onKeyDown: handleRootKeyDown, ref: setRootElement, space: 4, children: [(0, import_jsx_runtime.jsxs)(InnerStack, { space: 1, "data-muted": displayError, children: [(0, import_jsx_runtime.jsxs)(HeaderFlex$1, { align: "center", gap: FLEX_GAP, flex: 1, $size: avatarSize, children: [withAvatar && (0, import_jsx_runtime.jsx)(CommentsAvatar, { user, size: avatarSize }), (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", gap: 2, paddingY: intent ? 2 : 0, children: [(0, import_jsx_runtime.jsx)(Flex, { align: "center", paddingBottom: ((_a2 = comment.context) == null ? void 0 : _a2.intent) ? 0 : 1, sizing: "border", flex: 1, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-end", gap: 2, children: [(0, import_jsx_runtime.jsx)(Box, { flex: 1, children: name }), !displayError && (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, children: [(0, import_jsx_runtime.jsx)(TimeText, { muted: true, size: 0, children: (0, import_jsx_runtime.jsx)("time", { dateTime: createdDate.toISOString(), title: formattedCreatedAt, children: createdTimeAgo }) }), formattedLastEditAt && editedDate && (0, import_jsx_runtime.jsx)(TimeText, { muted: true, size: 0, title: formattedLastEditAt, children: (0, import_jsx_runtime.jsxs)("time", { dateTime: editedDate.toISOString(), title: formattedLastEditAt, children: ["(", t("list-item.layout-edited"), ")"] }) })] })] }) }), intent && (0, import_jsx_runtime.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime.jsx)(IntentText, { muted: true, size: 0, textOverflow: "ellipsis", children: (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "list-item.layout-context", values: { title: intent.title, intent: "edit" }, components: { IntentLink: (_ref65) => {
    let { children } = _ref65;
    return intent ? (0, import_jsx_runtime.jsx)(IntentLink, { params: intent.params, intent: intent.name, children }) : void 0;
  } } }) }) })] }), !isEditing && !displayError && (0, import_jsx_runtime.jsx)(ContextMenuBox, { "data-root-menu": isParent ? "true" : "false", onClick: stopPropagation, children: (0, import_jsx_runtime.jsx)(CommentsListItemContextMenu, { canDelete, canEdit, isParent, mode, onCopyLink: handleCopyLink, onDeleteStart: handleDelete, onEditStart: toggleEdit, onMenuClose: handleMenuClose, onMenuOpen: handleMenuOpen, onReactionSelect: handleReactionSelect, onStatusChange: handleOpenStatusChange, readOnly, status: comment.status }) })] }), isTextSelectionComment(comment) && Boolean(comment == null ? void 0 : comment.contentSnapshot) && (0, import_jsx_runtime.jsxs)(Flex, { gap: FLEX_GAP, marginBottom: 3, children: [withAvatar && (0, import_jsx_runtime.jsx)(SpacerAvatar, { $size: avatarSize }), (0, import_jsx_runtime.jsx)(CommentsListItemReferencedValue, { hasReferencedValue, value: comment == null ? void 0 : comment.contentSnapshot })] }), isEditing && (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-start", gap: 2, children: [withAvatar && (0, import_jsx_runtime.jsx)(SpacerAvatar, { $size: avatarSize }), (0, import_jsx_runtime.jsx)(Stack, { flex: 1, children: (0, import_jsx_runtime.jsx)(CommentInput, { currentUser, focusOnMount: true, mentionOptions, onChange: setValue, onDiscardCancel: cancelDiscard, onDiscardConfirm: confirmDiscard, onKeyDown: handleInputKeyDown, onSubmit: handleEditSubmit, readOnly, ref: commentInputRef, value, withAvatar: false }) })] }), !isEditing && (0, import_jsx_runtime.jsxs)(Flex, { gap: FLEX_GAP, children: [withAvatar && (0, import_jsx_runtime.jsx)(SpacerAvatar, { $size: avatarSize }), (0, import_jsx_runtime.jsx)(CommentMessageSerializer, { blocks: message })] }), hasReactions && (0, import_jsx_runtime.jsxs)(Flex, { gap: FLEX_GAP, marginTop: 2, children: [withAvatar && (0, import_jsx_runtime.jsx)(SpacerAvatar, { $size: avatarSize }), (0, import_jsx_runtime.jsx)(Box, { onClick: stopPropagation, children: (0, import_jsx_runtime.jsx)(CommentReactionsBar, { currentUser, mode, onSelect: handleReactionSelect, reactions, readOnly }) })] })] }), displayError && (0, import_jsx_runtime.jsxs)(ErrorFlex, { gap: FLEX_GAP, $size: avatarSize, children: [withAvatar && (0, import_jsx_runtime.jsx)(SpacerAvatar, { $size: avatarSize }), (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, flex: 1, children: [(0, import_jsx_runtime.jsxs)(Text, { muted: true, size: 1, children: [hasError && t("list-item.layout-failed-sent"), isRetrying && t("list-item.layout-posting")] }), (0, import_jsx_runtime.jsx)(Flex, { hidden: isRetrying, children: (0, import_jsx_runtime.jsx)(RetryCardButton, { __unstable_focusRing: true, display: "flex", forwardedAs: "button", onClick: handleCreateRetry, padding: 1, radius: 2, tone: "primary", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, muted: true, children: t("list-item.layout-retry") }) }) })] })] })] });
}
var __freeze$H = Object.freeze;
var __defProp$H = Object.defineProperty;
var __template$H = (cooked, raw) => __freeze$H(__defProp$H(cooked, "raw", { value: __freeze$H(raw || cooked.slice()) }));
var _a$H;
var ThreadCard = ut(Card).attrs({ padding: 3, radius: 3, sizing: "border" })((props) => {
  const { theme } = props;
  const isDark = theme.sanity.color.dark;
  const activeBg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][isDark ? 900 : 50].hex;
  const defaultBg = hues.gray[isDark ? 900 : 50].hex;
  return at(_a$H || (_a$H = __template$H(["\n      background-color: ", ";\n\n      &[data-active='true'] {\n        background-color: ", ";\n      }\n    "])), defaultBg, activeBg);
});
var __freeze$G = Object.freeze;
var __defProp$G = Object.defineProperty;
var __template$G = (cooked, raw) => __freeze$G(__defProp$G(cooked, "raw", { value: __freeze$G(raw || cooked.slice()) }));
var _a$G;
var _b$h;
var _c$7;
var EMPTY_ARRAY$8 = [];
var MAX_COLLAPSED_REPLIES = 5;
var DEFAULT_AVATAR_CONFIG = { avatarSize: 1, parentCommentAvatar: true, replyAvatar: true, threadCommentsAvatar: true };
var StyledThreadCard = ut(ThreadCard)(() => {
  return at(_a$G || (_a$G = __template$G(["\n    position: relative;\n\n    &:has(> [data-ui='GhostButton']:focus:focus-visible) {\n      box-shadow:\n        inset 0 0 0 1px var(--card-border-color),\n        0 0 0 1px var(--card-bg-color),\n        0 0 0 2px var(--card-focus-ring-color);\n    }\n\n    // The hover styles is managed with the [data-hovered] attribute instead of the :hover pseudo class\n    // since we want to show the hover styles when hovering over the menu items in the context menu as well.\n    // The context menu is rendered using a portal, so the :hover pseudo class won't work when hovering over\n    // the menu items.\n    &:not([data-active='true']) {\n      @media (hover: hover) {\n        &[data-hovered='true'] {\n          [data-root-menu='true'] {\n            opacity: 1;\n          }\n        }\n      }\n    }\n  "])));
});
var ExpandButton = ut(Button2)((_ref66) => {
  let { theme } = _ref66;
  const { medium } = theme.sanity.fonts.text.weights;
  return at(_b$h || (_b$h = __template$G(["\n    font-weight: ", ";\n  "])), medium);
});
var GhostButton = ut.button(_c$7 || (_c$7 = __template$G(["\n  opacity: 0;\n  position: absolute;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  left: 0;\n"])));
var CommentsListItem = import_react2.default.memo(function CommentsListItem2(props) {
  var _a2, _b2, _c2, _d2, _e2;
  const { avatarConfig = DEFAULT_AVATAR_CONFIG, canReply, currentUser, hasReferencedValue, innerPadding, isSelected, mentionOptions, mode, onCopyLink, onCreateRetry, onDelete, onEdit, onKeyDown, onPathSelect, onReactionSelect, onReply, onStatusChange, parentComment, readOnly, replies = EMPTY_ARRAY$8 } = props;
  const { t } = useTranslation2(commentsLocaleNamespace);
  const [value, setValue] = (0, import_react2.useState)(EMPTY_ARRAY$8);
  const [collapsed, setCollapsed] = (0, import_react2.useState)(true);
  const didExpand = (0, import_react2.useRef)(false);
  const replyInputRef = (0, import_react2.useRef)(null);
  const { isTopLayer } = useLayer();
  const hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]);
  const [mouseOver, setMouseOver] = (0, import_react2.useState)(false);
  const handleMouseEnter = (0, import_react2.useCallback)(() => setMouseOver(true), []);
  const handleMouseLeave = (0, import_react2.useCallback)(() => setMouseOver(false), []);
  const handleReplySubmit = (0, import_react2.useCallback)(() => {
    var _a3;
    const nextComment = {
      message: value,
      parentCommentId: parentComment._id,
      status: (parentComment == null ? void 0 : parentComment.status) || "open",
      // Since this is a reply to an existing comment, we use the same thread ID as the parent
      threadId: parentComment.threadId,
      // A new comment will not have any reactions
      reactions: EMPTY_ARRAY$8,
      payload: { fieldPath: ((_a3 = parentComment.target.path) == null ? void 0 : _a3.field) || "" }
    };
    onReply == null ? void 0 : onReply(nextComment);
    setValue(EMPTY_ARRAY$8);
  }, [onReply, parentComment._id, parentComment == null ? void 0 : parentComment.status, (_a2 = parentComment.target.path) == null ? void 0 : _a2.field, parentComment.threadId, value]);
  const startDiscard = (0, import_react2.useCallback)(() => {
    var _a3;
    if (!hasValue) {
      setValue(EMPTY_ARRAY$8);
      return;
    }
    (_a3 = replyInputRef.current) == null ? void 0 : _a3.discardDialogController.open();
  }, [hasValue]);
  const handleInputKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      startDiscard();
    }
  }, [startDiscard]);
  const cancelDiscard = (0, import_react2.useCallback)(() => {
    var _a3;
    (_a3 = replyInputRef.current) == null ? void 0 : _a3.discardDialogController.close();
  }, []);
  const confirmDiscard = (0, import_react2.useCallback)(() => {
    var _a3, _b3;
    setValue(EMPTY_ARRAY$8);
    (_a3 = replyInputRef.current) == null ? void 0 : _a3.discardDialogController.close();
    (_b3 = replyInputRef.current) == null ? void 0 : _b3.focus();
  }, []);
  const handleThreadRootClick = (0, import_react2.useCallback)((e2) => {
    var _a3;
    e2.stopPropagation();
    if (!isTopLayer)
      return;
    onPathSelect == null ? void 0 : onPathSelect({ fieldPath: ((_a3 = parentComment.target.path) == null ? void 0 : _a3.field) || "", origin: "inspector", threadId: parentComment.threadId });
  }, [isTopLayer, onPathSelect, (_b2 = parentComment.target.path) == null ? void 0 : _b2.field, parentComment.threadId]);
  const handleExpand = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    setCollapsed(false);
    didExpand.current = true;
  }, []);
  const splicedReplies = (0, import_react2.useMemo)(() => {
    if (collapsed)
      return replies == null ? void 0 : replies.slice(-MAX_COLLAPSED_REPLIES);
    return replies;
  }, [replies, collapsed]);
  const showCollapseButton = (0, import_react2.useMemo)(() => {
    if (!replies)
      return false;
    return replies.length > MAX_COLLAPSED_REPLIES;
  }, [replies]);
  const expandButtonText = (0, import_react2.useMemo)(() => {
    return "".concat((replies == null ? void 0 : replies.length) - MAX_COLLAPSED_REPLIES, " more ").concat((replies == null ? void 0 : replies.length) - MAX_COLLAPSED_REPLIES === 1 ? "comment" : "comments");
  }, [replies == null ? void 0 : replies.length]);
  (0, import_react2.useEffect)(() => {
    if (replies.length > MAX_COLLAPSED_REPLIES && !didExpand.current) {
      setCollapsed(true);
    }
  }, [replies]);
  const renderedReplies = (0, import_react2.useMemo)(() => splicedReplies.map((reply) => {
    var _a3, _b3;
    return (0, import_jsx_runtime.jsx)(Stack, { as: "li", ...applyCommentIdAttr(reply._id), children: (0, import_jsx_runtime.jsx)(CommentsListItemLayout, { avatarSize: avatarConfig.avatarSize, canDelete: reply.authorId === currentUser.id, canEdit: reply.authorId === currentUser.id, comment: reply, currentUser, hasError: ((_a3 = reply._state) == null ? void 0 : _a3.type) === "createError", isRetrying: ((_b3 = reply._state) == null ? void 0 : _b3.type) === "createRetrying", intent: commentIntentIfDiffers(parentComment, reply), mentionOptions, mode, onCopyLink, onCreateRetry, onDelete, onEdit, onInputKeyDown: handleInputKeyDown, onReactionSelect, readOnly, withAvatar: avatarConfig.threadCommentsAvatar }) }, reply._id);
  }), [avatarConfig.threadCommentsAvatar, avatarConfig.avatarSize, currentUser, handleInputKeyDown, mentionOptions, onCopyLink, onCreateRetry, onDelete, onEdit, onReactionSelect, parentComment, readOnly, splicedReplies, mode]);
  return (0, import_jsx_runtime.jsxs)(StyledThreadCard, { "data-active": isSelected ? "true" : "false", "data-hovered": mouseOver ? "true" : "false", "data-testid": "comments-list-item", onClick: handleThreadRootClick, onMouseEnter: handleMouseEnter, onMouseLeave: handleMouseLeave, children: [(0, import_jsx_runtime.jsx)(GhostButton, { "data-ui": "GhostButton", "aria-label": t("list-item.go-to-field-button.aria-label") }), (0, import_jsx_runtime.jsxs)(Stack, { as: "ul", padding: innerPadding, paddingBottom: canReply ? void 0 : 1, space: 4, children: [(0, import_jsx_runtime.jsx)(Stack, { as: "li", ...applyCommentIdAttr(parentComment._id), children: (0, import_jsx_runtime.jsx)(CommentsListItemLayout, { avatarSize: avatarConfig.avatarSize, canDelete: parentComment.authorId === currentUser.id, canEdit: parentComment.authorId === currentUser.id, comment: parentComment, currentUser, hasError: ((_c2 = parentComment._state) == null ? void 0 : _c2.type) === "createError", hasReferencedValue, intent: (_d2 = parentComment.context) == null ? void 0 : _d2.intent, isParent: true, isRetrying: ((_e2 = parentComment._state) == null ? void 0 : _e2.type) === "createRetrying", mentionOptions, mode, onCopyLink, onCreateRetry, onDelete, onEdit, onInputKeyDown: onKeyDown, onReactionSelect, onStatusChange, readOnly, withAvatar: avatarConfig.parentCommentAvatar }) }), showCollapseButton && !didExpand.current && (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, paddingY: 1, sizing: "border", children: [(0, import_jsx_runtime.jsx)(SpacerAvatar, {}), (0, import_jsx_runtime.jsx)(ExpandButton, { iconRight: ChevronDownIcon, mode: "bleed", onClick: handleExpand, text: expandButtonText })] }), renderedReplies, canReply && (0, import_jsx_runtime.jsx)(CommentInput, { avatarSize: avatarConfig.avatarSize, currentUser, expandOnFocus: true, mentionOptions, onChange: setValue, onDiscardCancel: cancelDiscard, onDiscardConfirm: confirmDiscard, onKeyDown: handleInputKeyDown, onSubmit: handleReplySubmit, placeholder: mode === "upsell" ? t("compose.reply-placeholder-upsell") : t("compose.reply-placeholder"), readOnly: readOnly || mode === "upsell", ref: replyInputRef, value, withAvatar: avatarConfig.replyAvatar })] })] });
});
function getEmptyStateMessages(t) {
  return { open: { title: t("list-status.empty-state-open-title"), message: t("list-status.empty-state-open-text") }, resolved: { title: t("list-status.empty-state-resolved-title"), message: t("list-status.empty-state-resolved-text") } };
}
function CommentsListStatus(props) {
  const { status, error, loading, hasNoComments } = props;
  const { t } = useTranslation2(commentsLocaleNamespace);
  const emptyStateMessages = getEmptyStateMessages(t);
  if (error) {
    return (0, import_jsx_runtime.jsx)(Flex, { align: "center", justify: "center", flex: 1, padding: 4, children: (0, import_jsx_runtime.jsx)(Flex, { align: "center", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, muted: true, children: t("list-status.error") }) }) });
  }
  if (loading) {
    return (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true, title: t("list-status.loading") });
  }
  if (hasNoComments) {
    return (0, import_jsx_runtime.jsx)(Flex, { align: "center", justify: "center", flex: 1, sizing: "border", children: (0, import_jsx_runtime.jsx)(Container, { width: 0, padding: 4, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime.jsx)(Text, { align: "center", size: 1, muted: true, weight: "medium", children: emptyStateMessages[status].title }), (0, import_jsx_runtime.jsx)(Text, { align: "center", size: 1, muted: true, children: emptyStateMessages[status].message })] }) }) });
  }
  return null;
}
function CreateNewThreadInput(props) {
  const { currentUser, fieldTitle, mentionOptions, mode, onBlur, onFocus, onKeyDown, onNewThreadCreate, readOnly } = props;
  const { t } = useTranslation2(commentsLocaleNamespace);
  const [value, setValue] = (0, import_react2.useState)(EMPTY_ARRAY$b);
  const commentInputHandle = (0, import_react2.useRef)(null);
  const handleSubmit = (0, import_react2.useCallback)(() => {
    onNewThreadCreate == null ? void 0 : onNewThreadCreate(value);
    setValue(EMPTY_ARRAY$b);
  }, [onNewThreadCreate, value]);
  const hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]);
  const startDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    if (!hasValue) {
      return;
    }
    (_a2 = commentInputHandle.current) == null ? void 0 : _a2.discardDialogController.open();
  }, [hasValue]);
  const handleInputKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      startDiscard();
    }
    if (onKeyDown)
      onKeyDown(event);
  }, [onKeyDown, startDiscard]);
  const confirmDiscard = (0, import_react2.useCallback)(() => {
    var _a2, _b2;
    setValue(EMPTY_ARRAY$b);
    (_a2 = commentInputHandle.current) == null ? void 0 : _a2.discardDialogController.close();
    (_b2 = commentInputHandle.current) == null ? void 0 : _b2.focus();
  }, []);
  const cancelDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = commentInputHandle.current) == null ? void 0 : _a2.discardDialogController.close();
  }, []);
  const placeholder = mode === "upsell" ? t("compose.add-comment-input-placeholder-upsell") : (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "compose.add-comment-input-placeholder", values: { field: fieldTitle } });
  return (0, import_jsx_runtime.jsx)(CommentInput, { currentUser, expandOnFocus: true, mentionOptions, onBlur, onChange: setValue, onDiscardCancel: cancelDiscard, onDiscardConfirm: confirmDiscard, onKeyDown: handleInputKeyDown, onFocus, onSubmit: handleSubmit, placeholder, readOnly: readOnly || mode === "upsell", ref: commentInputHandle, value });
}
var __freeze$F = Object.freeze;
var __defProp$F = Object.defineProperty;
var __template$F = (cooked, raw) => __freeze$F(__defProp$F(cooked, "raw", { value: __freeze$F(raw || cooked.slice()) }));
var _a$F;
var _b$g;
var HeaderFlex = ut(Flex)(_a$F || (_a$F = __template$F(["\n  min-height: 25px;\n"])));
var BreadcrumbsButton = ut(Button)((_ref67) => {
  let { theme } = _ref67;
  const fg = theme.sanity.color.base.fg;
  return at(_b$g || (_b$g = __template$F(["\n    --card-fg-color: ", ";\n\n    // The width is needed to make the text ellipsis work\n    // in the breadcrumbs component\n    max-width: 100%;\n  "])), fg);
});
function CommentThreadLayout(props) {
  const { breadcrumbs, canCreateNewThread, children, currentUser, fieldPath, isSelected, mentionOptions, mode, onNewThreadCreate, onPathSelect, readOnly } = props;
  const { t } = useTranslation2(commentsLocaleNamespace);
  const handleNewThreadCreate = (0, import_react2.useCallback)((payload) => {
    const nextComment = {
      message: payload,
      parentCommentId: void 0,
      status: "open",
      // Since this is a new comment, we generate a new thread ID
      threadId: v4_default(),
      // New comments have no reactions
      reactions: [],
      payload: { fieldPath }
    };
    onNewThreadCreate == null ? void 0 : onNewThreadCreate(nextComment);
  }, [onNewThreadCreate, fieldPath]);
  const handleBreadcrumbsClick = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    onPathSelect == null ? void 0 : onPathSelect({ fieldPath, origin: "inspector", threadId: null });
  }, [fieldPath, onPathSelect]);
  const handleNewThreadClick = (0, import_react2.useCallback)((e2) => {
    e2.stopPropagation();
    if (e2.detail === 0)
      return;
    onPathSelect == null ? void 0 : onPathSelect({ fieldPath, origin: "inspector", threadId: null });
  }, [fieldPath, onPathSelect]);
  const crumbsTitlePath = (0, import_react2.useMemo)(() => (breadcrumbs == null ? void 0 : breadcrumbs.map((p) => p.title)) || [], [breadcrumbs]);
  const lastCrumb = crumbsTitlePath[crumbsTitlePath.length - 1];
  return (0, import_jsx_runtime.jsxs)(Stack, { space: 2, children: [(0, import_jsx_runtime.jsx)(HeaderFlex, { align: "center", gap: 2, paddingRight: 1, sizing: "border", children: (0, import_jsx_runtime.jsx)(Stack, { flex: 1, children: (0, import_jsx_runtime.jsx)(Flex, { align: "center", children: (0, import_jsx_runtime.jsx)(BreadcrumbsButton, { "aria-label": t("list-item.breadcrumb-button-go-to-field-aria-label", { field: lastCrumb }), mode: "bleed", onClick: handleBreadcrumbsClick, padding: 2, space: 2, children: (0, import_jsx_runtime.jsx)(CommentBreadcrumbs, { maxLength: 3, titlePath: crumbsTitlePath }) }) }) }) }), canCreateNewThread && (0, import_jsx_runtime.jsx)(ThreadCard, { onClick: handleNewThreadClick, "data-active": isSelected, children: (0, import_jsx_runtime.jsx)(CreateNewThreadInput, { currentUser, fieldTitle: lastCrumb, mentionOptions, mode, onNewThreadCreate: handleNewThreadCreate, readOnly }) }), (0, import_jsx_runtime.jsx)(Stack, { space: 2, children })] });
}
function groupThreads(comments2) {
  return comments2.reduce((acc, comment) => {
    const field = comment.fieldPath;
    if (!acc[field]) {
      acc[field] = [];
    }
    acc[field].push(comment);
    return acc;
  }, {});
}
var CommentsListInner = (0, import_react2.forwardRef)(function CommentsListInner2(props, ref) {
  const { beforeListNode, comments: comments2, currentUser, error, loading, mentionOptions, mode, onCopyLink, onCreateRetry, onDelete, onEdit, onNewThreadCreate, onPathSelect, onReactionSelect, onReply, onStatusChange, readOnly, selectedPath, status } = props;
  const [boundaryElement, setBoundaryElement] = (0, import_react2.useState)(null);
  const groupedThreads = (0, import_react2.useMemo)(() => Object.entries(groupThreads(comments2)), [comments2]);
  const showComments = !loading && !error && groupedThreads.length > 0;
  return (0, import_jsx_runtime.jsxs)(Flex, { "data-testid": "comments-list", direction: "column", flex: 1, height: "fill", overflow: "hidden", ref: setBoundaryElement, sizing: "border", children: [mode !== "upsell" && (0, import_jsx_runtime.jsx)(CommentsListStatus, { error, hasNoComments: groupedThreads.length === 0, loading, status }), (showComments || beforeListNode) && (0, import_jsx_runtime.jsxs)(Stack, { as: "ul", flex: 1, overflow: "auto", padding: 3, paddingTop: 1, paddingBottom: 6, sizing: "border", space: 1, ref, children: [beforeListNode, (0, import_jsx_runtime.jsx)(BoundaryElementProvider, { element: boundaryElement, children: groupedThreads == null ? void 0 : groupedThreads.map((_ref68) => {
    let [fieldPath, group] = _ref68;
    const breadcrumbs = group[0].breadcrumbs;
    const firstThreadId = group[0].threadId;
    const newThreadSelected = (selectedPath == null ? void 0 : selectedPath.fieldPath) === fieldPath && !selectedPath.threadId;
    return (0, import_jsx_runtime.jsx)(Stack, { as: "li", paddingTop: 3, ...applyCommentsGroupAttr(firstThreadId), children: (0, import_jsx_runtime.jsx)(CommentThreadLayout, { breadcrumbs, canCreateNewThread: status === "open", currentUser, fieldPath, isSelected: newThreadSelected, mentionOptions, mode, onNewThreadCreate, onPathSelect, readOnly, children: group.map((item) => {
      var _a2, _b2, _c2;
      const replies = item.replies.slice().reverse();
      const canReply = status === "open" && ((_a2 = item.parentComment._state) == null ? void 0 : _a2.type) !== "createError" && ((_b2 = item.parentComment._state) == null ? void 0 : _b2.type) !== "createRetrying";
      const threadIsSelected = (selectedPath == null ? void 0 : selectedPath.threadId) === item.parentComment.threadId && (selectedPath == null ? void 0 : selectedPath.fieldPath) === ((_c2 = item.parentComment.target.path) == null ? void 0 : _c2.field);
      return (0, import_jsx_runtime.jsx)(CommentsListItem, { canReply, currentUser, hasReferencedValue: item.hasReferencedValue, isSelected: threadIsSelected, mentionOptions, mode, onCopyLink, onCreateRetry, onDelete, onEdit, onPathSelect, onReactionSelect, onReply, onStatusChange, parentComment: item.parentComment, readOnly, replies }, item.parentComment._id);
    }) }, fieldPath) }, fieldPath);
  }) })] })] });
});
var CommentsList = (0, import_react2.memo)(CommentsListInner);
var __freeze$E = Object.freeze;
var __defProp$E = Object.defineProperty;
var __template$E = (cooked, raw) => __freeze$E(__defProp$E(cooked, "raw", { value: __freeze$E(raw || cooked.slice()) }));
var _a$E;
var _b$f;
var _c$6;
var Root$8 = ut(Box)(_a$E || (_a$E = __template$E(["\n  max-width: 280px;\n"])));
var fadeInKeyFrame = ht(_b$f || (_b$f = __template$E(["\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n"])));
var StyledPopover = ut(Popover2)(_c$6 || (_c$6 = __template$E(["\n  opacity: 0;\n  // Fade in the popover after 500ms\n  animation: ", " 200ms 500ms forwards;\n"])), fadeInKeyFrame);
function CommentsOnboardingPopover(props) {
  const { onDismiss } = props;
  const { t } = useTranslation2(commentsLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(StyledPopover, { content: (0, import_jsx_runtime.jsx)(Root$8, { padding: 4, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime.jsx)(Text, { weight: "medium", size: 1, children: t("onboarding.header") }), (0, import_jsx_runtime.jsx)(Text, { size: 1, children: t("onboarding.body") }), (0, import_jsx_runtime.jsx)(Flex, { justify: "flex-end", marginTop: 2, children: (0, import_jsx_runtime.jsx)(Button2, { text: t("onboarding.dismiss"), tone: "primary", onClick: onDismiss }) })] }) }), open: true, portal: true, ...props });
}
var __freeze$D = Object.freeze;
var __defProp$D = Object.defineProperty;
var __template$D = (cooked, raw) => __freeze$D(__defProp$D(cooked, "raw", { value: __freeze$D(raw || cooked.slice()) }));
var _a$D;
var StyledButton$1 = ut(Button2)((_ref69) => {
  let { theme } = _ref69;
  const { space } = getTheme_v2(theme);
  return "\n      position: absolute;\n      top: ".concat(space[3], "px;\n      right: ").concat(space[3], "px;\n      z-index: 20;\n      background: transparent;\n      border-radius: 9999px;\n      box-shadow: none;\n      color: ").concat(white.hex, ";\n      --card-fg-color: ").concat(white.hex, ";\n      :hover {\n        --card-fg-color: ").concat(white.hex, ";\n      }\n    ");
});
var Image$1 = ut.img(_a$D || (_a$D = __template$D(["\n  object-fit: cover;\n  width: 100%;\n  height: 100%;\n  height: 200px;\n"])));
function CommentsUpsellDialog(props) {
  var _a2, _b2, _c2;
  const { data, onClose, onPrimaryClick, onSecondaryClick } = props;
  return (0, import_jsx_runtime.jsxs)(Dialog2, { id: "comments-upsell", onClose, onClickOutside: onClose, __unstable_hideCloseButton: true, bodyHeight: "fill", padding: false, footer: { cancelButton: ((_a2 = data.secondaryButton) == null ? void 0 : _a2.text) ? { text: data.secondaryButton.text, mode: "bleed", tone: "default", iconRight: LaunchIcon, ...data.secondaryButton.url && { target: "_blank", rel: "noopener noreferrer", as: "a", href: data.secondaryButton.url }, onClick: onSecondaryClick } : void 0, confirmButton: { text: (_b2 = data.ctaButton) == null ? void 0 : _b2.text, mode: "default", tone: "primary", ...data.ctaButton.url && { target: "_blank", rel: "noopener noreferrer", as: "a", href: data.ctaButton.url }, onClick: onPrimaryClick } }, children: [(0, import_jsx_runtime.jsx)(StyledButton$1, { icon: CloseIcon, mode: "bleed", tone: "default", onClick: onClose, tabIndex: -1, tooltipProps: null }), data.image && (0, import_jsx_runtime.jsx)(Image$1, { src: data.image.asset.url, alt: (_c2 = data.image.asset.altText) != null ? _c2 : "" }), (0, import_jsx_runtime.jsx)(Box, { padding: 3, marginTop: 2, children: (0, import_jsx_runtime.jsx)(Stack, { space: 4, paddingBottom: 2, children: (0, import_jsx_runtime.jsx)(UpsellDescriptionSerializer, { blocks: data.descriptionText }) }) })] });
}
var __freeze$C = Object.freeze;
var __defProp$C = Object.defineProperty;
var __template$C = (cooked, raw) => __freeze$C(__defProp$C(cooked, "raw", { value: __freeze$C(raw || cooked.slice()) }));
var _a$C;
var Image = ut.img(_a$C || (_a$C = __template$C(["\n  object-fit: cover;\n  width: 100%;\n  height: 100%;\n  height: 180px;\n"])));
function CommentsUpsellPanel(props) {
  var _a2;
  const { data, onPrimaryClick, onSecondaryClick } = props;
  return (0, import_jsx_runtime.jsx)(Container, { width: 1, children: (0, import_jsx_runtime.jsx)(Box, { marginBottom: 6, children: (0, import_jsx_runtime.jsxs)(Card, { radius: 3, overflow: "hidden", border: true, children: [data.image && (0, import_jsx_runtime.jsx)(Image, { src: data.image.asset.url, alt: (_a2 = data.image.asset.altText) != null ? _a2 : "" }), (0, import_jsx_runtime.jsxs)(Box, { padding: 3, marginTop: 2, children: [(0, import_jsx_runtime.jsx)(Stack, { space: 4, children: (0, import_jsx_runtime.jsx)(UpsellDescriptionSerializer, { blocks: data.descriptionText }) }), (0, import_jsx_runtime.jsxs)(Flex, { gap: 2, justify: "flex-end", marginTop: 5, children: [(0, import_jsx_runtime.jsx)(Button2, { mode: "bleed", text: data.secondaryButton.text, tone: "primary", iconRight: LaunchIcon, ...data.secondaryButton.url && { target: "_blank", rel: "noopener noreferrer", as: "a", href: data.secondaryButton.url }, onClick: onSecondaryClick }), (0, import_jsx_runtime.jsx)(Button2, { text: data.ctaButton.text, tone: "primary", ...data.ctaButton.url && { target: "_blank", rel: "noopener noreferrer", as: "a", href: data.ctaButton.url }, onClick: onPrimaryClick })] })] })] }) }) });
}
function CommentsDocumentLayout(props) {
  const { documentId, documentType } = props;
  return (0, import_jsx_runtime.jsx)(CommentsEnabledProvider, { documentId, documentType, children: (0, import_jsx_runtime.jsx)(CommentsDocumentLayoutInner, { ...props }) });
}
function CommentsDocumentLayoutInner(props) {
  const { documentId, documentType } = props;
  const commentsEnabled = useCommentsEnabled();
  const { openInspector, inspector } = useDocumentPane();
  const handleOpenCommentsInspector = (0, import_react2.useCallback)(() => {
    if ((inspector == null ? void 0 : inspector.name) === COMMENTS_INSPECTOR_NAME)
      return;
    openInspector(COMMENTS_INSPECTOR_NAME);
  }, [inspector == null ? void 0 : inspector.name, openInspector]);
  if (!commentsEnabled.enabled) {
    return props.renderDefault(props);
  }
  return (0, import_jsx_runtime.jsx)(CommentsProvider, { documentId, documentType, isCommentsOpen: (inspector == null ? void 0 : inspector.name) === COMMENTS_INSPECTOR_NAME, onCommentsOpen: handleOpenCommentsInspector, sortOrder: "desc", type: "field", children: (0, import_jsx_runtime.jsx)(CommentsSelectedPathProvider, { children: (0, import_jsx_runtime.jsx)(CommentsAuthoringPathProvider, { children: props.renderDefault(props) }) }) });
}
var __freeze$B = Object.freeze;
var __defProp$B = Object.defineProperty;
var __template$B = (cooked, raw) => __freeze$B(__defProp$B(cooked, "raw", { value: __freeze$B(raw || cooked.slice()) }));
var _a$B;
var ContentStack = ut(Stack)(_a$B || (_a$B = __template$B(["\n  width: 320px;\n"])));
function CommentsFieldButton(props) {
  const { count, currentUser, fieldTitle, isCreatingDataset, mentionOptions, onChange, onClick, onClose, onCommentAdd, onDiscard, onInputKeyDown, open, value } = props;
  const { t } = useTranslation2(commentsLocaleNamespace);
  const [popoverElement, setPopoverElement] = (0, import_react2.useState)(null);
  const [addCommentButtonElement, setAddCommentButtonElement] = (0, import_react2.useState)(null);
  const commentInputHandle = (0, import_react2.useRef)(null);
  const hasComments = Boolean(count > 0);
  const closePopover = (0, import_react2.useCallback)(() => {
    if (!open)
      return;
    onClose();
    addCommentButtonElement == null ? void 0 : addCommentButtonElement.focus();
  }, [addCommentButtonElement, open, onClose]);
  const handleSubmit = (0, import_react2.useCallback)(() => {
    onCommentAdd();
    closePopover();
  }, [closePopover, onCommentAdd]);
  const hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]);
  const startDiscard = (0, import_react2.useCallback)(() => {
    var _a2;
    if (!hasValue) {
      closePopover();
      return;
    }
    (_a2 = commentInputHandle.current) == null ? void 0 : _a2.discardDialogController.open();
  }, [closePopover, hasValue]);
  const handleInputKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.isDefaultPrevented()) {
      return;
    }
    if (onInputKeyDown)
      onInputKeyDown(event);
  }, [onInputKeyDown]);
  const handleDiscardCancel = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = commentInputHandle.current) == null ? void 0 : _a2.discardDialogController.close();
  }, []);
  const handleDiscardConfirm = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = commentInputHandle.current) == null ? void 0 : _a2.discardDialogController.close();
    closePopover();
    onDiscard();
  }, [closePopover, onDiscard]);
  const handlePopoverKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      startDiscard();
    }
  }, [startDiscard]);
  const handleClickOutside = (0, import_react2.useCallback)(() => {
    if (!open)
      return;
    startDiscard();
  }, [open, startDiscard]);
  useClickOutside(handleClickOutside, [popoverElement]);
  if (!hasComments) {
    const placeholder = (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "compose.add-comment-input-placeholder", values: { field: fieldTitle } });
    const content = (0, import_jsx_runtime.jsx)(ContentStack, { padding: 2, space: 4, children: (0, import_jsx_runtime.jsx)(CommentInput, { currentUser, focusLock: true, focusOnMount: true, mentionOptions, onChange, onDiscardCancel: handleDiscardCancel, onDiscardConfirm: handleDiscardConfirm, onKeyDown: handleInputKeyDown, onSubmit: handleSubmit, placeholder, readOnly: isCreatingDataset, ref: commentInputHandle, value }) });
    return (0, import_jsx_runtime.jsx)(Popover2, { constrainSize: true, content, fallbackPlacements: ["bottom-end"], open, placement: "right-start", portal: true, ref: setPopoverElement, onKeyDown: handlePopoverKeyDown, children: (0, import_jsx_runtime.jsx)("div", { children: (0, import_jsx_runtime.jsx)(Button2, { "aria-label": t("field-button.aria-label-add"), disabled: isCreatingDataset, icon: AddCommentIcon, mode: "bleed", onClick, ref: setAddCommentButtonElement, selected: open, tooltipProps: { content: t("field-button.title"), placement: "top" } }) }) });
  }
  return (0, import_jsx_runtime.jsx)(Tooltip, { portal: true, placement: "top", content: t("field-button.content", { count }), children: (0, import_jsx_runtime.jsx)(Button, { "aria-label": t("field-button.aria-label-open"), mode: "bleed", onClick, padding: 2, space: 2, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, children: [(0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(CommentIcon2, {}) }), (0, import_jsx_runtime.jsx)(Text, { size: 0, children: count > 9 ? "9+" : count })] }) }) });
}
var __freeze$A = Object.freeze;
var __defProp$A = Object.defineProperty;
var __template$A = (cooked, raw) => __freeze$A(__defProp$A(cooked, "raw", { value: __freeze$A(raw || cooked.slice()) }));
var _a$A;
var _b$e;
var messageCache = /* @__PURE__ */ new Map();
var EMPTY_ARRAY$7 = [];
var HIGHLIGHT_BLOCK_VARIANTS = { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 } };
function CommentsField(props) {
  const { enabled, mode } = useCommentsEnabled();
  if (!enabled) {
    return props.renderDefault(props);
  }
  return (0, import_jsx_runtime.jsx)(CommentFieldInner, { ...props, mode });
}
var HighlightDiv = ut(motion.div)((_ref70) => {
  let { theme } = _ref70;
  const { radius, space, color } = theme.sanity;
  const bg = hues[COMMENTS_HIGHLIGHT_HUE_KEY][color.dark ? 900 : 50].hex;
  return at(_a$A || (_a$A = __template$A(["\n    mix-blend-mode: ", ";\n    border-radius: ", "px;\n    top: -", "px;\n    left: -", "px;\n    bottom: -", "px;\n    right: -", "px;\n    pointer-events: none;\n    position: absolute;\n    z-index: 1;\n    width: calc(100% + ", "px);\n    height: calc(100% + ", "px);\n    background-color: ", ";\n  "])), color.dark ? "screen" : "multiply", radius[3], space[2], space[2], space[2], space[2], space[2] * 2, space[2] * 2, bg);
});
var FieldStack = ut(Stack)(_b$e || (_b$e = __template$A(["\n  position: relative;\n"])));
function CommentFieldInner(props) {
  const { mode } = props;
  const currentUser = useCurrentUser();
  const { element: boundaryElement } = useBoundaryElement();
  const rootRef = (0, import_react2.useRef)(null);
  const { comments: comments2, isCommentsOpen, isCreatingDataset, mentionOptions, onCommentsOpen, operation, setStatus, status } = useComments();
  const { upsellData, handleOpenDialog } = useCommentsUpsell();
  const { selectedPath, setSelectedPath } = useCommentsSelectedPath();
  const { authoringPath, setAuthoringPath } = useCommentsAuthoringPath();
  const { scrollToGroup } = useCommentsScroll({ boundaryElement });
  const fieldTitle = (0, import_react2.useMemo)(() => getSchemaTypeTitle(props.schemaType), [props.schemaType]);
  const stringPath = (0, import_react2.useMemo)(() => toString(props.path), [props.path]);
  const cachedValue = messageCache.get(stringPath) || null;
  const [value, setValue] = (0, import_react2.useState)(cachedValue);
  const isOpen = (0, import_react2.useMemo)(() => authoringPath === stringPath, [authoringPath, stringPath]);
  const isSelected = (0, import_react2.useMemo)(() => {
    if (!isCommentsOpen)
      return false;
    if ((selectedPath == null ? void 0 : selectedPath.origin) === "form" || (selectedPath == null ? void 0 : selectedPath.origin) === "url")
      return false;
    return (selectedPath == null ? void 0 : selectedPath.fieldPath) === stringPath;
  }, [isCommentsOpen, selectedPath == null ? void 0 : selectedPath.fieldPath, selectedPath == null ? void 0 : selectedPath.origin, stringPath]);
  const isInlineCommentThread = (0, import_react2.useMemo)(() => {
    return comments2.data.open.filter((c) => c.threadId === (selectedPath == null ? void 0 : selectedPath.threadId)).some((x) => isTextSelectionComment(x.parentComment));
  }, [comments2.data.open, selectedPath == null ? void 0 : selectedPath.threadId]);
  const count = (0, import_react2.useMemo)(() => {
    const commentsCount = comments2.data.open.map((c) => c.fieldPath === stringPath ? c.commentsCount : 0).reduce((acc, val) => acc + val, 0);
    return commentsCount || 0;
  }, [comments2.data.open, stringPath]);
  const hasComments = Boolean(count > 0);
  const resetMessageValue = (0, import_react2.useCallback)(() => {
    setValue(null);
    messageCache.delete(stringPath);
  }, [stringPath]);
  const handleClick = (0, import_react2.useCallback)(() => {
    var _a2;
    if (hasComments) {
      if (status === "resolved") {
        setStatus("open");
      }
      setAuthoringPath(null);
      onCommentsOpen == null ? void 0 : onCommentsOpen();
      const scrollToThreadId = (_a2 = comments2.data.open.find((c) => c.fieldPath === toString(props.path))) == null ? void 0 : _a2.threadId;
      if (scrollToThreadId) {
        setSelectedPath({ threadId: scrollToThreadId, origin: "form", fieldPath: toString(props.path) });
        scrollToGroup(scrollToThreadId);
      }
      return;
    }
    if (mode === "upsell") {
      if (upsellData) {
        handleOpenDialog("field_action");
      } else {
        onCommentsOpen == null ? void 0 : onCommentsOpen();
      }
      return;
    }
    setAuthoringPath(isOpen ? null : stringPath);
  }, [comments2.data.open, handleOpenDialog, hasComments, isOpen, mode, onCommentsOpen, props.path, scrollToGroup, setAuthoringPath, setSelectedPath, setStatus, status, stringPath, upsellData]);
  const handleCommentAdd = (0, import_react2.useCallback)(() => {
    if (value) {
      const newThreadId = v4_default();
      const nextComment = {
        type: "field",
        fieldPath: toString(props.path),
        message: value,
        parentCommentId: void 0,
        status: "open",
        threadId: newThreadId,
        // New comments have no reactions
        reactions: EMPTY_ARRAY$7
      };
      operation.create(nextComment);
      onCommentsOpen == null ? void 0 : onCommentsOpen();
      if (status === "resolved") {
        setStatus("open");
      }
      resetMessageValue();
      setSelectedPath({ threadId: newThreadId, origin: "form", fieldPath: toString(props.path) });
      scrollToGroup(newThreadId);
    }
  }, [onCommentsOpen, operation, props.path, resetMessageValue, scrollToGroup, setSelectedPath, setStatus, status, value]);
  const handleClose = (0, import_react2.useCallback)(() => setAuthoringPath(null), [setAuthoringPath]);
  const handleOnChange = (0, import_react2.useCallback)((nextValue) => {
    setValue(nextValue);
    messageCache.set(stringPath, nextValue);
  }, [stringPath]);
  const internalComments = (0, import_react2.useMemo)(() => ({ button: currentUser && (0, import_jsx_runtime.jsx)(CommentsFieldButton, { count: Number(count), currentUser, fieldTitle, isCreatingDataset, mentionOptions, onChange: handleOnChange, onClick: handleClick, onClose: handleClose, onCommentAdd: handleCommentAdd, onDiscard: resetMessageValue, open: isOpen, value }), hasComments, isAddingComment: isOpen }), [currentUser, count, fieldTitle, isCreatingDataset, mentionOptions, handleOnChange, handleClick, handleClose, handleCommentAdd, resetMessageValue, isOpen, value, hasComments]);
  return (0, import_jsx_runtime.jsxs)(FieldStack, { ...applyCommentsFieldAttr(toString(props.path)), ref: rootRef, children: [props.renderDefault({
    ...props,
    // eslint-disable-next-line camelcase
    __internal_comments: internalComments
  }), (0, import_jsx_runtime.jsx)(AnimatePresence, { children: isSelected && !isInlineCommentThread && (0, import_jsx_runtime.jsx)(HighlightDiv, { animate: "animate", exit: "exit", initial: "initial", variants: HIGHLIGHT_BLOCK_VARIANTS }) })] });
}
function createDomRectFromElements(elements) {
  if (!elements || !elements.length)
    return null;
  const rects = elements.map((el) => el.getBoundingClientRect());
  const minX = Math.min(...rects.map((r) => r.x)) || 0;
  const minY = Math.min(...rects.map((r) => r.y)) || 0;
  const maxRight = Math.max(...rects.map((r) => r.right)) || 0;
  const maxBottom = Math.max(...rects.map((r) => r.bottom)) || 0;
  return { x: minX, y: minY, width: maxRight - minX, height: maxBottom - minY, top: minY, right: maxRight, bottom: maxBottom, left: minX };
}
function useRectFromElements(props) {
  const { scrollElement, disabled, selector } = props;
  const [rect, setRect] = (0, import_react2.useState)(null);
  const handleSetRect = (0, import_react2.useCallback)(() => {
    const elements = document == null ? void 0 : document.querySelectorAll(selector);
    if (!elements)
      return;
    const nextRect = createDomRectFromElements(Array.from(elements));
    setRect(nextRect);
  }, [selector]);
  (0, import_react2.useEffect)(() => {
    if (disabled)
      return void 0;
    const timeout = setTimeout(() => {
      handleSetRect();
    }, 1);
    return () => {
      clearTimeout(timeout);
    };
  }, [handleSetRect, disabled]);
  (0, import_react2.useEffect)(() => {
    if (disabled || !scrollElement)
      return void 0;
    scrollElement.addEventListener("wheel", handleSetRect);
    return () => {
      scrollElement.removeEventListener("wheel", handleSetRect);
    };
  }, [handleSetRect, disabled, scrollElement]);
  return rect;
}
function useAuthoringReferenceElement(props) {
  const { scrollElement, disabled, selector } = props;
  const rect = useRectFromElements({ scrollElement, disabled, selector });
  const element = (0, import_react2.useMemo)(() => {
    if (!rect)
      return null;
    return { getBoundingClientRect: () => rect };
  }, [rect]);
  return element;
}
function getSelectionBoundingRect() {
  const selection = window.getSelection();
  const range = selection == null ? void 0 : selection.getRangeAt(0);
  const rect = range == null ? void 0 : range.getBoundingClientRect();
  return rect || null;
}
var __freeze$z = Object.freeze;
var __defProp$z = Object.defineProperty;
var __template$z = (cooked, raw) => __freeze$z(__defProp$z(cooked, "raw", { value: __freeze$z(raw || cooked.slice()) }));
var _a$z;
var MotionPopover$1 = ut(motion(Popover2))(_a$z || (_a$z = __template$z(["\n  user-select: none;\n"])));
var POPOVER_FALLBACK_PLACEMENTS$2 = ["bottom", "top"];
var VARIANTS$3 = { hidden: { opacity: 0, y: -4 }, visible: { opacity: 1, y: 0 } };
function FloatingButtonPopover(props) {
  const { disabled, onClick, onClickOutside, referenceElement } = props;
  const [popoverElement, setPopoverElement] = (0, import_react2.useState)(null);
  const { t } = useTranslation(commentsLocaleNamespace);
  useClickOutside(onClickOutside, [popoverElement]);
  const disabledText = t("inline-add-comment-button.disabled-overlap-title");
  const enabledText = t("inline-add-comment-button.title");
  const text = disabled ? disabledText : enabledText;
  const content = (0, import_jsx_runtime.jsx)(Button2, { "data-testid": "inline-comment-button", disabled, icon: disabled ? CommentDisabledIcon : AddCommentIcon, mode: "bleed", onClick, ref: setPopoverElement, text });
  return (0, import_jsx_runtime.jsx)(MotionPopover$1, { animate: "visible", content, contentEditable: false, fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$2, initial: "hidden", open: true, padding: 1, placement: "bottom", portal: true, referenceElement, variants: VARIANTS$3 });
}
var __freeze$y = Object.freeze;
var __defProp$y = Object.defineProperty;
var __template$y = (cooked, raw) => __freeze$y(__defProp$y(cooked, "raw", { value: __freeze$y(raw || cooked.slice()) }));
var _a$y;
var POPOVER_FALLBACK_PLACEMENTS$1 = ["bottom", "top"];
var MotionPopover = motion(Popover2);
var RootStack = ut(Stack)(_a$y || (_a$y = __template$y(["\n  width: 250px;\n"])));
var VARIANTS$2 = { hidden: { opacity: 0 }, visible: { opacity: 1 } };
function InlineCommentInputPopover(props) {
  const { currentUser, mentionOptions, onChange, onClickOutside, onDiscardConfirm, onSubmit, referenceElement, value } = props;
  const commentInputRef = (0, import_react2.useRef)(null);
  const [contentElement, setContentElement] = (0, import_react2.useState)(null);
  const handleDiscardConfirm = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = commentInputRef.current) == null ? void 0 : _a2.discardDialogController.close();
    onDiscardConfirm();
  }, [onDiscardConfirm]);
  const handleDiscardCancel = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = commentInputRef.current) == null ? void 0 : _a2.discardDialogController.close();
  }, []);
  const handleClickOutside = (0, import_react2.useCallback)(() => {
    var _a2;
    const hasValue = hasCommentMessageValue(value);
    if (hasValue) {
      (_a2 = commentInputRef.current) == null ? void 0 : _a2.discardDialogController.open();
      return;
    }
    onClickOutside();
  }, [onClickOutside, value]);
  useClickOutside(handleClickOutside, [contentElement]);
  const content = (0, import_jsx_runtime.jsx)(RootStack, { padding: 2, ref: setContentElement, children: (0, import_jsx_runtime.jsx)(CommentInput, { currentUser, focusLock: true, focusOnMount: true, mentionOptions, onChange, onDiscardCancel: handleDiscardCancel, onDiscardConfirm: handleDiscardConfirm, onSubmit, ref: commentInputRef, value }) });
  return (0, import_jsx_runtime.jsx)(MotionPopover, { animate: "visible", content, "data-ui": "InlineCommentInputPopover", fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS$1, initial: "hidden", open: true, placement: "bottom", portal: true, referenceElement, variants: VARIANTS$2 });
}
var EMPTY_ARRAY$6 = [];
var AI_ASSIST_TYPE = "sanity.assist.instruction.prompt";
function CommentsPortableTextInput(props) {
  const { enabled, mode } = useCommentsEnabled();
  const isAiAssist = props.schemaType.name === AI_ASSIST_TYPE;
  if (!enabled || isAiAssist) {
    return props.renderDefault(props);
  }
  return (0, import_jsx_runtime.jsx)(CommentsPortableTextInputInner, { ...props, mode });
}
var CommentsPortableTextInputInner = import_react2.default.memo(function CommentsPortableTextInputInner2(props) {
  var _a2, _b2;
  const { mode } = props;
  const currentUser = useCurrentUser();
  const portal = usePortal();
  const { mentionOptions, comments: comments2, operation, onCommentsOpen, getComment, setStatus, status } = useComments();
  const { setSelectedPath, selectedPath } = useCommentsSelectedPath();
  const { scrollToComment, scrollToGroup } = useCommentsScroll();
  const { handleOpenDialog } = useCommentsUpsell();
  const editorRef = (0, import_react2.useRef)(null);
  const mouseDownRef = (0, import_react2.useRef)(false);
  const [nextCommentValue, setNextCommentValue] = (0, import_react2.useState)(null);
  const [nextCommentSelection, setNextCommentSelection] = (0, import_react2.useState)(null);
  const [currentSelection, setCurrentSelection] = (0, import_react2.useState)(null);
  const [currentSelectionRect, setCurrenSelectionRect] = (0, import_react2.useState)(null);
  const [currentHoveredCommentId, setCurrentHoveredCommentId] = (0, import_react2.useState)(null);
  const [canSubmit, setCanSubmit] = (0, import_react2.useState)(false);
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const [isFullScreen, setIsFullScreen] = (0, import_react2.useState)(false);
  const [addedCommentsDecorations, setAddedCommentsDecorations] = (0, import_react2.useState)(EMPTY_ARRAY$6);
  const stringFieldPath = (0, import_react2.useMemo)(() => toString(props.path), [props.path]);
  const handleSetCurrentSelectionRect = (0, import_react2.useCallback)(() => {
    const rect = getSelectionBoundingRect();
    setCurrenSelectionRect(rect);
  }, []);
  const resetStates = (0, import_react2.useCallback)(() => {
    setCurrentSelection(null);
    setCurrenSelectionRect(null);
    setNextCommentSelection(null);
    setNextCommentValue(null);
    setCanSubmit(false);
  }, []);
  const handleSelectCurrentSelection = (0, import_react2.useCallback)(() => {
    if (mode === "upsell") {
      handleOpenDialog("pte");
      return;
    }
    setNextCommentSelection(currentSelection);
  }, [currentSelection, handleOpenDialog, mode]);
  const handleCommentDiscardConfirm = (0, import_react2.useCallback)(() => {
    resetStates();
  }, [resetStates]);
  const textComments = (0, import_react2.useMemo)(() => {
    return comments2.data.open.filter((comment) => comment.fieldPath === stringFieldPath).filter((c) => isTextSelectionComment(c.parentComment)).map((c) => c.parentComment);
  }, [comments2.data.open, stringFieldPath]);
  const getFragment = (0, import_react2.useCallback)(() => {
    if (!editorRef.current)
      return EMPTY_ARRAY$6;
    return PortableTextEditor.getFragment(editorRef.current);
  }, []);
  const handleSubmit = (0, import_react2.useCallback)(() => {
    if (!nextCommentSelection || !editorRef.current)
      return;
    const fragment = getFragment() || EMPTY_ARRAY$6;
    const editorValue = PortableTextEditor.getValue(editorRef.current);
    if (!editorValue)
      return;
    const textSelection = buildTextSelectionFromFragment({ fragment, selection: nextCommentSelection, value: editorValue });
    const threadId = v4_default();
    operation.create({ type: "field", contentSnapshot: fragment, fieldPath: stringFieldPath, message: nextCommentValue, parentCommentId: void 0, reactions: EMPTY_ARRAY$6, selection: textSelection, status: "open", threadId });
    onCommentsOpen == null ? void 0 : onCommentsOpen();
    if (status === "resolved") {
      setStatus("open");
    }
    setSelectedPath({ fieldPath: stringFieldPath, threadId, origin: "form" });
    scrollToGroup(threadId);
    resetStates();
  }, [nextCommentSelection, getFragment, operation, stringFieldPath, nextCommentValue, onCommentsOpen, status, setSelectedPath, scrollToGroup, resetStates, setStatus]);
  const handleDecoratorClick = (0, import_react2.useCallback)((commentId) => {
    var _a22;
    const comment = getComment(commentId);
    if (!comment)
      return;
    setSelectedPath({ fieldPath: ((_a22 = comment.target.path) == null ? void 0 : _a22.field) || "", threadId: comment.threadId, origin: "form" });
    onCommentsOpen == null ? void 0 : onCommentsOpen();
    scrollToComment(comment._id);
  }, [getComment, onCommentsOpen, scrollToComment, setSelectedPath]);
  const handleSelectionChange = (0, import_react2.useCallback)((selection) => {
    const isRangeSelected = (selection == null ? void 0 : selection.anchor.offset) !== (selection == null ? void 0 : selection.focus.offset);
    const fragment = getFragment();
    const isValidSelection = fragment == null ? void 0 : fragment.every(isPortableTextTextBlock);
    if (!isValidSelection || !isRangeSelected) {
      setCanSubmit(false);
      return;
    }
    if (!mouseDownRef.current) {
      handleSetCurrentSelectionRect();
    }
    setCurrentSelection(selection);
    setCanSubmit(true);
  }, [getFragment, handleSetCurrentSelectionRect]);
  const debounceSelectionChange = (0, import_react2.useMemo)(() => (0, import_debounce.default)(handleSelectionChange, 200), [handleSelectionChange]);
  const handleMouseDown = (0, import_react2.useCallback)(() => {
    mouseDownRef.current = true;
  }, []);
  const handleMouseUp = (0, import_react2.useCallback)(() => {
    mouseDownRef.current = false;
    handleSetCurrentSelectionRect();
  }, [handleSetCurrentSelectionRect]);
  const handleRangeDecorationMoved = (0, import_react2.useCallback)((details) => {
    var _a22;
    const { rangeDecoration, newSelection } = details;
    const commentId = (_a22 = rangeDecoration.payload) == null ? void 0 : _a22.commentId;
    setAddedCommentsDecorations((prev) => {
      const next = prev.map((p) => {
        var _a3;
        if (((_a3 = p.payload) == null ? void 0 : _a3.commentId) === commentId) {
          const nextDecoration = { ...rangeDecoration, selection: newSelection, payload: { ...rangeDecoration.payload, dirty: true } };
          return nextDecoration;
        }
        return p;
      });
      return next;
    });
  }, []);
  const updateCommentRange = (0, import_react2.useCallback)(() => {
    const decoratorsToUpdate = addedCommentsDecorations.filter((decorator) => {
      var _a22;
      return (_a22 = decorator.payload) == null ? void 0 : _a22.dirty;
    });
    if (decoratorsToUpdate.length === 0)
      return;
    decoratorsToUpdate.forEach((decorator) => {
      var _a22, _b22, _c2, _d2, _e2;
      const commentId = (_a22 = decorator.payload) == null ? void 0 : _a22.commentId;
      const comment = getComment(commentId || "");
      if (!comment) {
        return;
      }
      if (!editorRef.current)
        return;
      const editorValue = PortableTextEditor.getValue(editorRef.current) || EMPTY_ARRAY$6;
      const [updatedDecoration] = buildRangeDecorationSelectionsFromComments({ comments: [comment], value: editorValue });
      const nextRange = (updatedDecoration == null ? void 0 : updatedDecoration.range) ? [updatedDecoration.range] : EMPTY_ARRAY$6;
      const nextValue = updatedDecoration ? [...((_c2 = (_b22 = comment.target.path) == null ? void 0 : _b22.selection) == null ? void 0 : _c2.value.filter((r) => {
        var _a3;
        return r._key !== ((_a3 = nextRange[0]) == null ? void 0 : _a3._key);
      }).concat(nextRange).flat()) || EMPTY_ARRAY$6] : EMPTY_ARRAY$6;
      const nextComment = { target: { ...comment.target, path: { ...((_d2 = comment.target) == null ? void 0 : _d2.path) || {}, field: ((_e2 = comment.target.path) == null ? void 0 : _e2.field) || "", selection: { type: "text", value: nextValue } } } };
      operation.update(comment._id, nextComment);
    });
    setAddedCommentsDecorations((prev) => {
      const next = prev.map((p) => {
        var _a22, _b22;
        const isDirty = (_b22 = (_a22 = decoratorsToUpdate.find((d) => {
          var _a3, _b3;
          return ((_a3 = d.payload) == null ? void 0 : _a3.commentId) === ((_b3 = p.payload) == null ? void 0 : _b3.commentId);
        })) == null ? void 0 : _a22.payload) == null ? void 0 : _b22.dirty;
        if (isDirty) {
          const nextDecoration = { ...p, payload: { ...p.payload, dirty: false } };
          return nextDecoration;
        }
        return p;
      });
      return next.filter((p) => p.selection !== null);
    });
  }, [addedCommentsDecorations, getComment, operation]);
  const handleBuildRangeDecorations = (0, import_react2.useCallback)((commentsToDecorate) => {
    if (!editorRef.current)
      return EMPTY_ARRAY$6;
    const editorValue = PortableTextEditor.getValue(editorRef.current) || EMPTY_ARRAY$6;
    return buildRangeDecorations({ comments: commentsToDecorate, currentHoveredCommentId, onDecorationClick: handleDecoratorClick, onDecorationHoverEnd: setCurrentHoveredCommentId, onDecorationHoverStart: setCurrentHoveredCommentId, onDecorationMoved: handleRangeDecorationMoved, selectedThreadId: (selectedPath == null ? void 0 : selectedPath.threadId) || null, value: editorValue });
  }, [currentHoveredCommentId, handleDecoratorClick, handleRangeDecorationMoved, selectedPath == null ? void 0 : selectedPath.threadId]);
  const onEditorChange = (0, import_react2.useCallback)((change) => {
    if (change.type === "mutation") {
      updateCommentRange();
    }
    if (change.type === "selection") {
      debounceSelectionChange(change.selection);
    }
  }, [debounceSelectionChange, updateCommentRange]);
  const authoringDecoration = (0, import_react2.useMemo)(() => {
    if (!nextCommentSelection)
      return null;
    return { component: (_ref71) => {
      let { children } = _ref71;
      return (0, import_jsx_runtime.jsx)(CommentInlineHighlightSpan, { isAuthoring: true, children });
    }, selection: nextCommentSelection };
  }, [nextCommentSelection]);
  const rangeDecorations = (0, import_react2.useMemo)(() => {
    return [
      // Existing range decorations
      ...(props == null ? void 0 : props.rangeDecorations) || EMPTY_ARRAY$6,
      // The range decoration when adding a comment
      ...authoringDecoration ? [authoringDecoration] : EMPTY_ARRAY$6,
      // The range decorations for existing comments
      ...addedCommentsDecorations
    ];
  }, [addedCommentsDecorations, authoringDecoration, props == null ? void 0 : props.rangeDecorations]);
  const currentSelectionIsOverlapping = (0, import_react2.useMemo)(() => {
    if (!currentSelection || addedCommentsDecorations.length === 0)
      return false;
    return addedCommentsDecorations.some((d) => {
      if (!editorRef.current)
        return false;
      const testA = PortableTextEditor.isSelectionsOverlapping(editorRef.current, currentSelection, d.selection);
      const testB = PortableTextEditor.isSelectionsOverlapping(editorRef.current, d.selection, currentSelection);
      return testA || testB;
    });
  }, [addedCommentsDecorations, currentSelection]);
  const scrollElement = isFullScreen ? document.body : ((_a2 = portal.elements) == null ? void 0 : _a2.documentScrollElement) || document.body;
  const boundaryElement = isFullScreen ? ((_b2 = portal.elements) == null ? void 0 : _b2.documentScrollElement) || document.body : rootElement;
  const popoverAuthoringReferenceElement = useAuthoringReferenceElement({ scrollElement, disabled: !nextCommentSelection, selector: '[data-inline-comment-state="authoring"]' });
  const selectionReferenceElement = (0, import_react2.useMemo)(() => {
    if (!currentSelectionRect)
      return null;
    return { getBoundingClientRect: () => currentSelectionRect };
  }, [currentSelectionRect]);
  (0, import_react2.useEffect)(() => {
    if (!currentSelection)
      return void 0;
    scrollElement == null ? void 0 : scrollElement.addEventListener("wheel", handleSetCurrentSelectionRect);
    return () => {
      scrollElement == null ? void 0 : scrollElement.removeEventListener("wheel", handleSetCurrentSelectionRect);
    };
  }, [currentSelection, scrollElement, handleSetCurrentSelectionRect]);
  (0, import_react2.useEffect)(() => {
    const nextDecorations = handleBuildRangeDecorations(textComments);
    setAddedCommentsDecorations((current) => {
      return nextDecorations.map((nextDecoration) => {
        var _a22;
        const prevDecoration = current.find((p) => {
          var _a3, _b22;
          return ((_a3 = p.payload) == null ? void 0 : _a3.commentId) === ((_b22 = nextDecoration.payload) == null ? void 0 : _b22.commentId);
        });
        if ((_a22 = prevDecoration == null ? void 0 : prevDecoration.payload) == null ? void 0 : _a22.dirty) {
          return { ...nextDecoration, payload: { ...nextDecoration.payload, dirty: prevDecoration.payload.dirty } };
        }
        return nextDecoration;
      });
    });
  }, [handleBuildRangeDecorations, textComments]);
  const showFloatingButton = Boolean(currentSelection && canSubmit && selectionReferenceElement && !mouseDownRef.current);
  const showFloatingInput = Boolean(nextCommentSelection && popoverAuthoringReferenceElement);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(BoundaryElementProvider, { element: boundaryElement, children: (0, import_jsx_runtime.jsxs)(AnimatePresence, { children: [showFloatingInput && currentUser && (0, import_jsx_runtime.jsx)(InlineCommentInputPopover, { currentUser, mentionOptions, onChange: setNextCommentValue, onClickOutside: resetStates, onDiscardConfirm: handleCommentDiscardConfirm, onSubmit: handleSubmit, referenceElement: popoverAuthoringReferenceElement, value: nextCommentValue }), showFloatingButton && !showFloatingInput && (0, import_jsx_runtime.jsx)(FloatingButtonPopover, { disabled: currentSelectionIsOverlapping, onClick: handleSelectCurrentSelection, onClickOutside: resetStates, referenceElement: selectionReferenceElement })] }) }), (0, import_jsx_runtime.jsx)(Stack, { ref: setRootElement, onMouseDown: handleMouseDown, onMouseUp: handleMouseUp, children: props.renderDefault({ ...props, onEditorChange, editorRef, rangeDecorations, onFullScreenChange: setIsFullScreen }) })] });
});
function isPortableTextInputProps(inputProps) {
  return isArrayOfBlocksSchemaType(inputProps.schemaType);
}
function CommentsInput(props) {
  if (isPortableTextInputProps(props)) {
    return (0, import_jsx_runtime.jsx)(CommentsPortableTextInput, { ...props });
  }
  return props.renderDefault(props);
}
var _DEBUG = false;
var EMPTY_PARAMS$1 = {};
var LOADING_PANE = Symbol("LOADING_PANE");
var DOCUMENT_PANEL_PORTAL_ELEMENT = "documentPanelPortalElement";
var DocumentPaneContext = (0, import_react2.createContext)(null);
function useDocumentPane() {
  const documentPane = (0, import_react2.useContext)(DocumentPaneContext);
  if (!documentPane) {
    throw new Error("DocumentPane: missing context value");
  }
  return documentPane;
}
var __freeze$x = Object.freeze;
var __defProp$x = Object.defineProperty;
var __template$x = (cooked, raw) => __freeze$x(__defProp$x(cooked, "raw", { value: __freeze$x(raw || cooked.slice()) }));
var _a$x;
var _b$d;
var FEEDBACK_FORM_LINK = "https://snty.link/comments-beta-feedback";
var Span = ut.span(_a$x || (_a$x = __template$x(["\n  margin-right: 0.2em;\n"])));
var Link = ut.a(_b$d || (_b$d = __template$x(["\n  white-space: nowrap;\n"])));
var FooterCard = ut(Card)({ position: "relative", zIndex: 1 });
function CommentsInspectorFeedbackFooter() {
  const { t } = useTranslation2(commentsLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(FooterCard, { padding: 4, children: (0, import_jsx_runtime.jsxs)(Text, { muted: true, size: 1, children: [t("feature-feedback.title"), " ", (0, import_jsx_runtime.jsxs)(Link, { href: FEEDBACK_FORM_LINK, target: "_blank", rel: "noreferrer", children: [(0, import_jsx_runtime.jsxs)(Span, { children: [t("feature-feedback.link"), " "] }), " ", (0, import_jsx_runtime.jsx)(LaunchIcon, {})] })] }) });
}
var Root$7 = ut(Card)({ position: "relative", zIndex: 1, lineHeight: 0 });
var CommentsInspectorHeader = (0, import_react2.forwardRef)(function CommentsInspectorHeader2(props, ref) {
  const { t } = useTranslation2(commentsLocaleNamespace);
  const { onClose, onViewChange, view, mode } = props;
  const handleSetOpenView = (0, import_react2.useCallback)(() => onViewChange("open"), [onViewChange]);
  const handleSetResolvedView = (0, import_react2.useCallback)(() => onViewChange("resolved"), [onViewChange]);
  return (0, import_jsx_runtime.jsx)(Root$7, { ref, children: (0, import_jsx_runtime.jsxs)(Flex, { padding: 2, children: [(0, import_jsx_runtime.jsxs)(Flex, { align: "center", flex: 1, gap: 2, paddingY: 2, padding: 3, children: [(0, import_jsx_runtime.jsx)(Text, { as: "h1", size: 1, weight: "medium", children: t("feature-name") }), (0, import_jsx_runtime.jsx)(BetaBadge, {})] }), (0, import_jsx_runtime.jsxs)(Flex, { flex: "none", padding: 1, gap: 2, children: [(0, import_jsx_runtime.jsx)(MenuButton, { id: "comment-status-menu-button", button: (0, import_jsx_runtime.jsx)(Button2, { text: view === "open" ? t("status-filter.status-open") : t("status-filter.status-resolved"), mode: "bleed", iconRight: ChevronDownIcon }), menu: (0, import_jsx_runtime.jsxs)(Menu, { style: { width: "180px" }, children: [(0, import_jsx_runtime.jsx)(MenuItem2, { iconRight: view === "open" ? CheckmarkIcon : void 0, onClick: handleSetOpenView, text: t("status-filter.status-open-full") }), (0, import_jsx_runtime.jsx)(MenuItem2, { iconRight: view === "resolved" ? CheckmarkIcon : void 0, onClick: handleSetResolvedView, text: t("status-filter.status-resolved-full"), tooltipProps: mode === "upsell" ? { content: t("status-filter.status-resolved-full-upsell") } : void 0, disabled: mode === "upsell" })] }), popover: { placement: "bottom-end" } }), (0, import_jsx_runtime.jsx)(Button2, { "aria-label": t("close-pane-button-text-aria-label"), icon: DoubleChevronRightIcon, mode: "bleed", onClick: onClose, tooltipProps: { content: t("close-pane-button-text") } })] })] }) });
});
var __freeze$w = Object.freeze;
var __defProp$w = Object.defineProperty;
var __template$w = (cooked, raw) => __freeze$w(__defProp$w(cooked, "raw", { value: __freeze$w(raw || cooked.slice()) }));
var _a$w;
var RootLayer = ut(Layer)(_a$w || (_a$w = __template$w(["\n  display: flex;\n  flex-direction: column;\n  height: 100%;\n  overflow: hidden;\n"])));
function CommentsInspector(props) {
  const { enabled, mode } = useCommentsEnabled();
  if (!enabled)
    return null;
  return (0, import_jsx_runtime.jsx)(RootLayer, { children: (0, import_jsx_runtime.jsx)(CommentsInspectorInner, { ...props, mode }) });
}
function CommentsInspectorInner(props) {
  const { t } = useTranslation2(commentsLocaleNamespace);
  const { onClose, mode } = props;
  const [showDeleteDialog, setShowDeleteDialog] = (0, import_react2.useState)(false);
  const [commentToDelete, setCommentToDelete] = (0, import_react2.useState)(null);
  const [deleteLoading, setDeleteLoading] = (0, import_react2.useState)(false);
  const [deleteError, setDeleteError] = (0, import_react2.useState)(null);
  const rootRef = (0, import_react2.useRef)(null);
  const currentUser = useCurrentUser();
  const { params, createPathWithParams, setParams } = usePaneRouter();
  const uniqueParams = useUnique(params) || EMPTY_PARAMS$1;
  const commentIdParamRef = (0, import_react2.useRef)(uniqueParams == null ? void 0 : uniqueParams.comment);
  const didScrollToCommentFromParam = (0, import_react2.useRef)(false);
  const pushToast = useToast().push;
  const { isTopLayer } = useLayer();
  const { onPathOpen, connectionState } = useDocumentPane();
  const { scrollToComment, scrollToField, scrollToInlineComment } = useCommentsScroll();
  const { selectedPath, setSelectedPath } = useCommentsSelectedPath();
  const { isDismissed, setDismissed } = useCommentsOnboarding();
  const { comments: comments2, getComment, isCreatingDataset, mentionOptions, setStatus, status, operation } = useComments();
  const { upsellData, telemetryLogs } = useCommentsUpsell();
  const currentComments = (0, import_react2.useMemo)(() => comments2.data[status], [comments2, status]);
  const loading = (0, import_react2.useMemo)(() => {
    return comments2.loading || connectionState === "connecting";
  }, [comments2.loading, connectionState]);
  (0, import_react2.useEffect)(() => {
    if (mode === "upsell") {
      if ((selectedPath == null ? void 0 : selectedPath.origin) === "form") {
        telemetryLogs.panelViewed("field_action");
      } else if (commentIdParamRef.current) {
        telemetryLogs.panelViewed("link");
      } else {
        telemetryLogs.panelViewed("document_action");
      }
    }
    return () => {
      if (mode === "upsell") {
        telemetryLogs.panelDismissed();
      }
    };
  }, []);
  const handleChangeView = (0, import_react2.useCallback)((nextView) => {
    setStatus(nextView);
    setSelectedPath(null);
  }, [setSelectedPath, setStatus]);
  const handleCloseInspector = (0, import_react2.useCallback)(() => {
    onClose();
    setSelectedPath(null);
  }, [onClose, setSelectedPath]);
  const handleCopyLink = (0, import_react2.useCallback)((id) => {
    const path = createPathWithParams({ ...params, comment: id });
    const url = "".concat(window.location.origin).concat(path);
    navigator.clipboard.writeText(url).then(() => {
      pushToast({ closable: true, status: "info", title: t("copy-link-success-message") });
    }).catch(() => {
      pushToast({ closable: true, status: "error", title: t("copy-link-error-message") });
    });
  }, [createPathWithParams, params, pushToast, t]);
  const handleCreateRetry = (0, import_react2.useCallback)((id) => {
    var _a2;
    const comment = getComment(id);
    if (!comment)
      return;
    operation.create({ type: "field", fieldPath: ((_a2 = comment.target.path) == null ? void 0 : _a2.field) || "", id: comment._id, message: comment.message, parentCommentId: comment.parentCommentId, reactions: comment.reactions || [], status: comment.status, threadId: comment.threadId });
  }, [getComment, operation]);
  const closeDeleteDialog = (0, import_react2.useCallback)(() => {
    if (deleteLoading)
      return;
    setShowDeleteDialog(false);
    setCommentToDelete(null);
  }, [deleteLoading]);
  const handlePathSelect = (0, import_react2.useCallback)((nextPath) => {
    setSelectedPath(nextPath);
    if (nextPath == null ? void 0 : nextPath.fieldPath) {
      const path = fromString(nextPath.fieldPath);
      onPathOpen(path);
      scrollToField(nextPath.fieldPath);
      const isInlineComment = comments2.data.open.filter((c) => c.threadId === (nextPath == null ? void 0 : nextPath.threadId)).some((x) => isTextSelectionComment(x.parentComment));
      if (isInlineComment && nextPath.threadId) {
        scrollToInlineComment(nextPath.threadId);
      }
    }
  }, [comments2.data.open, onPathOpen, scrollToField, scrollToInlineComment, setSelectedPath]);
  const handleNewThreadCreate = (0, import_react2.useCallback)((nextComment) => {
    var _a2;
    const fieldPath = ((_a2 = nextComment == null ? void 0 : nextComment.payload) == null ? void 0 : _a2.fieldPath) || "";
    operation.create({ type: "field", fieldPath, message: nextComment.message, parentCommentId: nextComment.parentCommentId, reactions: nextComment.reactions, status: nextComment.status, threadId: nextComment.threadId });
    setSelectedPath({ fieldPath, origin: "inspector", threadId: nextComment.threadId });
  }, [operation, setSelectedPath]);
  const handleReply = (0, import_react2.useCallback)((nextComment) => {
    var _a2;
    operation.create({ ...nextComment, type: "field", fieldPath: ((_a2 = nextComment == null ? void 0 : nextComment.payload) == null ? void 0 : _a2.fieldPath) || "" });
  }, [operation]);
  const handleEdit = (0, import_react2.useCallback)((id, nextComment) => {
    operation.update(id, nextComment);
  }, [operation]);
  const onDeleteStart = (0, import_react2.useCallback)((id) => {
    var _a2;
    const parent = currentComments.find((c) => {
      var _a3;
      return ((_a3 = c.parentComment) == null ? void 0 : _a3._id) === id;
    });
    const isParent = Boolean(parent && ((_a2 = parent == null ? void 0 : parent.replies) == null ? void 0 : _a2.length) > 0);
    setShowDeleteDialog(true);
    setCommentToDelete({ commentId: id, isParent });
  }, [currentComments]);
  const handleDeleteConfirm = (0, import_react2.useCallback)(async (id) => {
    try {
      setDeleteLoading(true);
      await operation.remove(id);
      closeDeleteDialog();
    } catch (err) {
      setDeleteError(err);
    } finally {
      setDeleteLoading(false);
    }
  }, [closeDeleteDialog, operation]);
  const handleStatusChange = (0, import_react2.useCallback)((id, nextStatus) => {
    var _a2;
    operation.update(id, { status: nextStatus });
    if (nextStatus === "open") {
      setStatus("open");
      const comment = getComment(id);
      if (!comment)
        return;
      setSelectedPath({ fieldPath: ((_a2 = comment.target.path) == null ? void 0 : _a2.field) || null, origin: "inspector", threadId: comment.threadId || null });
      scrollToComment(id);
    }
  }, [getComment, operation, scrollToComment, setSelectedPath, setStatus]);
  const handleReactionSelect = (0, import_react2.useCallback)((id, reaction) => {
    operation.react(id, reaction);
  }, [operation]);
  const handleDeselectPath = (0, import_react2.useCallback)(() => {
    if (selectedPath && isTopLayer) {
      setSelectedPath(null);
    }
  }, [isTopLayer, selectedPath, setSelectedPath]);
  const handleClickOutside = (0, import_react2.useCallback)((e2) => {
    var _a2;
    const isPTETarget = e2.target instanceof HTMLElement && ((_a2 = e2.target) == null ? void 0 : _a2.hasAttribute("data-slate-string"));
    if (!isPTETarget) {
      handleDeselectPath();
    }
  }, [handleDeselectPath]);
  useClickOutside(handleClickOutside, [rootRef.current]);
  (0, import_react2.useEffect)(() => {
    var _a2;
    const commentToScrollTo = getComment(commentIdParamRef.current || "");
    if (!loading && commentToScrollTo && didScrollToCommentFromParam.current === false) {
      setStatus(commentToScrollTo.status || "open");
      setSelectedPath({ fieldPath: ((_a2 = commentToScrollTo.target.path) == null ? void 0 : _a2.field) || null, origin: "url", threadId: commentToScrollTo.threadId || null });
      scrollToComment(commentToScrollTo._id);
      didScrollToCommentFromParam.current = true;
      commentIdParamRef.current = void 0;
      setParams({ ...params, comment: void 0 });
    }
  }, [getComment, loading, params, scrollToComment, setParams, setSelectedPath, setStatus]);
  const beforeListNode = (0, import_react2.useMemo)(() => {
    if (mode === "upsell" && upsellData) {
      return (0, import_jsx_runtime.jsx)(CommentsUpsellPanel, { data: upsellData, onPrimaryClick: telemetryLogs.panelPrimaryClicked, onSecondaryClick: telemetryLogs.panelSecondaryClicked });
    }
    return null;
  }, [mode, telemetryLogs.panelPrimaryClicked, telemetryLogs.panelSecondaryClicked, upsellData]);
  return (0, import_jsx_runtime.jsxs)(import_react2.Fragment, { children: [commentToDelete && showDeleteDialog && (0, import_jsx_runtime.jsx)(CommentDeleteDialog, { ...commentToDelete, error: deleteError, loading: deleteLoading, onClose: closeDeleteDialog, onConfirm: handleDeleteConfirm }), (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", flex: 1, height: "fill", onClick: handleDeselectPath, overflow: "hidden", ref: rootRef, children: [(0, import_jsx_runtime.jsx)(CommentsOnboardingPopover, { onDismiss: setDismissed, open: !isDismissed, placement: "left-start", children: (0, import_jsx_runtime.jsx)(CommentsInspectorHeader, { onClose: handleCloseInspector, onViewChange: handleChangeView, view: status, mode }) }), currentUser && (0, import_jsx_runtime.jsx)(CommentsList, { beforeListNode, comments: currentComments, currentUser, error: comments2.error, loading, mentionOptions, mode, onCopyLink: handleCopyLink, onCreateRetry: handleCreateRetry, onDelete: onDeleteStart, onEdit: handleEdit, onNewThreadCreate: handleNewThreadCreate, onPathSelect: handlePathSelect, onReactionSelect: handleReactionSelect, onReply: handleReply, onStatusChange: handleStatusChange, readOnly: isCreatingDataset, selectedPath, status }), mode === "default" && (0, import_jsx_runtime.jsx)(CommentsInspectorFeedbackFooter, {})] })] });
}
function useMenuItem$1() {
  const { t } = useTranslation2(commentsLocaleNamespace);
  const { enabled } = useCommentsEnabled();
  return { hidden: !enabled, icon: CommentIcon, showAsAction: true, title: t("feature-name") };
}
var commentsInspector = defineDocumentInspector({ name: COMMENTS_INSPECTOR_NAME, component: CommentsInspector, useMenuItem: useMenuItem$1 });
function CommentsStudioLayout(props) {
  const { enabled, isLoading } = useFeatureEnabled("studioComments");
  return (0, import_jsx_runtime.jsx)(AddonDatasetProvider, { children: (0, import_jsx_runtime.jsx)(CommentsOnboardingProvider, { children: (0, import_jsx_runtime.jsx)(ConditionalWrapper, { condition: !enabled && !isLoading, wrapper: (children) => (0, import_jsx_runtime.jsx)(CommentsUpsellProvider, { children }), children: props.renderDefault(props) }) }) });
}
var comments = definePlugin({ name: "sanity/structure/comments", document: { inspectors: [commentsInspector], components: { unstable_layout: CommentsDocumentLayout } }, form: { components: { field: CommentsField, input: CommentsInput } }, studio: { components: { layout: CommentsStudioLayout } }, i18n: { bundles: [commentsUsEnglishLocaleBundle] } });
function ErrorPane(props) {
  const { children, currentMinWidth, flex, minWidth, paneKey, title = "Error", tone = "critical" } = props;
  return (0, import_jsx_runtime.jsxs)(Pane, { currentMinWidth, flex, id: paneKey, minWidth, tone, children: [(0, import_jsx_runtime.jsx)(PaneHeader, { title }), (0, import_jsx_runtime.jsx)(PaneContent, { overflow: "auto", children: (0, import_jsx_runtime.jsx)(Box, { paddingX: 4, paddingY: 5, children }) })] });
}
function getWaitMessages(path) {
  const thresholds = [{ ms: 300, messageKey: "panes.resolving.default-message" }, { ms: 5e3, messageKey: "panes.resolving.slow-resolve-message" }];
  if (isDev) {
    const message = ["Check console for errors?", "Is your observable/promise resolving?", path.length > 0 ? "Structure path: ".concat(path.join(" ➝ ")) : ""];
    thresholds.push({ ms: 1e4, message: message.join("\n") });
  }
  const src = of(null);
  return merge(...thresholds.map((threshold) => src.pipe(mapTo("messageKey" in threshold ? { messageKey: threshold.messageKey } : { message: threshold.message }), delay(threshold.ms))));
}
var __freeze$v = Object.freeze;
var __defProp$v = Object.defineProperty;
var __template$v = (cooked, raw) => __freeze$v(__defProp$v(cooked, "raw", { value: __freeze$v(raw || cooked.slice()) }));
var _a$v;
var DEFAULT_MESSAGE_KEY = "panes.resolving.default-message";
var Content$1 = ut(Flex)(_a$v || (_a$v = __template$v(["\n  opacity: 0;\n  transition: opacity 200ms;\n\n  &[data-mounted] {\n    opacity: 1;\n  }\n"])));
var LoadingPane = (0, import_react2.memo)((props) => {
  const { delay: delay2 = 300, flex, message: messageProp = getWaitMessages, minWidth, paneKey, path, selected, title, tone } = props;
  const { t } = useTranslation2(structureLocaleNamespace);
  const resolvedMessage = (0, import_react2.useMemo)(() => {
    if (typeof messageProp === "function") {
      return messageProp(path ? path.split(";") : []);
    }
    return messageProp;
  }, [messageProp, path]);
  const [currentMessage, setCurrentMessage] = (0, import_react2.useState)(() => {
    if (typeof resolvedMessage === "string")
      return resolvedMessage;
    return DEFAULT_MESSAGE_KEY;
  });
  (0, import_react2.useEffect)(() => {
    if (typeof resolvedMessage !== "object")
      return void 0;
    if (typeof resolvedMessage.subscribe === "function")
      return void 0;
    const sub = resolvedMessage.subscribe((message) => {
      setCurrentMessage("messageKey" in message ? t(message.messageKey) : message.message);
    });
    return () => sub.unsubscribe();
  }, [resolvedMessage, t]);
  const [contentElement, setContentElement] = (0, import_react2.useState)(null);
  const [mounted, setMounted] = (0, import_react2.useState)(false);
  (0, import_react2.useEffect)(() => {
    if (!contentElement)
      return void 0;
    return _raf2(() => setMounted(true));
  }, [contentElement]);
  const content = (0, import_jsx_runtime.jsx)(Content$1, { align: "center", "data-mounted": mounted ? "" : void 0, direction: "column", height: "fill", justify: "center", ref: setContentElement, children: (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true, title: title || currentMessage }) });
  return (0, import_jsx_runtime.jsx)(Pane, { flex, id: paneKey, minWidth, selected, tone, children: (0, import_jsx_runtime.jsx)(PaneContent, { children: content }) });
});
LoadingPane.displayName = "LoadingPane";
var StructureToolContext = (0, import_react2.createContext)(null);
function useStructureTool() {
  const structureTool2 = (0, import_react2.useContext)(StructureToolContext);
  if (!structureTool2)
    throw new Error("StructureTool: missing context value");
  return structureTool2;
}
var InspectorMenuItem = (0, import_react2.memo)(function InspectorMenuItem2(props) {
  const { documentId, documentType, index, setMenuItem, useMenuItem: useMenuItem2 } = props;
  const node = useUnique(useMenuItem2({ documentId, documentType }));
  (0, import_react2.useEffect)(() => {
    setMenuItem(index, node);
  }, [index, node, setMenuItem]);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
});
function DocumentInspectorMenuItemsResolver(props) {
  const { documentId, documentType, inspectors: inspectors2, onMenuItems } = props;
  const len = inspectors2.length;
  const lenRef = (0, import_react2.useRef)(len);
  const [menuItems, setMenuItems] = (0, import_react2.useState)(() => Array.from(new Array(len)));
  const menuItemsRef = (0, import_react2.useRef)(menuItems);
  (0, import_react2.useEffect)(() => {
    if (lenRef.current !== len) {
      const newFieldActions = Array.from(new Array(len));
      for (let i = 0; i < len; i++) {
        newFieldActions[i] = menuItemsRef.current[i];
      }
      lenRef.current = len;
      setMenuItems(() => {
        menuItemsRef.current = newFieldActions;
        return newFieldActions;
      });
    }
  }, [len]);
  const setMenuItem = (0, import_react2.useCallback)((index, node) => {
    setMenuItems((prev) => {
      const next = [...prev];
      next[index] = node;
      menuItemsRef.current = next;
      return next;
    });
  }, []);
  (0, import_react2.useEffect)(() => {
    onMenuItems(menuItems.filter(Boolean));
  }, [menuItems, onMenuItems]);
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: inspectors2.map((inspector, inspectorIndex) => inspector.useMenuItem && (0, import_jsx_runtime.jsx)(InspectorMenuItem, { documentId, documentType, index: inspectorIndex, setMenuItem, useMenuItem: inspector.useMenuItem }, inspector.name)) });
}
function useDocumentTitle() {
  const { connectionState, schemaType, title, value: documentValue } = useDocumentPane();
  const subscribed = Boolean(documentValue) && connectionState !== "connecting";
  const { error, value } = useDocumentPreview({ enabled: subscribed, schemaType, value: documentValue });
  if (connectionState === "connecting") {
    return { error: void 0, title: void 0 };
  }
  if (title) {
    return { error: void 0, title };
  }
  if (!documentValue) {
    return { error: void 0, title: "New ".concat((schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name)) };
  }
  if (error) {
    return { error: "Error: ".concat(error.message), title: void 0 };
  }
  return { error: void 0, title: value == null ? void 0 : value.title };
}
var IGNORE_OPS = ["patch", "commit"];
var DocumentOperationResults = (0, import_react2.memo)(function DocumentOperationResults2() {
  const { push: pushToast } = useToast();
  const { documentId, documentType } = useDocumentPane();
  const { title } = useDocumentTitle();
  const event = useDocumentOperationEvent(documentId, documentType);
  const prevEvent = (0, import_react2.useRef)(event);
  const paneRouter = usePaneRouter();
  const { t } = useTranslation2(structureLocaleNamespace);
  const documentTitleBase = title || t("panes.document-operation-results.operation-undefined-title");
  const documentTitle = documentTitleBase.length > 25 ? "".concat(documentTitleBase.slice(0, 25), "...") : documentTitleBase;
  (0, import_react2.useEffect)(() => {
    if (!event || event === prevEvent.current)
      return;
    let cleanupId;
    if (event.type === "error") {
      pushToast({
        closable: true,
        duration: 3e4,
        // 30s
        status: "error",
        title: t("panes.document-operation-results.operation-error", { context: event.op }),
        description: (0, import_jsx_runtime.jsxs)("details", { children: [(0, import_jsx_runtime.jsx)("summary", { children: t("panes.document-operation-results.error.summary.title") }), event.error.message] })
      });
    }
    if (event.type === "success" && !IGNORE_OPS.includes(event.op)) {
      pushToast({ closable: true, status: "success", title: (0, import_jsx_runtime.jsx)(Translate, { context: event.op, i18nKey: "panes.document-operation-results.operation-success", t, values: { title: documentTitle }, components: { Strong: "strong" } }) });
    }
    if (event.type === "success" && event.op === "delete") {
      cleanupId = setTimeout(() => paneRouter.closeCurrentAndAfter(), 0);
    }
    prevEvent.current = event;
    return () => clearTimeout(cleanupId);
  }, [event, paneRouter, pushToast, t, documentTitle]);
  return null;
});
var Root$6 = ut(Card)({ position: "relative", zIndex: 1, lineHeight: 0 });
function DocumentInspectorHeader(props) {
  const { as: forwardedAs, children, closeButtonLabel, onClose, title, ...restProps } = props;
  const { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime.jsxs)(Root$6, { ...restProps, as: forwardedAs, children: [(0, import_jsx_runtime.jsxs)(Flex, { padding: 2, children: [(0, import_jsx_runtime.jsx)(Box, { flex: 1, padding: 3, children: (0, import_jsx_runtime.jsx)(Text, { as: "h1", size: 1, weight: "medium", children: title }) }), (0, import_jsx_runtime.jsx)(Box, { flex: "none", padding: 1, children: (0, import_jsx_runtime.jsx)(Button2, { "aria-label": closeButtonLabel, icon: CloseIcon, mode: "bleed", onClick: onClose, tooltipProps: { content: t("document-inspector.close-button.tooltip") } }) })] }), children] });
}
var __freeze$u = Object.freeze;
var __defProp$u = Object.defineProperty;
var __template$u = (cooked, raw) => __freeze$u(__defProp$u(cooked, "raw", { value: __freeze$u(raw || cooked.slice()) }));
var _a$u;
var Root$5 = ut.div(_a$u || (_a$u = __template$u(["\n  position: absolute;\n  top: 0;\n  left: -4px;\n  bottom: 0;\n  width: 9px;\n  z-index: 201;\n  cursor: ew-resize;\n\n  /* Border */\n  & > span:nth-child(1) {\n    display: block;\n    border-left: 1px solid var(--card-border-color);\n    position: absolute;\n    top: 0;\n    left: 4px;\n    bottom: 0;\n    transition: opacity 200ms;\n  }\n\n  /* Hover effect */\n  & > span:nth-child(2) {\n    display: block;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 9px;\n    bottom: 0;\n    background-color: var(--card-border-color);\n    opacity: 0;\n    transition: opacity 150ms;\n  }\n\n  @media (hover: hover) {\n    &:hover > span:nth-child(2) {\n      opacity: 0.2;\n    }\n  }\n"])));
function Resizer(props) {
  const { onResize, onResizeStart } = props;
  const mouseXRef = (0, import_react2.useRef)(0);
  const handleMouseDown = (0, import_react2.useCallback)((event) => {
    event.preventDefault();
    mouseXRef.current = event.pageX;
    onResizeStart();
    const handleMouseMove = (e2) => {
      e2.preventDefault();
      onResize(e2.pageX - mouseXRef.current);
    };
    const handleMouseUp = () => {
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
    };
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
  }, [onResize, onResizeStart]);
  return (0, import_jsx_runtime.jsxs)(Root$5, { onMouseDown: handleMouseDown, children: [(0, import_jsx_runtime.jsx)("span", {}), (0, import_jsx_runtime.jsx)("span", {})] });
}
var __freeze$t = Object.freeze;
var __defProp$t = Object.defineProperty;
var __template$t = (cooked, raw) => __freeze$t(__defProp$t(cooked, "raw", { value: __freeze$t(raw || cooked.slice()) }));
var _a$t;
var Root$4 = ut(Box)(_a$t || (_a$t = __template$t(["\n  position: relative;\n  flex: 1;\n  padding-left: 1px;\n"])));
function Resizable(props) {
  const { as: forwardedAs, children, minWidth, maxWidth, ...restProps } = props;
  const [element, setElement] = (0, import_react2.useState)(null);
  const elementWidthRef = (0, import_react2.useRef)();
  const [targetWidth, setTargetWidth] = (0, import_react2.useState)();
  const handleResizeStart = (0, import_react2.useCallback)(() => {
    elementWidthRef.current = element == null ? void 0 : element.offsetWidth;
  }, [element]);
  const handleResize = (0, import_react2.useCallback)((deltaX) => {
    const w = elementWidthRef.current;
    if (!w)
      return;
    setTargetWidth(Math.min(Math.max(w - deltaX, minWidth), maxWidth));
  }, [minWidth, maxWidth]);
  const style = (0, import_react2.useMemo)(() => targetWidth ? { flex: "none", width: targetWidth } : { minWidth, maxWidth }, [minWidth, maxWidth, targetWidth]);
  return (0, import_jsx_runtime.jsxs)(Root$4, { as: forwardedAs, ...restProps, ref: setElement, style, children: [children, (0, import_jsx_runtime.jsx)(Resizer, { onResize: handleResize, onResizeStart: handleResizeStart })] });
}
function DocumentInspectorPanel(props) {
  const { documentId, documentType, flex } = props;
  const { collapsed } = usePane();
  const { closeInspector, inspector } = useDocumentPane();
  const { features } = useStructureTool();
  const handleClose = (0, import_react2.useCallback)(() => {
    if (inspector)
      closeInspector(inspector.name);
  }, [closeInspector, inspector]);
  if (collapsed || !inspector)
    return null;
  const element = (0, import_react2.createElement)(inspector.component, { onClose: handleClose, documentId, documentType });
  if (features.resizablePanes) {
    return (0, import_jsx_runtime.jsx)(Resizable, { as: "aside", "data-ui": "DocumentInspectorPanel", flex, maxWidth: DOCUMENT_INSPECTOR_MAX_WIDTH, minWidth: DOCUMENT_INSPECTOR_MIN_WIDTH, children: element });
  }
  return (0, import_jsx_runtime.jsx)(Box, { as: "aside", "data-ui": "DocumentInspectorPanel", flex, children: element });
}
var STRUCTURE_TOOL_NAMESPACE = "studio.structure-tool";
function useStructureToolSetting(namespace, key, defaultValue) {
  const keyValueStore = useKeyValueStore();
  const [value, setValue] = (0, import_react2.useState)(defaultValue);
  const keyValueStoreKey = [STRUCTURE_TOOL_NAMESPACE, namespace, key].filter(Boolean).join(".");
  const settings = (0, import_react2.useMemo)(() => {
    return keyValueStore.getKey(keyValueStoreKey);
  }, [keyValueStore, keyValueStoreKey]);
  (0, import_react2.useEffect)(() => {
    const sub = settings.pipe(startWith(defaultValue), map((fetchedValue) => {
      return fetchedValue === null ? defaultValue : fetchedValue;
    })).subscribe({ next: setValue });
    return () => sub == null ? void 0 : sub.unsubscribe();
  }, [defaultValue, keyValueStoreKey, settings]);
  const set2 = (0, import_react2.useCallback)((newValue) => {
    setValue(newValue);
    keyValueStore.setKey(keyValueStoreKey, newValue);
  }, [keyValueStore, keyValueStoreKey]);
  return (0, import_react2.useMemo)(() => [value, set2], [set2, value]);
}
var VIEW_MODE_PARSED = { id: "parsed", title: "document-inspector.view-mode.parsed" };
var VIEW_MODE_RAW = { id: "raw", title: "document-inspector.view-mode.raw-json" };
var VIEW_MODES = [VIEW_MODE_PARSED, VIEW_MODE_RAW];
var lru = (0, import_hashlru.default)(1e3);
function isExpanded(keyPath, value) {
  const cached = lru.get(keyPath);
  if (cached === void 0) {
    lru.set(keyPath, Array.isArray(value) || isRecord$4(value));
    return isExpanded(keyPath, value);
  }
  return cached;
}
function toggleExpanded(event) {
  const { path } = event;
  const current = lru.get(path);
  if (current === void 0) {
    return;
  }
  lru.set(path, !current);
}
function selectElement(element) {
  const sel = window.getSelection();
  if (sel) {
    const range = document.createRange();
    sel.removeAllRanges();
    range.selectNodeContents(element);
    sel.addRange(range);
  }
}
function select(event) {
  selectElement(event.currentTarget);
}
function maybeSelectAll(event) {
  const selectAll = event.keyCode === 65 && (event.metaKey || event.ctrlKey);
  if (!selectAll) {
    return;
  }
  event.preventDefault();
  selectElement(event.currentTarget);
}
function isDocumentLike(value) {
  return isRecord$4(value) && isString(value._id) && isString(value._type);
}
var __freeze$s = Object.freeze;
var __defProp$s = Object.defineProperty;
var __template$s = (cooked, raw) => __freeze$s(__defProp$s(cooked, "raw", { value: __freeze$s(raw || cooked.slice()) }));
var _a$s;
var JSONInspectorWrapper = ut.div((_ref72) => {
  let { theme } = _ref72;
  const { color, fonts, space } = theme.sanity;
  return at(_a$s || (_a$s = __template$s(["\n    & .json-inspector,\n    & .json-inspector .json-inspector__selection {\n      font-family: ", ";\n      font-size: ", "px;\n      line-height: ", "px;\n      color: var(--card-code-fg-color);\n    }\n\n    & .json-inspector .json-inspector__leaf {\n      padding-left: ", ";\n    }\n\n    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {\n      padding-top: ", ";\n      padding-left: 0;\n    }\n\n    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {\n      display: none;\n    }\n\n    & .json-inspector .json-inspector__line {\n      display: block;\n      position: relative;\n      cursor: default;\n    }\n\n    & .json-inspector .json-inspector__line::after {\n      content: '';\n      position: absolute;\n      top: 0;\n      left: -200px;\n      right: -50px;\n      bottom: 0;\n      z-index: -1;\n      pointer-events: none;\n    }\n\n    & .json-inspector .json-inspector__line:hover::after {\n      background: var(--card-code-bg-color);\n    }\n\n    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {\n      cursor: pointer;\n    }\n\n    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {\n      content: '▸ ';\n      margin-left: calc(0 - ", " + 3px);\n      font-size: ", "px;\n      line-height: ", "px;\n    }\n\n    &\n      .json-inspector\n      .json-inspector__leaf_expanded.json-inspector__leaf_composite\n      > .json-inspector__line::before {\n      content: '▾ ';\n      font-size: ", "px;\n      line-height: ", "px;\n    }\n\n    & .json-inspector .json-inspector__radio,\n    & .json-inspector .json-inspector__flatpath {\n      display: none;\n    }\n\n    & .json-inspector .json-inspector__value {\n      margin-left: ", ";\n    }\n\n    &\n      .json-inspector\n      > .json-inspector__leaf_root\n      > .json-inspector__line\n      > .json-inspector__key\n      + .json-inspector__value {\n      margin: 0;\n    }\n\n    & .json-inspector .json-inspector__key {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_helper,\n    & .json-inspector .json-inspector__value_null {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__not-found {\n      padding-top: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_string {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_boolean {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__value_number {\n      color: ", ";\n    }\n\n    & .json-inspector .json-inspector__show-original {\n      display: inline-block;\n      padding: 0 6px;\n      cursor: pointer;\n    }\n\n    & .json-inspector .json-inspector__show-original:hover {\n      color: inherit;\n    }\n\n    & .json-inspector .json-inspector__show-original::before {\n      content: '↔';\n    }\n\n    & .json-inspector .json-inspector__show-original:hover::after {\n      content: ' expand';\n    }\n  "])), fonts.code.family, fonts.code.sizes[1].fontSize, fonts.code.sizes[1].lineHeight, rem(space[4]), rem(space[3]), rem(space[4]), fonts.code.sizes[1].fontSize, fonts.code.sizes[1].lineHeight, fonts.code.sizes[1].fontSize, fonts.code.sizes[1].lineHeight, rem(space[4] / 2), color.syntax.property, color.syntax.constant, rem(space[3]), color.syntax.string, color.syntax.boolean, color.syntax.number);
});
function Search(props) {
  const { onChange, query } = props;
  const handleChange = (0, import_react2.useCallback)((event) => onChange(event.target.value), [onChange]);
  const { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(TextInput, { icon: SearchIcon, onChange: handleChange, placeholder: t("document-inspector.search.placeholder"), radius: 2, value: query || "" });
}
function InspectDialog(props) {
  const { value } = props;
  const { onInspectClose, paneKey } = useDocumentPane();
  const dialogIdPrefix = "".concat(paneKey, "_inspect_");
  const [viewModeId, onViewModeChange] = useStructureToolSetting("inspect-view-mode", null, "parsed");
  const viewMode = VIEW_MODES.find((mode) => mode.id === viewModeId);
  const setParsedViewMode = (0, import_react2.useCallback)(() => {
    onViewModeChange(VIEW_MODE_PARSED.id);
  }, [onViewModeChange]);
  const setRawViewMode = (0, import_react2.useCallback)(() => {
    onViewModeChange(VIEW_MODE_RAW.id);
  }, [onViewModeChange]);
  const { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(Dialog2, { bodyHeight: "fill", id: "".concat(dialogIdPrefix, "dialog"), header: isDocumentLike(value) ? (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "document-inspector.dialog.title", components: { DocumentTitle: () => (0, import_jsx_runtime.jsx)("em", { children: (0, import_jsx_runtime.jsx)(DocTitle, { document: value }) }) } }) : (0, import_jsx_runtime.jsx)("em", { children: t("document-inspector.dialog.title-no-value") }), onClose: onInspectClose, onClickOutside: onInspectClose, padding: false, width: 2, children: (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", height: "fill", children: [(0, import_jsx_runtime.jsx)(Card, { padding: 3, paddingTop: 0, shadow: 1, style: { position: "sticky", bottom: 0, zIndex: 3 }, children: (0, import_jsx_runtime.jsxs)(TabList, { space: 1, children: [(0, import_jsx_runtime.jsx)(Tab, { "aria-controls": "".concat(dialogIdPrefix, "tabpanel"), id: "".concat(dialogIdPrefix, "tab-").concat(VIEW_MODE_PARSED.id), label: t(VIEW_MODE_PARSED.title), onClick: setParsedViewMode, selected: viewMode === VIEW_MODE_PARSED }), (0, import_jsx_runtime.jsx)(Tab, { "aria-controls": "".concat(dialogIdPrefix, "tabpanel"), id: "".concat(dialogIdPrefix, "tab-").concat(VIEW_MODE_RAW.id), label: t(VIEW_MODE_RAW.title), onClick: setRawViewMode, selected: viewMode === VIEW_MODE_RAW })] }) }), (0, import_jsx_runtime.jsxs)(TabPanel, { "aria-labelledby": "".concat(dialogIdPrefix, "tab-").concat(viewModeId), flex: 1, id: "".concat(dialogIdPrefix, "tabpanel"), overflow: "auto", padding: 4, style: { outline: "none" }, children: [viewMode === VIEW_MODE_PARSED && (0, import_jsx_runtime.jsx)(JSONInspectorWrapper, { children: (0, import_jsx_runtime.jsx)(import_react_json_inspector.default, { data: value, isExpanded, onClick: toggleExpanded, search: Search }) }), viewMode === VIEW_MODE_RAW && (0, import_jsx_runtime.jsx)(Code, { language: "json", tabIndex: 0, onKeyDown: maybeSelectAll, onDoubleClick: select, onFocus: select, size: 1, children: JSON.stringify(value, null, 2) })] })] }) });
}
function SpacerButton(_ref73) {
  let { size } = _ref73;
  return (0, import_jsx_runtime.jsx)(Button2, { "aria-hidden": true, disabled: true, size, style: { pointerEvents: "none", visibility: "hidden", width: 0 }, text: "-" });
}
function Banner(props) {
  const { action, content, icon: Icon6, tone = "transparent", ...rest } = props;
  return (0, import_jsx_runtime.jsx)(Card, { borderBottom: true, paddingX: 4, paddingY: 2, tone, ...rest, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [Icon6 && (0, import_jsx_runtime.jsx)(Text, { size: 0, children: (0, import_jsx_runtime.jsx)(Icon6, {}) }), (0, import_jsx_runtime.jsx)(Flex, { align: "center", flex: 1, gap: 2, paddingY: 3, children: content }), (0, import_jsx_runtime.jsx)(SpacerButton, {}), action && (0, import_jsx_runtime.jsx)(Button2, { as: action == null ? void 0 : action.as, mode: "ghost", onClick: action == null ? void 0 : action.onClick, text: action.text, tone: action.tone || "default" })] }) });
}
function DeletedDocumentBanner(_ref74) {
  let { revisionId } = _ref74;
  const { documentId, documentType } = useDocumentPane();
  const { restore } = useDocumentOperation(documentId, documentType);
  const { navigateIntent } = useRouter();
  const handleRestore = (0, import_react2.useCallback)(() => {
    if (revisionId) {
      restore.execute(revisionId);
      navigateIntent("edit", { id: documentId, type: documentType });
    }
  }, [documentId, documentType, navigateIntent, restore, revisionId]);
  const { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(Banner, { action: revisionId ? { onClick: handleRestore, text: t("banners.deleted-document-banner.restore-button.text") } : void 0, content: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: t("banners.deleted-document-banner.text") }), "data-testid": "deleted-document-banner", icon: ReadOnlyIcon });
}
function DeprecatedDocumentTypeBanner() {
  const { schemaType } = useDocumentPane();
  const { t } = useTranslation2(structureLocaleNamespace);
  if (!isDeprecatedSchemaType(schemaType)) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)(Banner, { content: (0, import_jsx_runtime.jsxs)(Text, { size: 1, weight: "medium", children: [(0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "banners.deprecated-document-type-banner.text" }), " ", schemaType.deprecated.reason] }), "data-testid": "deprecated-document-type-banner", icon: ErrorOutlineIcon });
}
function PermissionCheckBanner(_ref75) {
  let { granted, requiredPermission } = _ref75;
  const currentUser = useCurrentUser();
  const listFormat = useListFormat({ style: "short" });
  const { t } = useTranslation2(structureLocaleNamespace);
  if (granted)
    return null;
  const roleTitles = ((currentUser == null ? void 0 : currentUser.roles) || []).map((role) => role.title);
  const roles = listFormat.formatToParts(roleTitles).map((part) => part.type === "element" ? (0, import_jsx_runtime.jsx)("code", { children: part.value }, part.value) : part.value);
  return (0, import_jsx_runtime.jsx)(Banner, { content: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "banners.permission-check-banner.missing-permission", components: { Roles: () => (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: roles }) }, values: { count: roles.length, roles: roleTitles }, context: requiredPermission }) }), "data-testid": "permission-check-banner", icon: ReadOnlyIcon });
}
var ReferenceChangedBanner = (0, import_react2.memo)(() => {
  var _a2, _b2, _c2, _d2, _e2, _f2, _g2;
  const documentPreviewStore = useDocumentPreviewStore();
  const { params, groupIndex, routerPanesState, replaceCurrent, BackLink: BackLink3 } = usePaneRouter();
  const routerReferenceId = (_a2 = routerPanesState[groupIndex]) == null ? void 0 : _a2[0].id;
  const parentGroup = routerPanesState[groupIndex - 1];
  const parentSibling = parentGroup == null ? void 0 : parentGroup[0];
  const parentId = parentSibling == null ? void 0 : parentSibling.id;
  const hasHistoryOpen = Boolean((_b2 = parentSibling == null ? void 0 : parentSibling.params) == null ? void 0 : _b2.rev);
  const parentRefPath = (0, import_react2.useMemo)(() => {
    return (params == null ? void 0 : params.parentRefPath) && fromString(params.parentRefPath) || null;
  }, [params == null ? void 0 : params.parentRefPath]);
  const { t } = useTranslation2(structureLocaleNamespace);
  const referenceInfo = useMemoObservable(() => {
    const parentRefPathSegment = parentRefPath == null ? void 0 : parentRefPath[0];
    if (!parentId || !parentRefPathSegment || !parentRefPath) {
      return of({ loading: false });
    }
    const publishedId = getPublishedId(parentId);
    const path = fromString(parentRefPathSegment);
    const keyedSegmentIndex = path.findIndex((p) => typeof p == "object" && "_key" in p);
    return concat(
      // emit a loading state instantly
      of({ loading: true }),
      // then emit the values from watching the published ID's path
      documentPreviewStore.unstable_observePathsDocumentPair(publishedId, keyedSegmentIndex === -1 ? path : path.slice(0, keyedSegmentIndex)).pipe(
        // this debounce time is needed to prevent flashing banners due to
        // the router state updating faster than the content-lake state. we
        // debounce to wait for more emissions because the value pulled
        // initially could be stale.
        debounceTime(750),
        map((_ref76) => {
          let { draft, published } = _ref76;
          var _a22;
          return { loading: false, result: { availability: { draft: draft.availability, published: published.availability }, refValue: (_a22 = get(draft.snapshot || published.snapshot, parentRefPath)) == null ? void 0 : _a22._ref } };
        })
      )
    );
  }, [documentPreviewStore, parentId, parentRefPath], { loading: true });
  const handleReloadReference = (0, import_react2.useCallback)(() => {
    var _a22;
    if (referenceInfo.loading)
      return;
    if ((_a22 = referenceInfo.result) == null ? void 0 : _a22.refValue) {
      replaceCurrent({ id: referenceInfo.result.refValue, params });
    }
  }, [referenceInfo.loading, referenceInfo.result, replaceCurrent, params]);
  const shouldHide = (
    // if `parentId` or `parentRefPath` is not present then this banner is n/a
    !parentId || !parentRefPath || // if viewing this pane via history, then hide
    hasHistoryOpen || // if loading, hide
    referenceInfo.loading || // if the parent document is not available (e.g. due to permission denied or
    // not found) we don't want to display a warning here, but instead rely on the
    // parent view to display the appropriate message
    !((_c2 = referenceInfo.result) == null ? void 0 : _c2.availability.draft.available) && !((_d2 = referenceInfo.result) == null ? void 0 : _d2.availability.published.available) || // if the references are the same, then hide the reference changed banner
    ((_e2 = referenceInfo.result) == null ? void 0 : _e2.refValue) === routerReferenceId
  );
  if (shouldHide)
    return null;
  return (0, import_jsx_runtime.jsx)(Banner, { action: ((_f2 = referenceInfo.result) == null ? void 0 : _f2.refValue) ? { onClick: handleReloadReference, icon: SyncIcon, text: t("banners.reference-changed-banner.reason-changed.reload-button.text") } : { as: BackLink3, icon: CloseIcon, text: t("banners.reference-changed-banner.reason-removed.close-button.text") }, "data-testid": "reference-changed-banner", content: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: ((_g2 = referenceInfo.result) == null ? void 0 : _g2.refValue) ? t("banners.reference-changed-banner.reason-changed.text") : t("banners.reference-changed-banner.reason-removed.text") }), icon: WarningOutlineIcon, tone: "caution" });
});
ReferenceChangedBanner.displayName = "ReferenceChangedBanner";
var __freeze$r = Object.freeze;
var __defProp$r = Object.defineProperty;
var __template$r = (cooked, raw) => __freeze$r(__defProp$r(cooked, "raw", { value: __freeze$r(raw || cooked.slice()) }));
var _a$r;
var _b$c;
var TitleContainer = ut(Stack)(_b$c || (_b$c = __template$r(["\n  ", "\n"])), (_ref77) => {
  let { theme } = _ref77;
  return at(_a$r || (_a$r = __template$r(["\n      @supports not (container-type: inline-size) {\n        display: none !important;\n      }\n\n      container-type: inline-size;\n\n      [data-heading] {\n        font-size: ", "px;\n        line-height: ", "px;\n        overflow-wrap: break-word;\n        text-wrap: pretty;\n      }\n\n      @container (max-width: 560px) {\n        [data-heading] {\n          font-size: ", "px;\n          line-height: ", "px;\n        }\n      }\n\n      @container (max-width: 420px) {\n        [data-heading] {\n          font-size: ", "px;\n          line-height: ", "px;\n        }\n      }\n    "])), theme.sanity.fonts.heading.sizes[4].fontSize, theme.sanity.fonts.heading.sizes[4].lineHeight, theme.sanity.fonts.heading.sizes[3].fontSize, theme.sanity.fonts.heading.sizes[3].lineHeight, theme.sanity.fonts.heading.sizes[2].fontSize, theme.sanity.fonts.heading.sizes[2].lineHeight);
});
var FormHeader = (_ref78) => {
  let { documentId, schemaType, title } = _ref78;
  var _a2;
  const isSingleton = documentId === schemaType.name;
  const { t } = useTranslation(structureLocaleNamespace);
  if (schemaType.__experimental_formPreviewTitle === false) {
    return null;
  }
  return (0, import_jsx_runtime.jsxs)(TitleContainer, { marginBottom: 6, space: 4, children: [!isSingleton && (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: (_a2 = schemaType.title) != null ? _a2 : schemaType.name }), (0, import_jsx_runtime.jsx)(Heading, { as: "h2", "data-heading": true, muted: !title, children: title != null ? title : t("document-view.form-view.form-title-fallback") })] });
};
function usePrevious(value) {
  const ref = (0, import_react2.useRef)();
  (0, import_react2.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
var LONG_ENOUGH_BUT_NOT_TOO_LONG = 1e3 * 60 * 60 * 24 * 24;
function useConditionalToast(params) {
  const toast = useToast();
  const wasEnabled = usePrevious(params.enabled);
  (0, import_react2.useEffect)(() => {
    if (!wasEnabled && params.enabled) {
      toast.push({ ...params, duration: LONG_ENOUGH_BUT_NOT_TOO_LONG });
    }
    if (wasEnabled && !params.enabled) {
      toast.push({
        ...params,
        // Note: @sanity/ui fallbacks to the default duration of 4s in case of falsey values
        duration: 0.01
      });
    }
  }, [params, toast, wasEnabled]);
}
var preventDefault = (ev) => ev.preventDefault();
var FormView = (0, import_react2.forwardRef)(function FormView2(props, ref) {
  var _a2;
  const { hidden, margins } = props;
  const { collapsedFieldSets, collapsedPaths, displayed: value, editState, documentId, documentType, fieldActions, onChange, validation, ready, formState, onFocus, connectionState, onBlur, onSetCollapsedPath, onPathOpen, onSetCollapsedFieldSet, onSetActiveFieldGroup } = useDocumentPane();
  const documentStore = useDocumentStore();
  const presence = useDocumentPresence(documentId);
  const { title } = useDocumentTitle();
  const patchChannel = (0, import_react2.useMemo)(() => createPatchChannel(), []);
  const isLocked = (_a2 = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a2.enabled;
  const { t } = useTranslation2(structureLocaleNamespace);
  useConditionalToast({ id: "sync-lock-".concat(documentId), status: "warning", enabled: isLocked, title: t("document-view.form-view.sync-lock-toast.title"), description: t("document-view.form-view.sync-lock-toast.description") });
  (0, import_react2.useEffect)(() => {
    const sub = documentStore.pair.documentEvents(documentId, documentType).pipe(tap((event) => {
      if (event.type === "mutation") {
        patchChannel.publish(prepareMutationEvent(event));
      }
      if (event.type === "rebase") {
        patchChannel.publish(prepareRebaseEvent(event));
      }
    })).subscribe();
    return () => {
      sub.unsubscribe();
    };
  }, [documentId, documentStore, documentType, patchChannel]);
  const hasRev = Boolean(value == null ? void 0 : value._rev);
  (0, import_react2.useEffect)(() => {
    if (hasRev) {
      patchChannel.publish({ type: "mutation", patches: [], snapshot: value });
    }
  }, [hasRev]);
  const [formRef, setFormRef] = (0, import_react2.useState)(null);
  (0, import_react2.useEffect)(() => {
    if (ready && !(formState == null ? void 0 : formState.focusPath.length) && formRef) {
      focusFirstDescendant(formRef);
    }
  }, [ready]);
  const setRef = (0, import_react2.useCallback)((node) => {
    setFormRef(node);
    if (typeof ref === "function") {
      ref(node);
    } else if (ref) {
      ref.current = node;
    }
  }, [ref]);
  return (0, import_jsx_runtime.jsx)(Container, { hidden, paddingX: 4, paddingTop: 5, paddingBottom: 9, sizing: "border", width: 1, children: (0, import_jsx_runtime.jsx)(PresenceOverlay, { margins, children: (0, import_jsx_runtime.jsx)(Box, { as: "form", onSubmit: preventDefault, ref: setRef, children: connectionState === "connecting" ? (0, import_jsx_runtime.jsx)(Delay, { ms: 300, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: [(0, import_jsx_runtime.jsx)(Spinner, { muted: true }), (0, import_jsx_runtime.jsx)(Box, { marginTop: 3, children: (0, import_jsx_runtime.jsx)(Text, { align: "center", muted: true, size: 1, children: t("document-view.form-view.loading") }) })] }) }) : formState === null || hidden ? (0, import_jsx_runtime.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime.jsx)(Text, { children: t("document-view.form-view.form-hidden") }) }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(FormHeader, { documentId, schemaType: formState.schemaType, title }), (0, import_jsx_runtime.jsx)(FormBuilder, { __internal_fieldActions: fieldActions, __internal_patchChannel: patchChannel, collapsedFieldSets, collapsedPaths, focusPath: formState.focusPath, changed: formState.changed, focused: formState.focused, groups: formState.groups, id: "root", members: formState.members, onChange, onFieldGroupSelect: onSetActiveFieldGroup, onPathBlur: onBlur, onPathFocus: onFocus, onPathOpen, onSetFieldSetCollapsed: onSetCollapsedFieldSet, onSetPathCollapsed: onSetCollapsedPath, presence, readOnly: connectionState === "reconnecting" || formState.readOnly, schemaType: formState.schemaType, validation, value: (
    // note: the form state doesn't have a typed concept of a "document" value
    // but these should be compatible
    formState.value
  ) })] }) }) }) });
});
function prepareMutationEvent(event) {
  const patches = event.mutations.map((mut) => mut.patch).filter(Boolean);
  return { type: "mutation", snapshot: event.document, patches: fromMutationPatches(event.origin, patches) };
}
function prepareRebaseEvent(event) {
  const remotePatches = event.remoteMutations.map((mut) => mut.patch).filter(Boolean);
  const localPatches = event.localMutations.map((mut) => mut.patch).filter(Boolean);
  return { type: "rebase", snapshot: event.document, patches: fromMutationPatches("remote", remotePatches).concat(fromMutationPatches("local", localPatches)) };
}
var __freeze$q = Object.freeze;
var __defProp$q = Object.defineProperty;
var __template$q = (cooked, raw) => __freeze$q(__defProp$q(cooked, "raw", { value: __freeze$q(raw || cooked.slice()) }));
var _a$q;
var DocumentBox = ut(Box)({ position: "relative" });
var Scroller$1 = ut(ScrollContainer)((_ref79) => {
  let { $disabled } = _ref79;
  if ($disabled) {
    return { height: "100%" };
  }
  return at(_a$q || (_a$q = __template$q(["\n    height: 100%;\n    overflow: auto;\n    position: relative;\n    scroll-behavior: smooth;\n    outline: none;\n  "])));
});
var DocumentPanel = function DocumentPanel2(props) {
  const { footerHeight, headerHeight, isInspectOpen, rootElement, setDocumentPanelPortalElement } = props;
  const { activeViewId, displayed, documentId, editState, inspector, value, views: views2, ready, schemaType, permissions, isPermissionsLoading, isDeleting, isDeleted, timelineStore } = useDocumentPane();
  const { collapsed: layoutCollapsed } = usePaneLayout();
  const { collapsed } = usePane();
  const parentPortal = usePortal();
  const { features } = useStructureTool();
  const portalRef = (0, import_react2.useRef)(null);
  const [documentScrollElement, setDocumentScrollElement] = (0, import_react2.useState)(null);
  const formContainerElement = (0, import_react2.useRef)(null);
  const requiredPermission = value._createdAt ? "update" : "create";
  const activeView = (0, import_react2.useMemo)(() => views2.find((view) => view.id === activeViewId) || views2[0] || { type: "form" }, [activeViewId, views2]);
  const portalElement = features.splitPanes ? portalRef.current || parentPortal.element : parentPortal.element;
  const margins = (0, import_react2.useMemo)(() => {
    if (layoutCollapsed) {
      return [headerHeight || 0, 0, footerHeight ? footerHeight + 2 : 2, 0];
    }
    return [0, 0, 2, 0];
  }, [layoutCollapsed, footerHeight, headerHeight]);
  const formViewHidden = activeView.type !== "form";
  const activeViewNode = (0, import_react2.useMemo)(() => activeView.type === "component" && activeView.component && (0, import_react2.createElement)(activeView.component, { document: { draft: (editState == null ? void 0 : editState.draft) || null, displayed: displayed || value, historical: displayed, published: (editState == null ? void 0 : editState.published) || null }, documentId, options: activeView.options, schemaType }), [activeView, displayed, documentId, editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, schemaType, value]);
  const lastNonDeletedRevId = useTimelineSelector(timelineStore, (state2) => state2.lastNonDeletedRevId);
  (0, import_react2.useEffect)(() => {
    if (!(documentScrollElement == null ? void 0 : documentScrollElement.scrollTo))
      return;
    documentScrollElement.scrollTo(0, 0);
  }, [documentId, documentScrollElement]);
  (0, import_react2.useEffect)(() => {
    if (portalElement) {
      setDocumentPanelPortalElement(portalElement);
    }
  }, [portalElement, setDocumentPanelPortalElement]);
  const inspectDialog = (0, import_react2.useMemo)(() => {
    return isInspectOpen ? (0, import_jsx_runtime.jsx)(InspectDialog, { value: displayed || value }) : null;
  }, [isInspectOpen, displayed, value]);
  const showInspector = Boolean(!collapsed && inspector);
  return (0, import_jsx_runtime.jsx)(PaneContent, { children: (0, import_jsx_runtime.jsxs)(Flex, { height: "fill", children: [(features.resizablePanes || !showInspector) && (0, import_jsx_runtime.jsx)(DocumentBox, { flex: 2, overflow: "hidden", children: (0, import_jsx_runtime.jsx)(PortalProvider, { element: portalElement, __unstable_elements: { documentScrollElement }, children: (0, import_jsx_runtime.jsx)(BoundaryElementProvider, { element: documentScrollElement, children: (0, import_jsx_runtime.jsxs)(VirtualizerScrollInstanceProvider, { scrollElement: documentScrollElement, containerElement: formContainerElement, children: [activeView.type === "form" && !isPermissionsLoading && ready && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(PermissionCheckBanner, { granted: Boolean(permissions == null ? void 0 : permissions.granted), requiredPermission }), !isDeleting && isDeleted && (0, import_jsx_runtime.jsx)(DeletedDocumentBanner, { revisionId: lastNonDeletedRevId }), (0, import_jsx_runtime.jsx)(ReferenceChangedBanner, {}), (0, import_jsx_runtime.jsx)(DeprecatedDocumentTypeBanner, {})] }), (0, import_jsx_runtime.jsxs)(Scroller$1, { $disabled: layoutCollapsed || false, "data-testid": "document-panel-scroller", ref: setDocumentScrollElement, children: [(0, import_jsx_runtime.jsx)(FormView, { hidden: formViewHidden, margins, ref: formContainerElement }, documentId + (ready ? "_ready" : "_pending")), activeViewNode] }), inspectDialog, (0, import_jsx_runtime.jsx)("div", { "data-testid": "document-panel-portal", ref: portalRef })] }) }) }) }), showInspector && (0, import_jsx_runtime.jsx)(BoundaryElementProvider, { element: rootElement, children: (0, import_jsx_runtime.jsx)(DocumentInspectorPanel, { documentId, documentType: schemaType.name, flex: 1 }) })] }) });
};
var POPOVER_FALLBACK_PLACEMENTS = ["left", "bottom"];
var DIALOG_WIDTH_TO_UI_WIDTH = { small: 0, medium: 1, large: 2, full: "auto" };
function ConfirmDialog(props) {
  const { dialog, referenceElement } = props;
  return (0, import_jsx_runtime.jsx)(Popover, { content: (0, import_jsx_runtime.jsx)(ConfirmDialogContent, { dialog }), fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS, open: true, placement: "top", portal: true, preventOverflow: true, referenceElement });
}
function ConfirmDialogContent(props) {
  const { dialog } = props;
  const {
    cancelButtonIcon,
    cancelButtonText,
    confirmButtonIcon,
    confirmButtonText,
    // color,
    message,
    onCancel,
    onConfirm,
    tone
  } = dialog;
  const { t } = useTranslation2(structureLocaleNamespace);
  const { isTopLayer } = useLayer();
  const [element, setElement] = (0, import_react2.useState)(null);
  const handleClickOutside = (0, import_react2.useCallback)(() => {
    if (isTopLayer)
      onCancel();
  }, [isTopLayer, onCancel]);
  const handleGlobalKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "Escape" && isTopLayer)
      onCancel();
  }, [isTopLayer, onCancel]);
  useClickOutside(handleClickOutside, [element]);
  useGlobalKeyDown(handleGlobalKeyDown);
  return (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", ref: setElement, style: { minWidth: 320 - 16, maxWidth: 400 }, children: [(0, import_jsx_runtime.jsx)(Box, { flex: 1, overflow: "auto", padding: 4, children: (0, import_jsx_runtime.jsx)(Text, { children: message }) }), (0, import_jsx_runtime.jsx)(Box, { paddingX: 4, paddingY: 3, style: { borderTop: "1px solid var(--card-border-color)" }, children: (0, import_jsx_runtime.jsxs)(Grid, { columns: 2, gap: 2, children: [(0, import_jsx_runtime.jsx)(Button, { icon: cancelButtonIcon, onClick: onCancel, mode: "ghost", text: cancelButtonText || t("confirm-dialog.cancel-button.fallback-text") }), (0, import_jsx_runtime.jsx)(Button, { icon: confirmButtonIcon, onClick: onConfirm, text: confirmButtonText || t("confirm-dialog.confirm-button.fallback-text"), tone })] }) })] });
}
function ModalDialog(props) {
  const { dialog } = props;
  const dialogId = (0, import_react2.useId)();
  const footer = dialog.footer && (0, import_jsx_runtime.jsx)(Box, { paddingX: 4, paddingY: 3, children: dialog.footer });
  return (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "fullscreen", children: (0, import_jsx_runtime.jsx)(Dialog, { __unstable_hideCloseButton: dialog.showCloseButton === false, footer, header: dialog.header, id: dialogId, onClose: dialog.onClose, onClickOutside: dialog.onClose, width: dialog.width === void 0 ? 1 : DIALOG_WIDTH_TO_UI_WIDTH[dialog.width], children: (0, import_jsx_runtime.jsx)(Box, { padding: 4, children: dialog.content }) }) });
}
function PopoverDialog(props) {
  const { dialog, referenceElement } = props;
  return (0, import_jsx_runtime.jsx)(Popover, { content: (0, import_jsx_runtime.jsx)(PopoverDialogContent, { dialog }), fallbackPlacements: POPOVER_FALLBACK_PLACEMENTS, open: true, placement: "top", portal: true, preventOverflow: true, referenceElement });
}
function PopoverDialogContent(props) {
  const { dialog } = props;
  const { content, onClose } = dialog;
  const { isTopLayer } = useLayer();
  const [element, setElement] = (0, import_react2.useState)(null);
  const handleClickOutside = (0, import_react2.useCallback)(() => {
    if (isTopLayer)
      onClose();
  }, [isTopLayer, onClose]);
  const handleGlobalKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "Escape" && isTopLayer)
      onClose();
  }, [isTopLayer, onClose]);
  useClickOutside(handleClickOutside, [element]);
  useGlobalKeyDown(handleGlobalKeyDown);
  return (0, import_jsx_runtime.jsx)("div", { ref: setElement, children: content });
}
function DocumentActionPortalProvider(props) {
  const { children } = props;
  const { element, elements } = usePortal();
  const portalElement = (elements == null ? void 0 : elements[DOCUMENT_PANEL_PORTAL_ELEMENT]) || element;
  return (0, import_jsx_runtime.jsx)(PortalProvider, { element: portalElement, children });
}
function ActionStateDialog(props) {
  const { dialog, referenceElement = null } = props;
  const modalId = (0, import_react2.useId)();
  if (dialog.type === "confirm") {
    return (0, import_jsx_runtime.jsx)(ConfirmDialog, { dialog, referenceElement });
  }
  if (dialog.type === "popover") {
    return (0, import_jsx_runtime.jsx)(PopoverDialog, { dialog, referenceElement });
  }
  if (dialog.type === "dialog" || !dialog.type) {
    return (0, import_jsx_runtime.jsx)(DocumentActionPortalProvider, { children: (0, import_jsx_runtime.jsx)(ModalDialog, { dialog }) });
  }
  if (dialog.type === "custom") {
    return (0, import_jsx_runtime.jsx)(DocumentActionPortalProvider, { children: dialog == null ? void 0 : dialog.component });
  }
  const unknownModal = dialog;
  console.warn("Unsupported modal type ".concat(unknownModal.type));
  return (0, import_jsx_runtime.jsx)(Dialog2, { id: modalId, onClose: unknownModal.onClose, onClickOutside: unknownModal.onClose, width: 1, children: unknownModal.content || // eslint-disable-next-line i18next/no-literal-string
  (0, import_jsx_runtime.jsxs)(Text, { size: 1, children: ["Unexpected modal type (", (0, import_jsx_runtime.jsx)("code", { children: unknownModal.type }), ")"] }) });
}
function ActionDialogWrapper(_ref80) {
  let { actionStates, children, referenceElement } = _ref80;
  const [actionIndex, setActionIndex] = (0, import_react2.useState)(-1);
  const currentAction = actionStates[actionIndex];
  const handleAction = (0, import_react2.useCallback)((idx) => {
    setActionIndex(idx);
  }, []);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [currentAction && currentAction.dialog && (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "paneFooter", children: (0, import_jsx_runtime.jsx)(ActionStateDialog, { dialog: currentAction.dialog, referenceElement }) }), children({ handleAction })] });
}
function ActionMenuButton(props) {
  const { actionStates, disabled } = props;
  const idPrefix = (0, import_react2.useId)();
  const [referenceElement, setReferenceElement] = (0, import_react2.useState)(null);
  const popoverProps = (0, import_react2.useMemo)(() => ({ placement: "top-end", portal: true, preventOverflow: true }), []);
  const { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(ActionDialogWrapper, { actionStates, referenceElement, children: (_ref81) => {
    let { handleAction } = _ref81;
    return (0, import_jsx_runtime.jsx)(MenuButton, { id: "".concat(idPrefix, "-action-menu"), button: (0, import_jsx_runtime.jsx)(ContextMenuButton, { "aria-label": t("buttons.action-menu-button.aria-label"), disabled, "data-testid": "action-menu-button", size: "large", tooltipProps: { content: t("buttons.action-menu-button.tooltip") } }), menu: (0, import_jsx_runtime.jsx)(Menu, { padding: 1, children: actionStates.map((actionState, idx) => (0, import_jsx_runtime.jsx)(ActionMenuListItem, { actionState, disabled, index: idx, onAction: handleAction }, idx)) }), popover: popoverProps, ref: setReferenceElement });
  } });
}
function ActionMenuListItem(props) {
  const { actionState, disabled, index, onAction } = props;
  const { onHandle } = actionState;
  const handleClick = (0, import_react2.useCallback)(() => {
    onAction(index);
    if (onHandle)
      onHandle();
  }, [index, onAction, onHandle]);
  const hotkeys = (0, import_react2.useMemo)(() => {
    return actionState.shortcut ? String(actionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1)) : void 0;
  }, [actionState.shortcut]);
  return (0, import_jsx_runtime.jsx)(MenuItem2, { "data-testid": "action-".concat(actionState.label.replace(" ", "")), disabled: disabled || Boolean(actionState.disabled), hotkeys, icon: actionState.icon, onClick: handleClick, text: actionState.label, tone: actionState.tone, ...actionState.disabled && { tooltipProps: { content: actionState.title } } });
}
var TIMELINE_ICON_COMPONENTS = { create: AddCircleIcon, delete: TrashIcon, discardDraft: CloseIcon, initial: AddCircleIcon, editDraft: EditIcon, editLive: EditIcon, publish: PublishIcon, unpublish: UnpublishIcon };
function getTimelineEventIconComponent(type) {
  return TIMELINE_ICON_COMPONENTS[type];
}
var __freeze$p = Object.freeze;
var __defProp$p = Object.defineProperty;
var __template$p = (cooked, raw) => __freeze$p(__defProp$p(cooked, "raw", { value: __freeze$p(raw || cooked.slice()) }));
var _a$p;
var _b$b;
var _c$5;
var _d$1;
var StackWrapper = ut(Stack)(_a$p || (_a$p = __template$p(["\n  max-width: 200px;\n"])));
var ListWrapper = ut(Flex)(_b$b || (_b$b = __template$p(["\n  max-height: calc(100vh - 198px);\n  min-width: 244px;\n"])));
var Root$3 = ut(Box)((_ref82) => {
  let { $visible } = _ref82;
  return at(_d$1 || (_d$1 = __template$p(["\n    opacity: 0;\n    pointer-events: none;\n\n    ", "\n  "])), $visible && at(_c$5 || (_c$5 = __template$p(["\n      opacity: 1;\n      pointer-events: auto;\n    "]))));
});
var TIMELINE_ITEM_I18N_KEY_MAPPING = { initial: "timeline.operation.created-initial", create: "timeline.operation.created", publish: "timeline.operation.published", editLive: "timeline.operation.edited-live", editDraft: "timeline.operation.edited-draft", unpublish: "timeline.operation.unpublished", discardDraft: "timeline.operation.draft-discarded", delete: "timeline.operation.deleted" };
var __freeze$o = Object.freeze;
var __defProp$o = Object.defineProperty;
var __template$o = (cooked, raw) => __freeze$o(__defProp$o(cooked, "raw", { value: __freeze$o(raw || cooked.slice()) }));
var _a$o;
var _b$a;
var _c$4;
var _d;
var _e;
var _f;
var IconWrapper = ut(Flex)((_ref83) => {
  let { theme } = _ref83;
  var _a2;
  const borderColor = (_a2 = theme.sanity.color.base.skeleton) == null ? void 0 : _a2.from;
  return at(_a$o || (_a$o = __template$o(["\n    --timeline-hairline-width: 1px;\n    position: relative;\n    z-index: 2;\n    margin: 0;\n    padding: 0;\n\n    &::before {\n      position: absolute;\n      content: '';\n      height: 100%;\n      width: var(--timeline-hairline-width);\n      background: ", ";\n      top: 0;\n      left: calc((100% - var(--timeline-hairline-width)) / 2);\n      z-index: 1;\n    }\n  "])), borderColor);
});
var Root$2 = ut(Button)((_ref84) => {
  let { $selected, $disabled } = _ref84;
  return at(_d || (_d = __template$o(["\n    position: relative;\n    width: 100%;\n\n    /* Line styling */\n    &[data-first] ", "::before {\n      height: 50%;\n      top: unset;\n      bottom: 0;\n    }\n\n    &[data-last] ", "::before {\n      height: 50%;\n    }\n\n    ", "\n\n    ", "\n  "])), IconWrapper, IconWrapper, $selected && at(_b$a || (_b$a = __template$o(["\n      ", "::before {\n        background: transparent;\n      }\n    "])), IconWrapper), $disabled && at(_c$4 || (_c$4 = __template$o(["\n      cursor: not-allowed;\n    "]))));
});
var IconBox = ut(Box)(_e || (_e = __template$o(["\n  background: var(--card-bg-color);\n  border-radius: 50px;\n  position: relative;\n  z-index: 2;\n"])));
var TimestampBox = ut(Box)(_f || (_f = __template$o(["\n  min-width: 1rem;\n  margin-left: ", ";\n"])), (_ref85) => {
  let { theme } = _ref85;
  return "-".concat(rem(theme.sanity.space[1]));
});
function UserAvatarStack(_ref86) {
  let { maxLength, userIds } = _ref86;
  return (0, import_jsx_runtime.jsx)(AvatarStack, { maxLength, children: userIds.map((userId) => (0, import_jsx_runtime.jsx)(UserAvatar, { user: userId, withTooltip: true }, userId)) });
}
var TIMELINE_ITEM_EVENT_TONE = { initial: "primary", create: "primary", publish: "positive", editLive: "caution", editDraft: "caution", unpublish: "critical", discardDraft: "critical", delete: "critical", withinSelection: "primary" };
function TimelineItem(_ref87) {
  let { chunk, isFirst, isLast, isLatest, isSelected, onSelect, timestamp, type } = _ref87;
  const { t } = useTranslation2("studio");
  const iconComponent = getTimelineEventIconComponent(type);
  const authorUserIds = Array.from(chunk.authors);
  const isSelectable = type !== "delete";
  const dateFormat = useDateTimeFormat({ dateStyle: "medium", timeStyle: "short" });
  const formattedTimestamp = (0, import_react2.useMemo)(() => {
    const parsedDate = new Date(timestamp);
    const formattedDate = dateFormat.format(parsedDate);
    return formattedDate;
  }, [timestamp, dateFormat]);
  const handleClick = (0, import_react2.useCallback)((evt) => {
    evt.preventDefault();
    evt.stopPropagation();
    if (isSelectable) {
      onSelect(chunk);
    }
  }, [onSelect, chunk, isSelectable]);
  return (0, import_jsx_runtime.jsx)(Root$2, { $selected: isSelected, $disabled: !isSelectable, "data-chunk-id": chunk.id, "data-first": isFirst ? true : void 0, "data-last": isLast ? true : void 0, "data-ui": "timelineItem", mode: isSelected ? "default" : "bleed", onClick: handleClick, padding: 0, radius: 2, tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type], children: (0, import_jsx_runtime.jsx)(Box, { paddingX: 2, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "stretch", children: [(0, import_jsx_runtime.jsx)(IconWrapper, { align: "center", children: (0, import_jsx_runtime.jsx)(IconBox, { padding: 2, children: (0, import_jsx_runtime.jsx)(Text, { size: 2, children: iconComponent && (0, import_react2.createElement)(iconComponent) }) }) }), (0, import_jsx_runtime.jsxs)(Stack, { space: 2, margin: 2, children: [isLatest && (0, import_jsx_runtime.jsx)(Flex, { children: (0, import_jsx_runtime.jsx)(Card, { padding: 1, radius: 2, shadow: 1, tone: isSelected ? "primary" : TIMELINE_ITEM_EVENT_TONE[chunk.type], children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 0, weight: "medium", children: t("timeline.latest") }) }) }), (0, import_jsx_runtime.jsx)(Box, { children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: t(TIMELINE_ITEM_I18N_KEY_MAPPING[type]) || (0, import_jsx_runtime.jsx)("code", { children: type }) }) }), (0, import_jsx_runtime.jsx)(TimestampBox, { paddingX: 1, children: (0, import_jsx_runtime.jsx)(Text, { as: "time", size: 0, muted: true, dateTime: timestamp, children: formattedTimestamp }) })] }), (0, import_jsx_runtime.jsx)(Flex, { flex: 1, justify: "flex-end", align: "center", children: (0, import_jsx_runtime.jsx)(UserAvatarStack, { maxLength: 3, userIds: authorUserIds }) })] }) }) });
}
var Timeline = (_ref88) => {
  let { chunks, disabledBeforeFirstChunk, hasMoreChunks, lastChunk, onLoadMore, onSelect, firstChunk } = _ref88;
  const [mounted, setMounted] = (0, import_react2.useState)(false);
  const { t } = useTranslation2("studio");
  const filteredChunks = (0, import_react2.useMemo)(() => {
    return chunks.filter((c) => {
      if (disabledBeforeFirstChunk && firstChunk) {
        return c.index < firstChunk.index;
      }
      return true;
    });
  }, [chunks, disabledBeforeFirstChunk, firstChunk]);
  const selectedIndex = (0, import_react2.useMemo)(() => (lastChunk == null ? void 0 : lastChunk.id) ? filteredChunks.findIndex((c) => c.id === lastChunk.id) : -1, [lastChunk == null ? void 0 : lastChunk.id, filteredChunks]);
  const renderItem2 = (0, import_react2.useCallback)((chunk, _ref89) => {
    let { activeIndex } = _ref89;
    const isFirst = activeIndex === 0;
    const isLast = filteredChunks && activeIndex === filteredChunks.length - 1 || false;
    return (0, import_jsx_runtime.jsxs)(Box, { paddingBottom: isLast ? 1 : 0, paddingTop: isFirst ? 1 : 0, paddingX: 1, children: [(0, import_jsx_runtime.jsx)(TimelineItem, { chunk, isFirst, isLast, isLatest: activeIndex === 0 && !disabledBeforeFirstChunk, isSelected: activeIndex === selectedIndex, onSelect, timestamp: chunk.endTimestamp, type: chunk.type }), activeIndex === filteredChunks.length - 1 && hasMoreChunks && (0, import_jsx_runtime.jsx)(LoadingBlock, {})] });
  }, [disabledBeforeFirstChunk, filteredChunks, hasMoreChunks, onSelect, selectedIndex]);
  (0, import_react2.useEffect)(() => setMounted(true), []);
  return (0, import_jsx_runtime.jsxs)(Root$3, { $visible: !selectedIndex || mounted, "data-ui": "timeline", children: [filteredChunks.length === 0 && (0, import_jsx_runtime.jsxs)(StackWrapper, { padding: 3, space: 3, children: [(0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: t("timeline.error.no-document-history-title") }), (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: t("timeline.error.no-document-history-description") })] }), filteredChunks.length > 0 && (0, import_jsx_runtime.jsx)(ListWrapper, { direction: "column", children: (0, import_jsx_runtime.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: t("timeline.list.aria-label"), autoFocus: "list", initialIndex: selectedIndex, initialScrollAlign: "center", itemHeight: 40, items: filteredChunks, onEndReached: onLoadMore, onEndReachedIndexOffset: 20, overscan: 5, renderItem: renderItem2, wrapAround: false }) })] });
};
Timeline.displayName = "Timeline";
function TimelineError() {
  const { t } = useTranslation2("studio");
  return (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-start", gap: 3, padding: 4, children: [(0, import_jsx_runtime.jsx)(TextWithTone, { tone: "critical", children: (0, import_jsx_runtime.jsx)(ErrorOutlineIcon, {}) }), (0, import_jsx_runtime.jsxs)(Stack, { space: 4, children: [(0, import_jsx_runtime.jsx)(TextWithTone, { size: 1, tone: "critical", weight: "medium", children: t("timeline.error.load-document-changes-title") }), (0, import_jsx_runtime.jsx)(TextWithTone, { size: 1, tone: "critical", children: t("timeline.error.load-document-changes-description") })] })] });
}
var __freeze$n = Object.freeze;
var __defProp$n = Object.defineProperty;
var __template$n = (cooked, raw) => __freeze$n(__defProp$n(cooked, "raw", { value: __freeze$n(raw || cooked.slice()) }));
var _a$n;
var Root$1 = ut(Popover2)(_a$n || (_a$n = __template$n(["\n  overflow: hidden;\n  overflow: clip;\n"])));
function TimelineMenu(_ref90) {
  let { chunk, mode, placement } = _ref90;
  const { setTimelineRange, setTimelineMode, timelineError, ready, timelineStore } = useDocumentPane();
  const [open, setOpen] = (0, import_react2.useState)(false);
  const [button, setButton] = (0, import_react2.useState)(null);
  const [popover, setPopover] = (0, import_react2.useState)(null);
  const toast = useToast();
  const chunks = useTimelineSelector(timelineStore, (state2) => state2.chunks);
  const loading = useTimelineSelector(timelineStore, (state2) => state2.isLoading);
  const hasMoreChunks = useTimelineSelector(timelineStore, (state2) => state2.hasMoreChunks);
  const realRevChunk = useTimelineSelector(timelineStore, (state2) => state2.realRevChunk);
  const sinceTime = useTimelineSelector(timelineStore, (state2) => state2.sinceTime);
  const { t } = useTranslation2("studio");
  const handleOpen = (0, import_react2.useCallback)(() => {
    setTimelineMode(mode);
    setOpen(true);
  }, [mode, setTimelineMode]);
  const handleClose = (0, import_react2.useCallback)(() => {
    setTimelineMode("closed");
    setOpen(false);
  }, [setTimelineMode]);
  const handleClickOutside = (0, import_react2.useCallback)(() => {
    if (open) {
      handleClose();
    }
  }, [handleClose, open]);
  const handleGlobalKeyDown = (0, import_react2.useCallback)((event) => {
    if (open && (event.key === "Escape" || event.key === "Tab")) {
      handleClose();
      button == null ? void 0 : button.focus();
    }
  }, [button, handleClose, open]);
  useClickOutside(handleClickOutside, [button, popover]);
  useGlobalKeyDown(handleGlobalKeyDown);
  const selectRev = (0, import_react2.useCallback)((revChunk) => {
    try {
      const [sinceId, revId] = timelineStore.findRangeForRev(revChunk);
      setTimelineMode("closed");
      setTimelineRange(sinceId, revId);
    } catch (err) {
      toast.push({ closable: true, description: err.message, status: "error", title: t("timeline.error.unable-to-load-revision") });
    }
  }, [setTimelineMode, setTimelineRange, t, timelineStore, toast]);
  const selectSince = (0, import_react2.useCallback)((sinceChunk) => {
    try {
      const [sinceId, revId] = timelineStore.findRangeForSince(sinceChunk);
      setTimelineMode("closed");
      setTimelineRange(sinceId, revId);
    } catch (err) {
      toast.push({ closable: true, description: err.message, status: "error", title: t("timeline.error.unable-to-load-revision") });
    }
  }, [setTimelineMode, setTimelineRange, t, timelineStore, toast]);
  const handleLoadMore = (0, import_react2.useCallback)(() => {
    if (!loading) {
      timelineStore.loadMore();
    }
  }, [loading, timelineStore]);
  const content = timelineError ? (0, import_jsx_runtime.jsx)(TimelineError, {}) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [mode === "rev" && (0, import_jsx_runtime.jsx)(Timeline, { chunks, firstChunk: realRevChunk, hasMoreChunks, lastChunk: realRevChunk, onLoadMore: handleLoadMore, onSelect: selectRev }), mode === "since" && (0, import_jsx_runtime.jsx)(Timeline, { chunks, disabledBeforeFirstChunk: true, firstChunk: realRevChunk, hasMoreChunks, lastChunk: sinceTime, onLoadMore: handleLoadMore, onSelect: selectSince })] });
  const formatParams = { timestamp: { dateStyle: "medium", timeStyle: "short" } };
  const revLabel = chunk ? t(TIMELINE_ITEM_I18N_KEY_MAPPING[chunk.type], { context: "timestamp", timestamp: new Date(chunk == null ? void 0 : chunk.endTimestamp), formatParams }) : t("timeline.latest-version");
  const sinceLabel = chunk ? t("timeline.since", { timestamp: new Date(chunk == null ? void 0 : chunk.endTimestamp), formatParams }) : t("timeline.since-version-missing");
  const buttonLabel = mode === "rev" ? revLabel : sinceLabel;
  return (0, import_jsx_runtime.jsx)(Root$1, { constrainSize: true, content: open && content, "data-ui": "versionMenu", open, placement, portal: true, ref: setPopover, children: (0, import_jsx_runtime.jsx)(Button2, { disabled: !ready, mode: "bleed", iconRight: ChevronDownIcon, onClick: open ? handleClose : handleOpen, ref: setButton, selected: open, style: { maxWidth: "100%" }, text: ready ? buttonLabel : t("timeline.loading-history") }) });
}
function DocumentHeaderTabs() {
  const { activeViewId, paneKey, views: views2 } = useDocumentPane();
  const tabPanelId = "".concat(paneKey, "tabpanel");
  return (0, import_jsx_runtime.jsx)(TabList, { space: 1, children: views2.map((view, index) => {
    var _a2;
    return (0, import_jsx_runtime.jsx)(DocumentHeaderTab, { icon: view.icon, id: "".concat(paneKey, "tab-").concat(view.id), isActive: activeViewId === view.id, label: view.title, tabPanelId, viewId: index === 0 ? null : (_a2 = view.id) != null ? _a2 : null }, view.id);
  }) });
}
function DocumentHeaderTab(props) {
  const { icon, id, isActive, label, tabPanelId, viewId, ...rest } = props;
  const { ready } = useDocumentPane();
  const { setView } = usePaneRouter();
  const handleClick = (0, import_react2.useCallback)(() => setView(viewId), [setView, viewId]);
  return (0, import_jsx_runtime.jsx)(Tab, { ...rest, "aria-controls": tabPanelId, disabled: !ready, icon, id, label, onClick: handleClick, selected: isActive });
}
function DocumentHeaderTitle() {
  const { connectionState, schemaType, title, value: documentValue } = useDocumentPane();
  const subscribed = Boolean(documentValue) && connectionState !== "connecting";
  const { error, value } = useDocumentPreview({ enabled: subscribed, schemaType, value: documentValue });
  const { t } = useTranslation2(structureLocaleNamespace);
  if (connectionState === "connecting") {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
  }
  if (title) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: title });
  }
  if (!documentValue) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: t("panes.document-header-title.new.text", { schemaType: (schemaType == null ? void 0 : schemaType.title) || (schemaType == null ? void 0 : schemaType.name) }) });
  }
  if (error) {
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: t("panes.document-header-title.error.text", { error: error.message }) });
  }
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (value == null ? void 0 : value.title) || (0, import_jsx_runtime.jsx)("span", { style: { color: "var(--card-muted-fg-color)" }, children: t("panes.document-header-title.untitled.text") }) });
}
var DocumentPanelHeader = (0, import_react2.memo)((0, import_react2.forwardRef)(function DocumentPanelHeader2(_props, ref) {
  const { menuItems } = _props;
  const { actions, editState, onMenuAction, onPaneClose, onPaneSplit, menuItemGroups, schemaType, timelineStore, connectionState, views: views2, unstable_languageFilter } = useDocumentPane();
  const { features } = useStructureTool();
  const { index, BackLink: BackLink3, hasGroupSiblings } = usePaneRouter();
  const { actions: fieldActions } = useFieldActions();
  const [referenceElement, setReferenceElement] = (0, import_react2.useState)(null);
  const menuNodes = (0, import_react2.useMemo)(() => resolveMenuNodes({ actionHandler: onMenuAction, fieldActions, menuItems, menuItemGroups }), [onMenuAction, fieldActions, menuItemGroups, menuItems]);
  const menuButtonNodes = (0, import_react2.useMemo)(() => menuNodes.filter(isMenuNodeButton), [menuNodes]);
  const contextMenuNodes = (0, import_react2.useMemo)(() => menuNodes.filter(isNotMenuNodeButton), [menuNodes]);
  const showTabs = views2.length > 1;
  const rev = useTimelineSelector(timelineStore, (state2) => state2.revTime);
  const { collapsed, isLast } = usePane();
  const tabIndex = isLast && !collapsed ? -1 : 0;
  const showSplitPaneButton = features.splitViews && onPaneSplit && views2.length > 1;
  const showSplitPaneCloseButton = showSplitPaneButton && hasGroupSiblings;
  const showBackButton = features.backButton && index > 0;
  const showPaneGroupCloseButton = !showSplitPaneCloseButton && !showBackButton && !!BackLink3;
  const { t } = useTranslation2(structureLocaleNamespace);
  return (0, import_jsx_runtime.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime.jsx)(PaneHeader, { border: true, ref, loading: connectionState === "connecting", title: (0, import_jsx_runtime.jsx)(DocumentHeaderTitle, {}), tabs: showTabs && (0, import_jsx_runtime.jsx)(DocumentHeaderTabs, {}), tabIndex, backButton: showBackButton && (0, import_jsx_runtime.jsx)(Button2, { as: BackLink3, "data-as": "a", icon: ArrowLeftIcon, mode: "bleed", tooltipProps: { content: t("pane-header.back-button.text") } }), subActions: (0, import_jsx_runtime.jsx)(TimelineMenu, { chunk: rev, mode: "rev", placement: "bottom-end" }), actions: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, children: [unstable_languageFilter.length > 0 && (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: unstable_languageFilter.map((languageFilterComponent, idx) => {
    return (0, import_react2.createElement)(languageFilterComponent, {
      // eslint-disable-next-line react/no-array-index-key
      key: "language-filter-".concat(idx),
      schemaType
    });
  }) }), menuButtonNodes.map((item) => (0, import_jsx_runtime.jsx)(PaneHeaderActionButton, { node: item }, item.key)), editState && (0, import_jsx_runtime.jsx)(RenderActionCollectionState, { actions: actions || [], actionProps: editState, group: "paneActions", children: (_ref91) => {
    let { states } = _ref91;
    return (0, import_jsx_runtime.jsx)(ActionDialogWrapper, { actionStates: states, referenceElement, children: (_ref92) => {
      let { handleAction } = _ref92;
      return (0, import_jsx_runtime.jsx)("div", { ref: setReferenceElement, children: (0, import_jsx_runtime.jsx)(PaneContextMenuButton, { nodes: contextMenuNodes, actionsNodes: states.length > 0 ? states.map((actionState, actionIndex) => (0, import_jsx_runtime.jsx)(ActionMenuListItem, { actionState, disabled: Boolean(actionState.disabled), index: actionIndex, onAction: handleAction }, actionState.label)) : void 0 }, "context-menu") });
    } });
  } }), showSplitPaneButton && (0, import_jsx_runtime.jsx)(Button2, { "aria-label": t("buttons.split-pane-button.aria-label"), icon: SplitVerticalIcon, mode: "bleed", onClick: onPaneSplit, tooltipProps: { content: t("buttons.split-pane-button.tooltip") } }, "split-pane-button"), showSplitPaneCloseButton && (0, import_jsx_runtime.jsx)(Button2, { icon: CloseIcon, mode: "bleed", onClick: onPaneClose, tooltipProps: { content: t("buttons.split-pane-close-button.title") } }, "close-view-button"), showPaneGroupCloseButton && (0, import_jsx_runtime.jsx)(Button2, { icon: CloseIcon, mode: "bleed", tooltipProps: { content: t("buttons.split-pane-close-group-button.title") }, as: BackLink3 }, "close-view-button")] }) }) });
}));
var BADGE_TONES = { primary: "primary", success: "positive", warning: "caution", danger: "critical" };
function DocumentBadgesInner(_ref93) {
  let { states } = _ref93;
  if (states.length === 0) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)(Inline, { space: 1, children: states.map((badge, index) => (0, import_jsx_runtime.jsx)(Tooltip, { content: badge.title, disabled: !badge.title, placement: "top", portal: true, children: (0, import_jsx_runtime.jsx)(Badge, { fontSize: 1, mode: "outline", paddingX: 2, paddingY: 1, radius: 4, tone: badge.color ? BADGE_TONES[badge.color] : void 0, style: { whiteSpace: "nowrap" }, children: badge.label }) }, String(index))) });
}
function DocumentBadges() {
  const { badges, editState } = useDocumentPane();
  if (!editState || !badges)
    return null;
  return (0, import_jsx_runtime.jsx)(RenderBadgeCollectionState, { badges, badgeProps: editState, children: (_ref94) => {
    let { states } = _ref94;
    return (0, import_jsx_runtime.jsx)(DocumentBadgesInner, { states });
  } });
}
var DISABLED_REASON_TITLE_KEY$1 = { NOTHING_TO_DELETE: "action.delete.disabled.nothing-to-delete", NOT_READY: "action.delete.disabled.not-ready" };
var DeleteAction = (_ref95) => {
  let { id, type, draft, onComplete } = _ref95;
  const { setIsDeleting: paneSetIsDeleting } = useDocumentPane();
  const { delete: deleteOp } = useDocumentOperation(id, type);
  const [isDeleting, setIsDeleting] = (0, import_react2.useState)(false);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false);
  const { t } = useTranslation2(structureLocaleNamespace);
  const handleCancel = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(false);
    onComplete();
  }, [onComplete]);
  const handleConfirm = (0, import_react2.useCallback)(() => {
    setIsDeleting(true);
    setConfirmDialogOpen(false);
    paneSetIsDeleting(true);
    deleteOp.execute();
    onComplete();
  }, [deleteOp, onComplete, paneSetIsDeleting]);
  const handle = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(true);
  }, []);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({ id, type, permission: "delete" });
  const currentUser = useCurrentUser();
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return { tone: "critical", icon: TrashIcon, disabled: true, label: t("action.delete.label"), title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, { context: "delete-document", currentUser }) };
  }
  return { tone: "critical", icon: TrashIcon, disabled: isDeleting || Boolean(deleteOp.disabled) || isPermissionsLoading, title: deleteOp.disabled && t(DISABLED_REASON_TITLE_KEY$1[deleteOp.disabled]) || "", label: isDeleting ? t("action.delete.running.label") : t("action.delete.label"), shortcut: "Ctrl+Alt+D", onHandle: handle, dialog: isConfirmDialogOpen && { type: "custom", component: (0, import_jsx_runtime.jsx)(ConfirmDeleteDialogContainer, { action: "delete", id: (draft == null ? void 0 : draft._id) || id, type, onCancel: handleCancel, onConfirm: handleConfirm }) } };
};
DeleteAction.action = "delete";
var DISABLED_REASON_KEY$2 = { NO_CHANGES: "action.discard-changes.disabled.no-changes", NOT_PUBLISHED: "action.discard-changes.disabled.not-published", NOT_READY: "action.discard-changes.disabled.not-ready" };
var DiscardChangesAction = (_ref96) => {
  let { id, type, published, liveEdit, onComplete } = _ref96;
  const { discardChanges } = useDocumentOperation(id, type);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({ id, type, permission: "discardDraft" });
  const currentUser = useCurrentUser();
  const { t } = useTranslation2(structureLocaleNamespace);
  const handleConfirm = (0, import_react2.useCallback)(() => {
    discardChanges.execute();
    onComplete();
  }, [discardChanges, onComplete]);
  const handle = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(true);
  }, []);
  const dialog = (0, import_react2.useMemo)(() => isConfirmDialogOpen && { type: "confirm", tone: "critical", onCancel: onComplete, onConfirm: handleConfirm, message: t("action.discard-changes.confirm-dialog.confirm-discard-changes") }, [handleConfirm, isConfirmDialogOpen, onComplete, t]);
  if (!published || liveEdit) {
    return null;
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return { tone: "critical", icon: ResetIcon, disabled: true, label: t("action.discard-changes.label"), title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, { context: "discard-changes", currentUser }) };
  }
  return { tone: "critical", icon: ResetIcon, disabled: Boolean(discardChanges.disabled) || isPermissionsLoading, title: discardChanges.disabled && DISABLED_REASON_KEY$2[discardChanges.disabled] || "", label: t("action.discard-changes.label"), onHandle: handle, dialog };
};
DiscardChangesAction.action = "discardChanges";
var DISABLED_REASON_KEY$1 = { NOTHING_TO_DUPLICATE: "action.duplicate.disabled.nothing-to-duplicate", NOT_READY: "action.duplicate.disabled.not-ready" };
var DuplicateAction = (_ref97) => {
  let { id, type, onComplete } = _ref97;
  const documentStore = useDocumentStore();
  const { duplicate } = useDocumentOperation(id, type);
  const { navigateIntent } = useRouter();
  const [isDuplicating, setDuplicating] = (0, import_react2.useState)(false);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({ id, type, permission: "duplicate" });
  const { t } = useTranslation2(structureLocaleNamespace);
  const currentUser = useCurrentUser();
  const handle = (0, import_react2.useCallback)(async () => {
    const dupeId = v4_default();
    setDuplicating(true);
    const duplicateSuccess = firstValueFrom(documentStore.pair.operationEvents(id, type).pipe(filter((e2) => e2.op === "duplicate" && e2.type === "success")));
    duplicate.execute(dupeId);
    await duplicateSuccess;
    navigateIntent("edit", { id: dupeId, type });
    onComplete();
  }, [documentStore.pair, duplicate, id, navigateIntent, onComplete, type]);
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return { icon: CopyIcon, disabled: true, label: t("action.duplicate.label"), title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, { context: "duplicate-document", currentUser }) };
  }
  return { icon: CopyIcon, disabled: isDuplicating || Boolean(duplicate.disabled) || isPermissionsLoading, label: isDuplicating ? t("action.duplicate.running.label") : t("action.duplicate.label"), title: duplicate.disabled ? t(DISABLED_REASON_KEY$1[duplicate.disabled]) : "", onHandle: handle };
};
DuplicateAction.action = "duplicate";
var HistoryRestoreAction = (_ref98) => {
  let { id, type, revision, onComplete } = _ref98;
  const { restore } = useDocumentOperation(id, type);
  const event = useDocumentOperationEvent(id, type);
  const { navigateIntent } = useRouter();
  const prevEvent = (0, import_react2.useRef)(event);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false);
  const { t } = useTranslation2(structureLocaleNamespace);
  const handleConfirm = (0, import_react2.useCallback)(() => {
    restore.execute(revision);
    onComplete();
  }, [restore, revision, onComplete]);
  (0, import_react2.useEffect)(() => {
    if (!event || event === prevEvent.current)
      return;
    if (event.type === "success" && event.op === "restore") {
      navigateIntent("edit", { id, type });
    }
    prevEvent.current = event;
  }, [event, id, navigateIntent, type]);
  const handle = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(true);
  }, []);
  const dialog = (0, import_react2.useMemo)(() => {
    if (isConfirmDialogOpen) {
      return { type: "confirm", tone: "critical", onCancel: onComplete, onConfirm: handleConfirm, message: t("action.restore.confirm.message") };
    }
    return null;
  }, [handleConfirm, isConfirmDialogOpen, onComplete, t]);
  const isRevisionInitialVersion = revision === "@initial";
  const isRevisionLatestVersion = revision === void 0;
  if (isRevisionLatestVersion) {
    return null;
  }
  return { label: t("action.restore.label"), color: "primary", onHandle: handle, title: t(isRevisionInitialVersion ? "action.restore.disabled.cannot-restore-initial" : "action.restore.tooltip"), icon: RestoreIcon, dialog, disabled: isRevisionInitialVersion };
};
HistoryRestoreAction.action = "restore";
var DocumentPublished = defineEvent({ name: "Document Published", version: 1, description: 'User clicked the "Publish" button in the document pane' });
var DISABLED_REASON_TITLE_KEY = { LIVE_EDIT_ENABLED: "action.publish.live-edit.publish-disabled", ALREADY_PUBLISHED: "action.publish.already-published.no-time-ago.tooltip", NO_CHANGES: "action.publish.no-changes.tooltip", NOT_READY: "action.publish.disabled.not-ready" };
function getDisabledReason(reason, publishedAt, t) {
  if (reason === "ALREADY_PUBLISHED" && publishedAt) {
    return (0, import_jsx_runtime.jsx)(AlreadyPublished, { publishedAt });
  }
  return t(DISABLED_REASON_TITLE_KEY[reason]);
}
function AlreadyPublished(_ref99) {
  let { publishedAt } = _ref99;
  const { t } = useTranslation2(structureLocaleNamespace);
  const timeSincePublished = useRelativeTime(publishedAt);
  return (0, import_jsx_runtime.jsx)("span", { children: t("action.publish.already-published.tooltip", { timeSincePublished }) });
}
var PublishAction = (props) => {
  var _a2;
  const { id, type, liveEdit, draft, published } = props;
  const [publishState, setPublishState] = (0, import_react2.useState)(null);
  const { publish } = useDocumentOperation(id, type);
  const validationStatus = useValidationStatus(id, type);
  const syncState = useSyncState(id, type);
  const { changesOpen, onHistoryOpen, documentId, documentType } = useDocumentPane();
  const editState = useEditState(documentId, documentType);
  const { t } = useTranslation2(structureLocaleNamespace);
  const revision = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev;
  const hasValidationErrors = validationStatus.validation.some(isValidationErrorMarker);
  const [publishScheduled, setPublishScheduled] = (0, import_react2.useState)(false);
  const isSyncing = syncState.isSyncing;
  const isValidating = validationStatus.isValidating;
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({ id, type, permission: "publish" });
  const currentUser = useCurrentUser();
  const title = publish.disabled ? getDisabledReason(publish.disabled, (published || {})._updatedAt, t) || "" : hasValidationErrors ? t("action.publish.validation-issues.tooltip") : "";
  const hasDraft = Boolean(draft);
  const doPublish = (0, import_react2.useCallback)(() => {
    publish.execute();
    setPublishState("publishing");
  }, [publish]);
  (0, import_react2.useEffect)(() => {
    const validationComplete = validationStatus.isValidating === false && validationStatus.revision !== revision;
    if (!publishScheduled || isSyncing || !validationComplete) {
      return;
    }
    if (!hasValidationErrors) {
      doPublish();
    }
    setPublishScheduled(false);
  }, [isSyncing, doPublish, hasValidationErrors, publishScheduled, validationStatus.revision, revision, isValidating, validationStatus.isValidating]);
  (0, import_react2.useEffect)(() => {
    const didPublish = publishState === "publishing" && !hasDraft;
    if (didPublish) {
      if (changesOpen) {
        onHistoryOpen();
      }
    }
    const nextState = didPublish ? "published" : null;
    const delay2 = didPublish ? 200 : 4e3;
    const timer2 = setTimeout(() => {
      setPublishState(nextState);
    }, delay2);
    return () => clearTimeout(timer2);
  }, [changesOpen, publishState, hasDraft, onHistoryOpen]);
  const telemetry = useTelemetry();
  const handle = (0, import_react2.useCallback)(() => {
    telemetry.log(DocumentPublished, { publishedImmediately: !(draft == null ? void 0 : draft._createdAt), previouslyPublished: Boolean(published) });
    if (syncState.isSyncing || validationStatus.isValidating || validationStatus.revision !== revision) {
      setPublishScheduled(true);
    } else {
      doPublish();
    }
  }, [telemetry, draft == null ? void 0 : draft._createdAt, published, syncState.isSyncing, validationStatus.isValidating, validationStatus.revision, revision, doPublish]);
  if (liveEdit) {
    return { tone: "default", icon: PublishIcon, label: t("action.publish.live-edit.label"), title: t("action.publish.live-edit.tooltip"), disabled: true };
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return { tone: "default", icon: PublishIcon, label: "Publish", title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, { context: "publish-document", currentUser }), disabled: true };
  }
  const disabled = Boolean(publishScheduled || ((_a2 = editState == null ? void 0 : editState.transactionSyncLock) == null ? void 0 : _a2.enabled) || publishState === "publishing" || publishState === "published" || hasValidationErrors || publish.disabled);
  return {
    disabled: disabled || isPermissionsLoading,
    tone: "default",
    label: (
      // eslint-disable-next-line no-nested-ternary
      publishState === "published" ? t("action.publish.published.label") : publishScheduled || publishState === "publishing" ? t("action.publish.running.label") : t("action.publish.draft.label")
    ),
    // @todo: Implement loading state, to show a `<Button loading />` state
    // loading: publishScheduled || publishState === 'publishing',
    icon: PublishIcon,
    // eslint-disable-next-line no-nested-ternary
    title: publishScheduled ? t("action.publish.waiting") : publishState === "published" || publishState === "publishing" ? null : title,
    shortcut: disabled || publishScheduled ? null : "Ctrl+Alt+P",
    onHandle: handle
  };
};
PublishAction.action = "publish";
var DISABLED_REASON_KEY = { NOT_PUBLISHED: "action.unpublish.disabled.not-published", NOT_READY: "action.unpublish.disabled.not-ready", LIVE_EDIT_ENABLED: "action.unpublish.disabled.live-edit-enabled" };
var UnpublishAction = (_ref100) => {
  let { id, type, draft, onComplete, liveEdit } = _ref100;
  const { unpublish } = useDocumentOperation(id, type);
  const [isConfirmDialogOpen, setConfirmDialogOpen] = (0, import_react2.useState)(false);
  const [permissions, isPermissionsLoading] = useDocumentPairPermissions({ id, type, permission: "unpublish" });
  const currentUser = useCurrentUser();
  const { t } = useTranslation2(structureLocaleNamespace);
  const handleCancel = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(false);
    onComplete();
  }, [onComplete]);
  const handleConfirm = (0, import_react2.useCallback)(() => {
    setConfirmDialogOpen(false);
    unpublish.execute();
    onComplete();
  }, [onComplete, unpublish]);
  const dialog = (0, import_react2.useMemo)(() => {
    if (isConfirmDialogOpen) {
      return { type: "dialog", onClose: onComplete, content: (0, import_jsx_runtime.jsx)(ConfirmDeleteDialogContainer, { id: (draft == null ? void 0 : draft._id) || id, type, action: "unpublish", onCancel: handleCancel, onConfirm: handleConfirm }) };
    }
    return null;
  }, [draft, id, handleCancel, handleConfirm, isConfirmDialogOpen, onComplete, type]);
  if (liveEdit) {
    return null;
  }
  if (!isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted)) {
    return { tone: "critical", icon: UnpublishIcon, label: "Unpublish", title: (0, import_jsx_runtime.jsx)(InsufficientPermissionsMessage, { context: "unpublish-document", currentUser }), disabled: true };
  }
  return { tone: "critical", icon: UnpublishIcon, disabled: Boolean(unpublish.disabled) || isPermissionsLoading, label: t("action.unpublish.label"), title: unpublish.disabled ? t(DISABLED_REASON_KEY[unpublish.disabled]) : "", onHandle: () => setConfirmDialogOpen(true), dialog };
};
UnpublishAction.action = "unpublish";
function DocumentStatusBarActionsInner(props) {
  const { disabled, showMenu, states } = props;
  const { __internal_tasks } = useDocumentPane();
  const [firstActionState, ...menuActionStates] = states;
  const [buttonElement, setButtonElement] = (0, import_react2.useState)(null);
  const tooltipContent = (0, import_react2.useMemo)(() => {
    if (!firstActionState || !firstActionState.title && !firstActionState.shortcut)
      return null;
    return (0, import_jsx_runtime.jsxs)(Flex, { style: { maxWidth: 300 }, align: "center", gap: 3, children: [firstActionState.title && (0, import_jsx_runtime.jsx)(Text, { size: 1, children: firstActionState.title }), firstActionState.shortcut && (0, import_jsx_runtime.jsx)(Hotkeys, { fontSize: 1, style: { marginTop: -4, marginBottom: -4 }, keys: String(firstActionState.shortcut).split("+").map((s) => s.slice(0, 1).toUpperCase() + s.slice(1).toLowerCase()) })] });
  }, [firstActionState]);
  return (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, children: [__internal_tasks && __internal_tasks.footerAction, firstActionState && (0, import_jsx_runtime.jsx)(LayerProvider, { zOffset: 200, children: (0, import_jsx_runtime.jsx)(Tooltip, { disabled: !tooltipContent, content: tooltipContent, placement: "top", children: (0, import_jsx_runtime.jsx)(Stack, { children: (0, import_jsx_runtime.jsx)(Button2, { "data-testid": "action-".concat(firstActionState.label), disabled: disabled || Boolean(firstActionState.disabled), icon: firstActionState.icon, onClick: firstActionState.onHandle, ref: setButtonElement, size: "large", text: firstActionState.label, tone: firstActionState.tone || "primary" }) }) }) }), showMenu && menuActionStates.length > 0 && (0, import_jsx_runtime.jsx)(ActionMenuButton, { actionStates: menuActionStates, disabled }), firstActionState && firstActionState.dialog && (0, import_jsx_runtime.jsx)(ActionStateDialog, { dialog: firstActionState.dialog, referenceElement: buttonElement })] });
}
var DocumentStatusBarActions = (0, import_react2.memo)(function DocumentStatusBarActions2() {
  const { actions, connectionState, documentId, editState } = useDocumentPane();
  if (!actions || !editState) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)(RenderActionCollectionState, { actions, actionProps: editState, group: "default", children: (_ref101) => {
    let { states } = _ref101;
    return (0, import_jsx_runtime.jsx)(DocumentStatusBarActionsInner, { disabled: connectionState !== "connected", showMenu: actions.length > 1, states }, documentId);
  } });
});
var HistoryStatusBarActions = (0, import_react2.memo)(function HistoryStatusBarActions2() {
  const { connectionState, editState, timelineStore } = useDocumentPane();
  const revTime = useTimelineSelector(timelineStore, (state2) => state2.revTime);
  const revision = (revTime == null ? void 0 : revTime.id) || "";
  const disabled = ((editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || {})._rev === revision;
  const actionProps = (0, import_react2.useMemo)(() => ({ ...editState || {}, revision }), [editState, revision]);
  const historyActions = (0, import_react2.useMemo)(() => [HistoryRestoreAction], []);
  return (0, import_jsx_runtime.jsx)(RenderActionCollectionState, { actions: historyActions, actionProps, group: "default", children: (_ref102) => {
    let { states } = _ref102;
    return (0, import_jsx_runtime.jsx)(DocumentStatusBarActionsInner, { disabled: connectionState !== "connected" || Boolean(disabled), showMenu: false, states });
  } });
});
var __freeze$m = Object.freeze;
var __defProp$m = Object.defineProperty;
var __template$m = (cooked, raw) => __freeze$m(__defProp$m(cooked, "raw", { value: __freeze$m(raw || cooked.slice()) }));
var _a$m;
var _b$9;
var _c$3;
var StyledMotionPath = ut(motion.path)(_a$m || (_a$m = __template$m(["\n  transform-origin: center;\n"])));
var Circle = (props) => (0, import_jsx_runtime.jsx)(motion.circle, { fill: "none", r: "8", cx: "12.5", cy: "12.5", strokeWidth: "1.2", ...props });
var Arrows = (props) => (0, import_jsx_runtime.jsx)(StyledMotionPath, { fill: "none", d: "M14 17.5619L11.5 20.5L14.5 23.0619M11 7.43811L13.5 4.50001L10.5 1.93811", ...props });
var Checkmark = (props) => (0, import_jsx_runtime.jsx)(motion.path, { d: "M9.5 12.1316L11.7414 14.5L16 10", ...props });
var rotateAnimation = ht(_b$9 || (_b$9 = __template$m(["\n  0% {\n    transform: rotate(0);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n"])));
var RotateGroup = ut.g(_c$3 || (_c$3 = __template$m(["\n  transform-origin: center;\n\n  &[data-rotate] {\n    animation: ", " 1s ease-in-out infinite;\n  }\n"])), rotateAnimation);
var root = { syncing: { scale: 1, transition: { duration: 0 } }, saved: { scale: [1, 0.8, 1.2, 0.9, 1.1, 0.95, 1.05, 0.99, 1], transition: { duration: 0.5, delay: 0.2 } }, changes: { transition: { duration: 0 } } };
var circle = { syncing: { strokeDasharray: "0, 0, 23, 3, 23, 3", strokeDashoffset: 10, opacity: 1, transition: { duration: 0 } }, saved: { strokeDasharray: "0, 0, 23, 0, 23, 0", strokeDashoffset: 10, opacity: 1, transition: { duration: 0.2 } }, changes: { strokeDasharray: "0, 60, 23, 0, 23, 0", strokeDashoffset: 0, opacity: 0, transition: { duration: 0.5 } } };
var arrows = { syncing: { opacity: 1, transition: { duration: 0 } }, saved: { opacity: 0, transition: { duration: 0.2 } }, changes: { opacity: 0 } };
var checkmark = { syncing: { pathLength: 0, transition: { duration: 0 } }, saved: { pathLength: 1, transition: { delay: 0.4, duration: 0.3 } }, changes: { pathLength: 0, transition: { duration: 0.2 } } };
function AnimatedStatusIcon(props) {
  const { status } = props;
  if (!status) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)("svg", { width: "1em", height: "1em", viewBox: "0 0 25 25", fill: "none", stroke: "currentColor", strokeWidth: "1.2", "data-sanity-icon": "animated-status-icon", children: (0, import_jsx_runtime.jsxs)(motion.g, { variants: root, initial: status, animate: status, children: [(0, import_jsx_runtime.jsxs)(RotateGroup, { "data-rotate": status === "changes" ? void 0 : "", children: [(0, import_jsx_runtime.jsx)(Arrows, { variants: arrows, initial: status, animate: status }), (0, import_jsx_runtime.jsx)(Circle, { variants: circle, initial: status, animate: status })] }), (0, import_jsx_runtime.jsx)(Checkmark, { variants: checkmark, initial: status, animate: status })] }) });
}
var STATUS_DICTIONARY = { saved: { i18nKey: "status-bar.document-status-pulse.status.saved.text", tone: "positive" }, syncing: { i18nKey: "status-bar.document-status-pulse.status.syncing.text", tone: "default" } };
var DocumentStatusPulse = (props) => {
  const { status } = props;
  const { t } = useTranslation2(structureLocaleNamespace);
  if (status !== "saved" && status !== "syncing") {
    return null;
  }
  const currentStatus = STATUS_DICTIONARY[status];
  return (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, children: [(0, import_jsx_runtime.jsx)(TextWithTone, { size: 1, tone: currentStatus.tone, children: (0, import_jsx_runtime.jsx)(AnimatedStatusIcon, { status }) }), (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: t(currentStatus.i18nKey) })] });
};
var SYNCING_TIMEOUT = 1e3;
var SAVED_TIMEOUT = 3e3;
function DocumentStatusLine(_ref103) {
  let { singleLine } = _ref103;
  const { documentId, documentType, editState, value } = useDocumentPane();
  const [status, setStatus] = (0, import_react2.useState)(null);
  const syncState = useSyncState(documentId, documentType);
  const lastUpdated = value == null ? void 0 : value._updatedAt;
  (0, import_react2.useEffect)(() => {
    if (status === "syncing" && !syncState.isSyncing) {
      const timerId = setTimeout(() => setStatus("saved"), SYNCING_TIMEOUT);
      return () => clearTimeout(timerId);
    }
    if (status === "saved") {
      const timerId = setTimeout(() => setStatus(null), SAVED_TIMEOUT);
      return () => clearTimeout(timerId);
    }
  }, [status, lastUpdated, syncState.isSyncing]);
  (0, import_react2.useLayoutEffect)(() => {
    setStatus(null);
  }, [documentId]);
  (0, import_react2.useLayoutEffect)(() => {
    if (syncState.isSyncing) {
      setStatus("syncing");
    }
  }, [syncState.isSyncing, lastUpdated]);
  if (status) {
    return (0, import_jsx_runtime.jsx)(DocumentStatusPulse, { status: status || void 0 });
  }
  return (0, import_jsx_runtime.jsx)(Tooltip, { content: (0, import_jsx_runtime.jsx)(DocumentStatus, { absoluteDate: true, draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published }), placement: "top", children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [(0, import_jsx_runtime.jsx)(DocumentStatusIndicator, { draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published }), (0, import_jsx_runtime.jsx)(DocumentStatus, { draft: editState == null ? void 0 : editState.draft, published: editState == null ? void 0 : editState.published, singleLine })] }) });
}
function useResizeObserver(_ref104) {
  let { element, onResize } = _ref104;
  (0, import_react2.useLayoutEffect)(() => {
    if (element) {
      resizeObserver.observe(element, onResize);
    }
    return () => {
      if (element) {
        resizeObserver.unobserve(element);
      }
    };
  }, [element, onResize]);
}
var CONTAINER_BREAKPOINT = 480;
function DocumentStatusBar(props) {
  const { actionsBoxRef } = props;
  const { editState, timelineStore } = useDocumentPane();
  const showingRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision);
  const [collapsed, setCollapsed] = (0, import_react2.useState)(null);
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const handleResize = (0, import_react2.useCallback)((event) => {
    setCollapsed(event.contentRect.width < CONTAINER_BREAKPOINT);
  }, []);
  useResizeObserver({ element: rootElement, onResize: handleResize });
  const shouldRender = (editState == null ? void 0 : editState.ready) && typeof collapsed === "boolean";
  return (0, import_jsx_runtime.jsx)(Flex, { direction: "column", ref: setRootElement, sizing: "border", children: shouldRender && (0, import_jsx_runtime.jsxs)(Flex, { align: "stretch", gap: 1, justify: "space-between", paddingY: 2, paddingLeft: 4, paddingRight: 3, children: [(0, import_jsx_runtime.jsxs)(Flex, { align: "center", flex: 1, gap: collapsed ? 2 : 3, wrap: "wrap", paddingRight: 3, children: [(0, import_jsx_runtime.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime.jsx)(DocumentStatusLine, { singleLine: !collapsed }), (0, import_jsx_runtime.jsx)(SpacerButton, { size: "large" })] }), (0, import_jsx_runtime.jsx)(DocumentBadges, {})] }), (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-start", justify: "flex-end", ref: actionsBoxRef, style: { flexShrink: 0, marginLeft: "auto" }, children: [(0, import_jsx_runtime.jsx)(SpacerButton, { size: "large" }), showingRevision ? (0, import_jsx_runtime.jsx)(HistoryStatusBarActions, {}) : (0, import_jsx_runtime.jsx)(DocumentStatusBarActions, {})] })] }) });
}
function KeyboardShortcutResponder(props) {
  const { actionsBoxElement, activeIndex, as = "div", children, id, onActionStart, onKeyDown, rootRef, states, ...rest } = props;
  const activeAction = states[activeIndex];
  const handleKeyDown = (0, import_react2.useCallback)((event) => {
    const matchingStates = states.filter((state2) => state2.shortcut && (0, import_is_hotkey.default)(state2.shortcut, event));
    const matchingState = matchingStates[0];
    if (matchingStates.length > 1) {
      console.warn('Keyboard shortcut conflict: More than one document action matches the shortcut "'.concat(matchingState.shortcut, '"'));
    }
    if (matchingState && !matchingState.disabled && matchingState.onHandle) {
      event.preventDefault();
      matchingState.onHandle();
      onActionStart(states.indexOf(matchingState));
      return;
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  }, [onActionStart, onKeyDown, states]);
  return (0, import_react2.createElement)(as, { id, onKeyDown: handleKeyDown, tabIndex: -1, ...rest, ref: rootRef }, [children, activeAction && activeAction.dialog && (0, import_jsx_runtime.jsx)(LegacyLayerProvider, { zOffset: "paneFooter", children: (0, import_jsx_runtime.jsx)(ActionStateDialog, { dialog: activeAction.dialog, referenceElement: actionsBoxElement }) })]);
}
var DocumentActionShortcuts = React.memo((props) => {
  const { actionsBoxElement, as = "div", children, ...rest } = props;
  const { actions, editState } = useDocumentPane();
  const [activeIndex, setActiveIndex] = (0, import_react2.useState)(-1);
  const onActionStart = (0, import_react2.useCallback)((idx) => {
    setActiveIndex(idx);
  }, []);
  const actionProps = (0, import_react2.useMemo)(() => editState && {
    ...editState,
    // @todo: what to call here?
    onComplete: () => void 0,
    // @todo: get revision string
    revision: void 0
  }, [editState]);
  if (!actionProps || !actions)
    return null;
  return (0, import_jsx_runtime.jsx)(RenderActionCollectionState, { actionProps, actions, children: (_ref105) => {
    let { states } = _ref105;
    return (0, import_jsx_runtime.jsx)(KeyboardShortcutResponder, { ...rest, activeIndex, actionsBoxElement, as, onActionStart, states, children });
  } });
});
DocumentActionShortcuts.displayName = "DocumentActionShortcuts";
function getInspectorItems(_ref106) {
  let { currentInspector, hasValue, inspectors: inspectors2, inspectorMenuItems } = _ref106;
  return inspectors2.map((inspector, index) => {
    var _a2;
    const menuItem = inspectorMenuItems[index];
    if (!menuItem || menuItem.hidden)
      return null;
    return { action: "".concat(INSPECT_ACTION_PREFIX).concat(inspector.name), group: menuItem.showAsAction ? void 0 : "inspectors", icon: menuItem.icon, isDisabled: !hasValue, selected: (currentInspector == null ? void 0 : currentInspector.name) === inspector.name, shortcut: (_a2 = menuItem.hotkeys) == null ? void 0 : _a2.join("+"), showAsAction: menuItem.showAsAction, title: menuItem.title, tone: menuItem.tone };
  }).filter(Boolean);
}
function getInspectItem(_ref107) {
  let { hasValue, t } = _ref107;
  return { action: "inspect", group: "inspectors", title: t("document-inspector.menu-item.title"), icon: JsonIcon, isDisabled: !hasValue, shortcut: "Ctrl+Alt+I" };
}
function getProductionPreviewItem(_ref108) {
  let { previewUrl, t } = _ref108;
  if (!previewUrl)
    return null;
  return { action: "production-preview", group: "links", title: t("production-preview.menu-item.title"), icon: EarthAmericasIcon, shortcut: "Ctrl+Alt+O" };
}
function getMenuItems(params) {
  const inspectorItems = getInspectorItems(params);
  const items = [
    // Get production preview item
    getProductionPreviewItem(params)
  ].filter(Boolean);
  return [
    ...inspectorItems,
    // TODO: convert to inspector or document view?
    getInspectItem(params),
    ...items
  ];
}
var isSanityDocument2 = (value) => isRecord$4(value) && typeof value._id === "string" && typeof value._type === "string";
function usePreviewUrl(value) {
  const [previewUrl, setPreviewUrl] = (0, import_react2.useState)(void 0);
  const [error, setError] = (0, import_react2.useState)(null);
  const { resolveProductionUrl } = useSource().document;
  const value$ = useAsObservable(value);
  if (error)
    throw error;
  (0, import_react2.useEffect)(() => {
    value$.pipe(
      // this so that the preview URL isn't fetched on every keystroke
      debounceTime(500),
      switchMap((document2) => isSanityDocument2(document2) ? from(resolveProductionUrl({ document: document2 })) : of(void 0)),
      catchError((e2) => {
        const message = isRecord$4(e2) && typeof e2.message === "string" ? e2.message : "Unknown error";
        throw new Error("An error was thrown while trying to get your preview url: ".concat(message));
      })
    ).subscribe({ next: setPreviewUrl, error: setError });
  }, [resolveProductionUrl, value$]);
  return previewUrl;
}
function DocumentLayoutError(props) {
  const { documentType, value, currentMinWidth, paneKey, minWidth } = props;
  const { t } = useTranslation2();
  return (0, import_jsx_runtime.jsx)(ErrorPane, { currentMinWidth, flex: 2.5, minWidth, paneKey, title: (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "panes.document-pane.document-unknown-type.title", values: { documentType } }), tone: "caution", children: (0, import_jsx_runtime.jsxs)(Stack, { space: 4, children: [documentType && (0, import_jsx_runtime.jsx)(Text, { as: "p", children: (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "panes.document-pane.document-unknown-type.text", values: { documentType } }) }), !documentType && (0, import_jsx_runtime.jsx)(Text, { as: "p", children: t("panes.document-pane.document-unknown-type.without-schema.text") }), isDev && value && /* eslint-disable i18next/no-literal-string */
  (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Text, { as: "p", children: "Here is the JSON representation of the document:" }), (0, import_jsx_runtime.jsx)(Card, { padding: 3, overflow: "auto", radius: 2, shadow: 1, tone: "inherit", children: (0, import_jsx_runtime.jsx)(Code, { language: "json", size: [1, 1, 2], children: JSON.stringify(value, null, 2) }) })] })] }) });
}
var __freeze$l = Object.freeze;
var __defProp$l = Object.defineProperty;
var __template$l = (cooked, raw) => __freeze$l(__defProp$l(cooked, "raw", { value: __freeze$l(raw || cooked.slice()) }));
var _a$l;
var EMPTY_ARRAY$5 = [];
var DIALOG_PROVIDER_POSITION = [
  // We use the `position: fixed` for dialogs on narrower screens (first two media breakpoints).
  "fixed",
  "fixed",
  // And we use the `position: absolute` strategy (within panes) on wide screens.
  "absolute"
];
var StyledChangeConnectorRoot = ut(ChangeConnectorRoot)(_a$l || (_a$l = __template$l(["\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  min-height: 0;\n  min-width: 0;\n"])));
function DocumentLayout() {
  const { changesOpen, documentId, documentType, fieldActions, inspectOpen, inspector, inspectors: inspectors2, onFocus, onHistoryOpen, onMenuAction, onPathOpen, paneKey, schemaType, value } = useDocumentPane();
  const { features } = useStructureTool();
  const { t } = useTranslation(structureLocaleNamespace);
  const { collapsed: layoutCollapsed } = usePaneLayout();
  const zOffsets = useZIndex();
  const previewUrl = usePreviewUrl(value);
  const [rootElement, setRootElement] = (0, import_react2.useState)(null);
  const [footerElement, setFooterElement] = (0, import_react2.useState)(null);
  const [headerElement, setHeaderElement] = (0, import_react2.useState)(null);
  const [actionsBoxElement, setActionsBoxElement] = (0, import_react2.useState)(null);
  const [documentPanelPortalElement, setDocumentPanelPortalElement] = (0, import_react2.useState)(null);
  const [inspectorMenuItems, setInspectorMenuItems] = (0, import_react2.useState)([]);
  const [rootFieldActionNodes, setRootFieldActionNodes] = (0, import_react2.useState)([]);
  const footerRect = useElementRect(footerElement);
  const headerRect = useElementRect(headerElement);
  const footerHeight = footerRect == null ? void 0 : footerRect.height;
  const headerHeight = headerRect == null ? void 0 : headerRect.height;
  const currentMinWidth = DOCUMENT_PANEL_INITIAL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0);
  const minWidth = DOCUMENT_PANEL_MIN_WIDTH + (inspector ? DOCUMENT_INSPECTOR_MIN_WIDTH : 0);
  const currentInspector = (0, import_react2.useMemo)(() => inspectors2 == null ? void 0 : inspectors2.find((i) => i.name === (inspector == null ? void 0 : inspector.name)), [inspectors2, inspector == null ? void 0 : inspector.name]);
  const hasValue = Boolean(value);
  const menuItems = (0, import_react2.useMemo)(() => getMenuItems({ currentInspector, features, hasValue, inspectorMenuItems, inspectors: inspectors2, previewUrl, t }), [currentInspector, features, hasValue, inspectorMenuItems, inspectors2, previewUrl, t]);
  const handleKeyUp = (0, import_react2.useCallback)((event) => {
    for (const item of menuItems) {
      if (item.shortcut) {
        if ((0, import_is_hotkey.default)(item.shortcut, event)) {
          event.preventDefault();
          event.stopPropagation();
          onMenuAction(item);
          return;
        }
      }
    }
  }, [onMenuAction, menuItems]);
  const onConnectorSetFocus = (0, import_react2.useCallback)((path) => {
    onPathOpen(path);
    onFocus(path);
  }, [onPathOpen, onFocus]);
  if (!schemaType) {
    return (0, import_jsx_runtime.jsx)(DocumentLayoutError, { currentMinWidth, documentType, minWidth, paneKey, value });
  }
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [inspectors2.length > 0 && (0, import_jsx_runtime.jsx)(DocumentInspectorMenuItemsResolver, { documentId, documentType, inspectors: inspectors2, onMenuItems: setInspectorMenuItems }), fieldActions.length > 0 && schemaType && (0, import_jsx_runtime.jsx)(FieldActionsResolver, { actions: fieldActions, documentId, documentType, onActions: setRootFieldActionNodes, path: EMPTY_ARRAY$5, schemaType }), (0, import_jsx_runtime.jsx)(FieldActionsProvider, { actions: rootFieldActionNodes, path: EMPTY_ARRAY$5, children: (0, import_jsx_runtime.jsxs)(DocumentActionShortcuts, { actionsBoxElement, as: Pane, currentMinWidth, "data-testid": "document-pane", flex: 2.5, id: paneKey, minWidth, onKeyUp: handleKeyUp, rootRef: setRootElement, children: [(0, import_jsx_runtime.jsx)(DocumentPanelHeader, { ref: setHeaderElement, menuItems }), (0, import_jsx_runtime.jsx)(DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.paneDialog, children: (0, import_jsx_runtime.jsx)(Flex, { direction: "column", flex: 1, height: layoutCollapsed ? void 0 : "fill", children: (0, import_jsx_runtime.jsx)(StyledChangeConnectorRoot, { "data-testid": "change-connector-root", isReviewChangesOpen: changesOpen, onOpenReviewChanges: onHistoryOpen, onSetFocus: onConnectorSetFocus, children: (0, import_jsx_runtime.jsx)(DocumentPanel, { footerHeight: footerHeight || null, headerHeight: headerHeight || null, isInspectOpen: inspectOpen, rootElement, setDocumentPanelPortalElement }) }) }) }), (0, import_jsx_runtime.jsx)(PortalProvider, { __unstable_elements: { [DOCUMENT_PANEL_PORTAL_ELEMENT]: documentPanelPortalElement }, children: (0, import_jsx_runtime.jsx)(DialogProvider, { position: DIALOG_PROVIDER_POSITION, zOffset: zOffsets.portal, children: (0, import_jsx_runtime.jsx)(PaneFooter, { ref: setFooterElement, children: (0, import_jsx_runtime.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime.jsx)(DocumentStatusBar, { actionsBoxRef: setActionsBoxElement }) }) }) }) }), (0, import_jsx_runtime.jsx)(DocumentOperationResults, {})] }) })] });
}
function pick(plugin) {
  var _a2, _b2;
  return (_b2 = (_a2 = plugin.document) == null ? void 0 : _a2.components) == null ? void 0 : _b2.unstable_layout;
}
function useDocumentLayoutComponent() {
  return useMiddlewareComponents({ pick, defaultComponent: DocumentLayout });
}
function getInitialValueTemplateOpts(templates, opts) {
  const payload = opts.panePayload || {};
  const structureNodeTemplate = opts.templateName;
  if (opts.urlTemplate && structureNodeTemplate && structureNodeTemplate !== opts.urlTemplate) {
    console.warn('Conflicting templates: URL says "'.concat(opts.urlTemplate, '", structure node says "').concat(structureNodeTemplate, '". Using "').concat(structureNodeTemplate, '".'));
  }
  const template2 = structureNodeTemplate || opts.urlTemplate;
  const typeTemplates = templates.filter((t) => t.schemaType === opts.documentType);
  const templateParams = { ...opts.templateParams, ...typeof payload === "object" ? payload || {} : {} };
  let templateName = template2;
  if (!template2 && typeTemplates.length === 1) {
    templateName = typeTemplates[0].id;
  }
  return { templateName, templateParams };
}
var DocumentPaneProvider = (0, import_react2.memo)((props) => {
  const { children, index, pane, paneKey, onFocusPath } = props;
  const schema2 = useSchema();
  const templates = useTemplates();
  const { __internal_tasks, document: { actions: documentActions2, badges: documentBadges2, unstable_fieldActions: fieldActionsResolver, unstable_languageFilter: languageFilterResolver, inspectors: inspectorsResolver } } = useSource();
  const presenceStore = usePresenceStore();
  const paneRouter = usePaneRouter();
  const setPaneParams = paneRouter.setParams;
  const { features } = useStructureTool();
  const { push: pushToast } = useToast();
  const { options, menuItemGroups = DEFAULT_MENU_ITEM_GROUPS, title = null, views: viewsProp = [] } = pane;
  const paneOptions = useUnique(options);
  const documentIdRaw = paneOptions.id;
  const documentId = getPublishedId(documentIdRaw);
  const documentType = options.type;
  const params = useUnique(paneRouter.params) || EMPTY_PARAMS$2;
  const panePayload = useUnique(paneRouter.payload);
  const { templateName, templateParams } = (0, import_react2.useMemo)(() => getInitialValueTemplateOpts(templates, { documentType, templateName: paneOptions.template, templateParams: paneOptions.templateParameters, panePayload, urlTemplate: params.template }), [documentType, paneOptions, params, panePayload, templates]);
  const initialValueRaw = useInitialValue({ documentId, documentType, templateName, templateParams });
  const initialValue = useUnique(initialValueRaw);
  const { patch } = useDocumentOperation(documentId, documentType);
  const editState = useEditState(documentId, documentType);
  const { validation: validationRaw } = useValidationStatus(documentId, documentType);
  const connectionState = useConnectionState(documentId, documentType);
  const schemaType = schema2.get(documentType);
  const value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue.value;
  const [isDeleting, setIsDeleting] = (0, import_react2.useState)(false);
  const actions = (0, import_react2.useMemo)(() => documentActions2({ schemaType: documentType, documentId }), [documentActions2, documentId, documentType]);
  const badges = (0, import_react2.useMemo)(() => documentBadges2({ schemaType: documentType, documentId }), [documentBadges2, documentId, documentType]);
  const languageFilter = (0, import_react2.useMemo)(() => languageFilterResolver({ schemaType: documentType, documentId }), [documentId, documentType, languageFilterResolver]);
  const validation = useUnique(validationRaw);
  const views2 = useUnique(viewsProp);
  const [focusPath, setFocusPath] = (0, import_react2.useState)(() => params.path ? fromString(params.path) : EMPTY_ARRAY$b);
  const focusPathRef = (0, import_react2.useRef)(focusPath);
  const activeViewId = params.view || views2[0] && views2[0].id || null;
  const [timelineMode, setTimelineMode] = (0, import_react2.useState)("closed");
  const [timelineError, setTimelineError] = (0, import_react2.useState)(null);
  const timelineStore = useTimelineStore({ documentId, documentType, onError: setTimelineError, rev: params.rev, since: params.since });
  const onOlderRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision);
  const revTime = useTimelineSelector(timelineStore, (state2) => state2.revTime);
  const sinceAttributes = useTimelineSelector(timelineStore, (state2) => state2.sinceAttributes);
  const timelineDisplayed = useTimelineSelector(timelineStore, (state2) => state2.timelineDisplayed);
  const timelineReady = useTimelineSelector(timelineStore, (state2) => state2.timelineReady);
  const isPristine = useTimelineSelector(timelineStore, (state2) => state2.isPristine);
  const isDeleted = (0, import_react2.useMemo)(() => {
    if (!timelineReady) {
      return false;
    }
    return Boolean(!(editState == null ? void 0 : editState.draft) && !(editState == null ? void 0 : editState.published)) && !isPristine;
  }, [editState == null ? void 0 : editState.draft, editState == null ? void 0 : editState.published, isPristine, timelineReady]);
  const previewUrl = usePreviewUrl(value);
  const [presence, setPresence] = (0, import_react2.useState)([]);
  (0, import_react2.useEffect)(() => {
    const subscription = presenceStore.documentPresence(documentId).subscribe((nextPresence) => {
      setPresence(nextPresence);
    });
    return () => {
      subscription.unsubscribe();
    };
  }, [documentId, presenceStore]);
  const inspectors2 = (0, import_react2.useMemo)(() => inspectorsResolver({ documentId, documentType }), [documentId, documentType, inspectorsResolver]);
  const [inspectorName, setInspectorName] = (0, import_react2.useState)(() => params.inspect || null);
  const inspectParamRef = (0, import_react2.useRef)(params.inspect);
  (0, import_react2.useEffect)(() => {
    if (inspectParamRef.current !== params.inspect) {
      inspectParamRef.current = params.inspect;
      setInspectorName(params.inspect || null);
    }
  }, [params.inspect]);
  const currentInspector = inspectors2 == null ? void 0 : inspectors2.find((i) => i.name === inspectorName);
  const resolvedChangesInspector = inspectors2.find((i) => i.name === HISTORY_INSPECTOR_NAME);
  const changesOpen = (currentInspector == null ? void 0 : currentInspector.name) === HISTORY_INSPECTOR_NAME;
  const { t } = useTranslation2(structureLocaleNamespace);
  const inspectOpen = params.inspect === "on";
  const compareValue = changesOpen ? sinceAttributes : (editState == null ? void 0 : editState.published) || null;
  const fieldActions = (0, import_react2.useMemo)(() => schemaType ? fieldActionsResolver({ documentId, documentType, schemaType }) : [], [documentId, documentType, fieldActionsResolver, schemaType]);
  const ready = connectionState === "connected" && editState.ready && (timelineReady || !!timelineError);
  const displayed = (0, import_react2.useMemo)(() => onOlderRevision ? timelineDisplayed || { _id: value._id, _type: value._type } : value, [onOlderRevision, timelineDisplayed, value]);
  const setTimelineRange = (0, import_react2.useCallback)((newSince, newRev) => {
    setPaneParams({ ...params, since: newSince, rev: newRev || void 0 });
  }, [params, setPaneParams]);
  const handleFocus = (0, import_react2.useCallback)((nextFocusPath) => {
    setFocusPath(nextFocusPath);
    if (focusPathRef.current !== nextFocusPath) {
      focusPathRef.current = nextFocusPath;
      onFocusPath == null ? void 0 : onFocusPath(nextFocusPath);
    }
    presenceStore.setLocation([{ type: "document", documentId, path: nextFocusPath, lastActiveAt: (/* @__PURE__ */ new Date()).toISOString() }]);
  }, [documentId, onFocusPath, presenceStore, setFocusPath]);
  const handleBlur = (0, import_react2.useCallback)((blurredPath) => {
    if (disableBlurRef.current) {
      return;
    }
    setFocusPath(EMPTY_ARRAY$b);
    if (focusPathRef.current !== EMPTY_ARRAY$b) {
      focusPathRef.current = EMPTY_ARRAY$b;
      onFocusPath == null ? void 0 : onFocusPath(EMPTY_ARRAY$b);
    }
  }, [onFocusPath, setFocusPath]);
  const patchRef = (0, import_react2.useRef)(() => {
    throw new Error("Nope");
  });
  patchRef.current = (event) => {
    patch.execute(toMutationPatches(event.patches), initialValue.value);
  };
  const handleChange = (0, import_react2.useCallback)((event) => patchRef.current(event), []);
  const closeInspector = (0, import_react2.useCallback)((closeInspectorName) => {
    var _a2, _b2, _c2, _d2;
    const inspector = closeInspectorName && inspectors2.find((i) => i.name === closeInspectorName);
    if (closeInspectorName && !inspector) {
      console.warn('No inspector named "'.concat(closeInspectorName, '"'));
      return;
    }
    if (!currentInspector) {
      return;
    }
    if (inspector) {
      const result = (_b2 = (_a2 = inspector.onClose) == null ? void 0 : _a2.call(inspector, { params })) != null ? _b2 : { params };
      setInspectorName(null);
      inspectParamRef.current = void 0;
      setPaneParams({ ...result.params, inspect: void 0 });
      return;
    }
    if (currentInspector) {
      const result = (_d2 = (_c2 = currentInspector.onClose) == null ? void 0 : _c2.call(currentInspector, { params })) != null ? _d2 : { params };
      setInspectorName(null);
      inspectParamRef.current = void 0;
      setPaneParams({ ...result.params, inspect: void 0 });
    }
  }, [currentInspector, inspectors2, params, setPaneParams]);
  const openInspector = (0, import_react2.useCallback)((nextInspectorName, paneParams) => {
    var _a2, _b2, _c2, _d2;
    const nextInspector = inspectors2.find((i) => i.name === nextInspectorName);
    if (!nextInspector) {
      console.warn('No inspector named "'.concat(nextInspectorName, '"'));
      return;
    }
    if ((currentInspector == null ? void 0 : currentInspector.name) === nextInspector.name) {
      setPaneParams({ ...params, ...paneParams, inspect: nextInspector.name });
      return;
    }
    let currentParams = params;
    if (currentInspector) {
      const closeResult = (_b2 = (_a2 = nextInspector.onClose) == null ? void 0 : _a2.call(nextInspector, { params: currentParams })) != null ? _b2 : { params: currentParams };
      currentParams = closeResult.params;
    }
    const result = (_d2 = (_c2 = nextInspector.onOpen) == null ? void 0 : _c2.call(nextInspector, { params: currentParams })) != null ? _d2 : { params: currentParams };
    setInspectorName(nextInspector.name);
    inspectParamRef.current = nextInspector.name;
    setPaneParams({ ...result.params, ...paneParams, inspect: nextInspector.name });
  }, [currentInspector, inspectors2, params, setPaneParams]);
  const handleHistoryClose = (0, import_react2.useCallback)(() => {
    if (resolvedChangesInspector) {
      closeInspector(resolvedChangesInspector.name);
    }
  }, [closeInspector, resolvedChangesInspector]);
  const handleHistoryOpen = (0, import_react2.useCallback)(() => {
    if (!features.reviewChanges) {
      return;
    }
    if (resolvedChangesInspector) {
      openInspector(resolvedChangesInspector.name);
    }
  }, [features.reviewChanges, openInspector, resolvedChangesInspector]);
  const handlePaneClose = (0, import_react2.useCallback)(() => paneRouter.closeCurrent(), [paneRouter]);
  const handlePaneSplit = (0, import_react2.useCallback)(() => paneRouter.duplicateCurrent(), [paneRouter]);
  const toggleLegacyInspect = (0, import_react2.useCallback)(function() {
    let toggle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !inspectOpen;
    if (toggle) {
      setPaneParams({ ...params, inspect: "on" });
    } else {
      setPaneParams((0, import_omit.default)(params, "inspect"));
    }
  }, [inspectOpen, params, setPaneParams]);
  const handleMenuAction = (0, import_react2.useCallback)((item) => {
    if (item.action === "production-preview" && previewUrl) {
      window.open(previewUrl);
      return true;
    }
    if (item.action === "inspect") {
      toggleLegacyInspect(true);
      return true;
    }
    if (item.action === "reviewChanges") {
      handleHistoryOpen();
      return true;
    }
    if (typeof item.action === "string" && item.action.startsWith(INSPECT_ACTION_PREFIX)) {
      const nextInspectorName = item.action.slice(INSPECT_ACTION_PREFIX.length);
      const nextInspector = inspectors2.find((i) => i.name === nextInspectorName);
      if (nextInspector) {
        if (nextInspector.name === inspectorName) {
          closeInspector(nextInspector.name);
        } else {
          openInspector(nextInspector.name);
        }
        return true;
      }
    }
    return false;
  }, [closeInspector, handleHistoryOpen, inspectorName, inspectors2, openInspector, previewUrl, toggleLegacyInspect]);
  const handleLegacyInspectClose = (0, import_react2.useCallback)(() => toggleLegacyInspect(false), [toggleLegacyInspect]);
  const [openPath, onSetOpenPath] = (0, import_react2.useState)([]);
  const [fieldGroupState, onSetFieldGroupState] = (0, import_react2.useState)();
  const [collapsedPaths, onSetCollapsedPath] = (0, import_react2.useState)();
  const [collapsedFieldSets, onSetCollapsedFieldSets] = (0, import_react2.useState)();
  const handleOnSetCollapsedPath = (0, import_react2.useCallback)((path, collapsed) => {
    onSetCollapsedPath((prevState) => setAtPath(prevState, path, collapsed));
  }, []);
  const handleOnSetCollapsedFieldSet = (0, import_react2.useCallback)((path, collapsed) => {
    onSetCollapsedFieldSets((prevState) => setAtPath(prevState, path, collapsed));
  }, []);
  const handleSetActiveFieldGroup = (0, import_react2.useCallback)((path, groupName) => onSetFieldGroupState((prevState) => setAtPath(prevState, path, groupName)), []);
  const requiredPermission = value._createdAt ? "update" : "create";
  const liveEdit = Boolean(schemaType == null ? void 0 : schemaType.liveEdit);
  const docId = value._id ? value._id : "dummy-id";
  const docPermissionsInput = (0, import_react2.useMemo)(() => {
    return { ...value, _id: liveEdit ? getPublishedId(docId) : getDraftId(docId) };
  }, [liveEdit, value, docId]);
  const [permissions, isPermissionsLoading] = useDocumentValuePermissions({ document: docPermissionsInput, permission: requiredPermission });
  const isNonExistent = !(value == null ? void 0 : value._id);
  const readOnly = (0, import_react2.useMemo)(() => {
    var _a2;
    const hasNoPermission = !isPermissionsLoading && !(permissions == null ? void 0 : permissions.granted);
    const updateActionDisabled = !isActionEnabled(schemaType, "update");
    const createActionDisabled = isNonExistent && !isActionEnabled(schemaType, "create");
    const reconnecting = connectionState === "reconnecting";
    const isLocked = (_a2 = editState.transactionSyncLock) == null ? void 0 : _a2.enabled;
    return !ready || revTime !== null || hasNoPermission || updateActionDisabled || createActionDisabled || reconnecting || isLocked || isDeleting || isDeleted;
  }, [connectionState, editState.transactionSyncLock, isNonExistent, isDeleted, isDeleting, isPermissionsLoading, permissions == null ? void 0 : permissions.granted, ready, revTime, schemaType]);
  const formState = useFormState(schemaType, { value: displayed, readOnly, comparisonValue: compareValue, focusPath, openPath, collapsedPaths, presence, validation, collapsedFieldSets, fieldGroupState, changesOpen });
  const formStateRef = (0, import_react2.useRef)(formState);
  formStateRef.current = formState;
  const setOpenPath = (0, import_react2.useCallback)((path) => {
    const ops = getExpandOperations(formStateRef.current, path);
    ops.forEach((op) => {
      if (op.type === "expandPath") {
        onSetCollapsedPath((prevState) => setAtPath(prevState, op.path, false));
      }
      if (op.type === "expandFieldSet") {
        onSetCollapsedFieldSets((prevState) => setAtPath(prevState, op.path, false));
      }
      if (op.type === "setSelectedGroup") {
        onSetFieldGroupState((prevState) => setAtPath(prevState, op.path, op.groupName));
      }
    });
    onSetOpenPath(path);
  }, [formStateRef]);
  const documentPane = (0, import_react2.useMemo)(() => ({ actions, activeViewId, badges, changesOpen, closeInspector, collapsedFieldSets, collapsedPaths, compareValue, connectionState, displayed, documentId, documentIdRaw, documentType, editState, fieldActions, focusPath, inspector: currentInspector || null, inspectors: inspectors2, __internal_tasks, onBlur: handleBlur, onChange: handleChange, onFocus: handleFocus, onPathOpen: setOpenPath, onHistoryClose: handleHistoryClose, onHistoryOpen: handleHistoryOpen, onInspectClose: handleLegacyInspectClose, onMenuAction: handleMenuAction, onPaneClose: handlePaneClose, onPaneSplit: handlePaneSplit, onSetActiveFieldGroup: handleSetActiveFieldGroup, onSetCollapsedPath: handleOnSetCollapsedPath, onSetCollapsedFieldSet: handleOnSetCollapsedFieldSet, openInspector, index, inspectOpen, validation, menuItemGroups: menuItemGroups || [], paneKey, previewUrl, ready, schemaType, isPermissionsLoading, permissions, setTimelineMode, setTimelineRange, setIsDeleting, isDeleting, isDeleted, timelineError, timelineMode, timelineStore, title, value, views: views2, formState, unstable_languageFilter: languageFilter }), [__internal_tasks, actions, activeViewId, badges, changesOpen, closeInspector, collapsedFieldSets, collapsedPaths, compareValue, connectionState, currentInspector, displayed, documentId, documentIdRaw, documentType, editState, fieldActions, focusPath, formState, handleBlur, handleChange, handleFocus, handleHistoryClose, handleHistoryOpen, handleLegacyInspectClose, handleMenuAction, handleOnSetCollapsedFieldSet, handleOnSetCollapsedPath, handlePaneClose, handlePaneSplit, handleSetActiveFieldGroup, index, inspectOpen, inspectors2, isDeleted, isDeleting, isPermissionsLoading, languageFilter, menuItemGroups, openInspector, paneKey, permissions, previewUrl, ready, schemaType, setOpenPath, setTimelineRange, timelineError, timelineMode, timelineStore, title, validation, value, views2]);
  (0, import_react2.useEffect)(() => {
    if (connectionState === "reconnecting") {
      pushToast({ id: "sanity/structure/reconnecting", status: "warning", title: t("panes.document-pane-provider.reconnecting.title") });
    }
  }, [connectionState, pushToast, t]);
  const disableBlurRef = (0, import_react2.useRef)(false);
  (0, import_react2.useEffect)(() => {
    var _a2;
    if (ready && params.path) {
      const { path, ...restParams } = params;
      const pathFromUrl = resolveKeyedPath((_a2 = formStateRef.current) == null ? void 0 : _a2.value, fromString(path));
      disableBlurRef.current = true;
      setFocusPath(pathFromUrl);
      setOpenPath(pathFromUrl);
      if (focusPathRef.current !== pathFromUrl) {
        focusPathRef.current = pathFromUrl;
        onFocusPath == null ? void 0 : onFocusPath(pathFromUrl);
      }
      const timeout = setTimeout(() => {
        disableBlurRef.current = false;
      }, 0);
      paneRouter.setParams(restParams);
      return () => clearTimeout(timeout);
    }
    return void 0;
  }, [params, documentId, onFocusPath, setOpenPath, ready, paneRouter]);
  return (0, import_jsx_runtime.jsx)(DocumentPaneContext.Provider, { value: documentPane, children });
});
DocumentPaneProvider.displayName = "DocumentPaneProvider";
var DocumentPane = (0, import_react2.memo)(function DocumentPane2(props) {
  const { name: parentSourceName } = useSource();
  return (0, import_jsx_runtime.jsx)(SourceProvider, { name: props.pane.source || parentSourceName, children: (0, import_jsx_runtime.jsx)(DocumentPaneInner, { ...props }) });
});
function DocumentPaneInner(props) {
  var _a2;
  const { pane, paneKey } = props;
  const { resolveNewDocumentOptions } = useSource().document;
  const paneRouter = usePaneRouter();
  const options = usePaneOptions(pane.options, paneRouter.params);
  const { documentType, isLoaded: isDocumentLoaded } = useDocumentType(options.id, options.type);
  const DocumentLayout2 = useDocumentLayoutComponent();
  const templateItems = (0, import_react2.useMemo)(() => {
    return resolveNewDocumentOptions({ type: "document", documentId: options.id, schemaType: options.type });
  }, [options.id, options.type, resolveNewDocumentOptions]);
  const [templatePermissions, isTemplatePermissionsLoading] = useTemplatePermissions({ templateItems });
  const isLoaded = isDocumentLoaded && !isTemplatePermissionsLoading;
  const providerProps = (0, import_react2.useMemo)(() => {
    return isLoaded && documentType && options.type !== documentType ? mergeDocumentType(props, options, documentType) : props;
  }, [props, documentType, isLoaded, options]);
  const { ReferenceChildLink: ReferenceChildLink3, handleEditReference, groupIndex, routerPanesState } = paneRouter;
  const childParams = ((_a2 = routerPanesState[groupIndex + 1]) == null ? void 0 : _a2[0].params) || {};
  const routerPanesStateLength = routerPanesState.length;
  const { parentRefPath } = childParams;
  const activePath = (0, import_react2.useMemo)(() => {
    return parentRefPath ? { path: fromString(parentRefPath), state: (
      // eslint-disable-next-line no-nested-ternary
      groupIndex >= routerPanesStateLength - 1 ? "none" : groupIndex >= routerPanesStateLength - 2 ? "selected" : "pressed"
    ) } : { path: [], state: "none" };
  }, [parentRefPath, groupIndex, routerPanesStateLength]);
  const { t } = useTranslation2(structureLocaleNamespace);
  if (options.type === "*" && !isLoaded) {
    return (0, import_jsx_runtime.jsx)(LoadingPane, { flex: 2.5, minWidth: 320, paneKey, title: t("panes.document-pane.document-not-found.loading") });
  }
  if (!documentType) {
    return (0, import_jsx_runtime.jsx)(ErrorPane, { flex: 2.5, minWidth: 320, paneKey, title: t("panes.document-pane.document-not-found.title"), children: (0, import_jsx_runtime.jsx)(Stack, { space: 4, children: (0, import_jsx_runtime.jsx)(Text, { as: "p", children: (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "panes.document-pane.document-not-found.text", values: { id: options.id } }) }) }) });
  }
  return (0, import_jsx_runtime.jsx)(DocumentPaneProvider, { ...providerProps, children: (0, import_jsx_runtime.jsx)(ReferenceInputOptionsProvider, { EditReferenceLinkComponent: ReferenceChildLink3, onEditReference: handleEditReference, initialValueTemplateItems: templatePermissions, activePath, children: (0, import_jsx_runtime.jsx)(DocumentLayout2, { documentId: options.id, documentType: options.type }) }) }, "".concat(documentType, "-").concat(options.id));
}
function usePaneOptions(options) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const templates = useTemplates();
  return (0, import_react2.useMemo)(() => {
    if (options.type && options.type !== "*") {
      return options;
    }
    const templateName = options.template || params.template;
    const template2 = templateName ? templates.find((t) => t.id === templateName) : void 0;
    const documentType = template2 == null ? void 0 : template2.schemaType;
    if (!documentType) {
      return options;
    }
    return { ...options, type: documentType };
  }, [options, params.template, templates]);
}
function mergeDocumentType(props, options, documentType) {
  return { ...props, pane: { ...props.pane, options: { ...options, type: documentType } } };
}
var PARTIAL_PAGE_LIMIT = 100;
var FULL_LIST_LIMIT = 2e3;
var DEFAULT_ORDERING = { by: [{ field: "_updatedAt", direction: "desc" }] };
var EMPTY_RECORD = {};
var __freeze$k = Object.freeze;
var __defProp$k = Object.defineProperty;
var __template$k = (cooked, raw) => __freeze$k(__defProp$k(cooked, "raw", { value: __freeze$k(raw || cooked.slice()) }));
var _a$k;
var _b$8;
var RootBox = ut(Box)(_a$k || (_a$k = __template$k(["\n  position: relative;\n"])));
var CommandListBox = ut(Box)(_b$8 || (_b$8 = __template$k(["\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n"])));
var SKELETON_ITEMS = [...Array(30).keys()];
function LoadingView(props) {
  const { layout } = props;
  return (0, import_jsx_runtime.jsx)(Stack, { paddingX: 3, paddingY: 2, paddingTop: 0, space: 1, children: SKELETON_ITEMS.map((num) => (0, import_jsx_runtime.jsx)(SanityDefaultPreview, { isPlaceholder: true, layout }, num)) });
}
function DocumentListPaneContent(props) {
  const { childItemId, error, filterIsSimpleTypeConstraint, hasMaxItems, hasSearchQuery, isActive, isLazyLoading, isLoading, items, layout, loadingVariant, onListChange, onRetry, paneTitle, searchInputElement, showIcons } = props;
  const schema2 = useSchema();
  const { collapsed: layoutCollapsed } = usePaneLayout();
  const { collapsed, index } = usePane();
  const [shouldRender, setShouldRender] = (0, import_react2.useState)(false);
  const { t } = useTranslation2(structureLocaleNamespace);
  const handleEndReached = (0, import_react2.useCallback)(() => {
    if (isLoading || isLazyLoading || !shouldRender)
      return;
    onListChange();
  }, [isLazyLoading, isLoading, onListChange, shouldRender]);
  (0, import_react2.useEffect)(() => {
    if (collapsed)
      return void 0;
    const timer2 = setTimeout(() => {
      setShouldRender(true);
    }, 0);
    return () => {
      clearTimeout(timer2);
    };
  }, [collapsed, items]);
  const renderItem2 = (0, import_react2.useCallback)((item, _ref109) => {
    let { activeIndex } = _ref109;
    const publishedId = getPublishedId(item._id);
    const isSelected = childItemId === publishedId;
    const pressed = !isActive && isSelected;
    const selected = isActive && isSelected;
    const isLastItem = activeIndex === items.length - 1;
    const showSpinner = isLastItem && isLazyLoading;
    const showMaxItemsMessage = isLastItem && hasMaxItems;
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(PaneItem, { icon: showIcons === false ? false : void 0, id: publishedId, layout, marginBottom: 1, pressed, schemaType: schema2.get(item._type), selected, value: item }), showSpinner && (0, import_jsx_runtime.jsx)(LoadingBlock, {}), showMaxItemsMessage && (0, import_jsx_runtime.jsx)(Box, { marginY: 1, paddingX: 3, paddingY: 4, children: (0, import_jsx_runtime.jsx)(Text, { align: "center", muted: true, size: 1, children: t("panes.document-list-pane.max-items.text", { limit: FULL_LIST_LIMIT }) }) })] });
  }, [childItemId, isActive, items.length, layout, schema2, showIcons, hasMaxItems, isLazyLoading, t]);
  const noDocumentsContent = (0, import_react2.useMemo)(() => {
    if (hasSearchQuery) {
      return (0, import_jsx_runtime.jsx)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: (0, import_jsx_runtime.jsx)(Container, { width: 1, children: (0, import_jsx_runtime.jsx)(Box, { paddingX: 4, paddingY: 5, children: (0, import_jsx_runtime.jsx)(Text, { align: "center", muted: true, children: t("panes.document-list-pane.no-documents.text") }) }) }) });
    }
    return (0, import_jsx_runtime.jsx)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: (0, import_jsx_runtime.jsx)(Container, { width: 1, children: (0, import_jsx_runtime.jsx)(Box, { paddingX: 4, paddingY: 5, children: (0, import_jsx_runtime.jsx)(Text, { align: "center", muted: true, children: filterIsSimpleTypeConstraint ? t("panes.document-list-pane.no-documents-of-type.text") : t("panes.document-list-pane.no-matching-documents.text") }) }) }) });
  }, [filterIsSimpleTypeConstraint, hasSearchQuery, t]);
  const mainContent = (0, import_react2.useMemo)(() => {
    if (!shouldRender) {
      return null;
    }
    if (error) {
      return (0, import_jsx_runtime.jsx)(Flex, { align: "center", direction: "column", height: "fill", justify: "center", children: (0, import_jsx_runtime.jsx)(Container, { width: 1, children: (0, import_jsx_runtime.jsxs)(Stack, { paddingX: 4, paddingY: 5, space: 4, children: [(0, import_jsx_runtime.jsx)(Heading, { as: "h3", children: t("panes.document-list-pane.error.title") }), (0, import_jsx_runtime.jsx)(Text, { as: "p", children: (0, import_jsx_runtime.jsx)(Translate, { t, i18nKey: "panes.document-list-pane.error.text", values: { error: error.message }, components: { Code: (_ref110) => {
        let { children } = _ref110;
        return (0, import_jsx_runtime.jsx)("code", { children });
      } } }) }), onRetry && (0, import_jsx_runtime.jsx)(Box, { children: (0, import_jsx_runtime.jsx)(Button2, { icon: SyncIcon, onClick: onRetry, text: t("panes.document-list-pane.error.retry-button.text"), tone: "primary" }) })] }) }) });
    }
    if (!isLoading && items.length === 0) {
      return noDocumentsContent;
    }
    if (loadingVariant === "initial" && isLoading) {
      return (0, import_jsx_runtime.jsx)(Delay, { ms: 300, children: (0, import_jsx_runtime.jsx)(LoadingView, { layout }) });
    }
    if (loadingVariant === "spinner" && isLoading) {
      return null;
    }
    const key = "".concat(index, "-").concat(collapsed);
    return (0, import_jsx_runtime.jsx)(RootBox, { overflow: "hidden", height: "fill", children: (0, import_jsx_runtime.jsx)(CommandListBox, { children: (0, import_jsx_runtime.jsx)(CommandList, { activeItemDataAttr: "data-hovered", ariaLabel: paneTitle, canReceiveFocus: true, inputElement: searchInputElement, itemHeight: 51, items, onEndReached: handleEndReached, onlyShowSelectionWhenActive: true, overscan: 10, paddingBottom: 1, paddingX: 3, renderItem: renderItem2, wrapAround: false }, key) }) });
  }, [
    collapsed,
    error,
    handleEndReached,
    index,
    isLoading,
    items,
    layout,
    loadingVariant,
    // noDocumentsContent,
    onRetry,
    renderItem2,
    searchInputElement,
    shouldRender
  ]);
  return (0, import_jsx_runtime.jsx)(PaneContent, { overflow: layoutCollapsed || loadingVariant === "initial" ? "hidden" : "auto", children: mainContent });
}
var DocumentListPaneHeader = (0, import_react2.memo)((_ref111) => {
  let { contentAfter, index, initialValueTemplates = [], menuItemGroups = [], menuItems = [], setLayout, setSortOrder, title } = _ref111;
  const { features } = useStructureTool();
  const { collapsed, isLast } = usePane();
  const tabIndex = isLast && !collapsed ? -1 : 0;
  const actionHandlers = (0, import_react2.useMemo)(() => {
    return { setLayout: (_ref112) => {
      let { layout: value } = _ref112;
      setLayout(value);
    }, setSortOrder: (sort) => {
      setSortOrder(sort);
    } };
  }, [setLayout, setSortOrder]);
  return (0, import_jsx_runtime.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime.jsx)(PaneHeader, { actions: (0, import_jsx_runtime.jsx)(PaneHeaderActions, { initialValueTemplateItems: initialValueTemplates, actionHandlers, menuItemGroups, menuItems }), backButton: features.backButton && index > 0 && (0, import_jsx_runtime.jsx)(Button2, { as: BackLink, "data-as": "a", icon: ArrowLeftIcon, mode: "bleed", tooltipProps: { content: "Back" } }), contentAfter, tabIndex, title }) });
});
DocumentListPaneHeader.displayName = "DocumentListPaneHeader";
function removePublishedWithDrafts(documents) {
  return collate(documents).map((entry) => {
    const doc = entry.draft || entry.published;
    return { ...doc, hasPublished: !!entry.published, hasDraft: !!entry.draft };
  });
}
var RE_TYPE_NAME_IN_FILTER = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type\b/;
function getTypeNameFromSingleTypeFilter(filter2) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const matches = filter2.match(RE_TYPE_NAME_IN_FILTER);
  if (!matches) {
    return null;
  }
  const match = (matches[1] || matches[2]).trim().replace(/^["']|["']$/g, "");
  if (match[0] === "$") {
    const k = match.slice(1);
    const v = params[k];
    return typeof v === "string" ? v : null;
  }
  return match;
}
function isSimpleTypeFilter(filter2) {
  return /^_type\s*==\s*['"$]\w+['"]?\s*$/.test(filter2.trim());
}
function applyOrderingFunctions(order, schemaType) {
  const orderBy2 = order.by.map((by) => {
    if (by.mapWith) {
      return by;
    }
    const fieldType = tryResolveSchemaTypeForPath(schemaType, by.field);
    if (!fieldType) {
      return by;
    }
    if (fieldExtendsType(fieldType, "datetime")) {
      return { ...by, mapWith: "dateTime" };
    }
    if (fieldType.jsonType === "string") {
      return { ...by, mapWith: "lower" };
    }
    return by;
  });
  return orderBy2.every((item, index) => item === order.by[index]) ? order : { ...order, by: orderBy2 };
}
function tryResolveSchemaTypeForPath(baseType, path) {
  const pathSegments = fromString(path);
  let current = baseType;
  for (const segment of pathSegments) {
    if (!current) {
      return void 0;
    }
    if (typeof segment === "string") {
      current = getFieldTypeByName(current, segment);
      continue;
    }
    const isArrayAccessor = isKeySegment(segment) || isIndexSegment(segment);
    if (!isArrayAccessor || current.jsonType !== "array") {
      return void 0;
    }
    const [memberType, otherType] = current.of || [];
    if (otherType || !memberType) {
      return void 0;
    }
    if (!isReferenceSchemaType(memberType)) {
      current = memberType;
      continue;
    }
    const [refType, otherRefType] = memberType.to || [];
    if (otherRefType || !refType) {
      return void 0;
    }
    current = refType;
  }
  return current;
}
function getFieldTypeByName(type, fieldName) {
  if (!("fields" in type)) {
    return void 0;
  }
  const fieldType = type.fields.find((field) => field.name === fieldName);
  return fieldType ? fieldType.type : void 0;
}
function fieldExtendsType(field, ofType) {
  let current = field.type;
  while (current) {
    if (current.name === ofType) {
      return true;
    }
    if (!current.type && current.jsonType === ofType) {
      return true;
    }
    current = current.type;
  }
  return false;
}
var IMPLICIT_SCHEMA_TYPE_FIELDS = ["_id", "_type", "_createdAt", "_updatedAt", "_rev"];
function joinReferences(schemaType, path) {
  let strict = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  const [head, ...tail] = path;
  if (!("fields" in schemaType)) {
    return "";
  }
  const schemaField = schemaType.fields.find((field) => field.name === head);
  if (!schemaField) {
    if (!IMPLICIT_SCHEMA_TYPE_FIELDS.includes(head)) {
      const errorMessage = 'The current ordering config targeted the nonexistent field "'.concat(head, '" on schema type "').concat(schemaType.name, '". It should be one of ').concat(schemaType.fields.map((field) => field.name).join(", "));
      if (strict) {
        throw new Error(errorMessage);
      } else {
        console.warn(errorMessage);
      }
    }
    return "";
  }
  if ("to" in schemaField.type && schemaField.type.name === "reference") {
    const refTypes = schemaField.type.to;
    return "".concat(head, "->{").concat(refTypes.map((refType) => joinReferences(refType, tail)).join(","), "}");
  }
  const tailFields = tail.length > 0 && joinReferences(schemaField.type, tail);
  const tailWrapper = tailFields ? "{".concat(tailFields, "}") : "";
  return tail.length > 0 ? "".concat(head).concat(tailWrapper) : head;
}
function getExtendedProjection(schemaType, orderBy2) {
  let strict = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  return orderBy2.map((ordering) => joinReferences(schemaType, ordering.field.split("."), strict)).join(", ");
}
function listenSearchQuery(options) {
  const { client, schema: schema2, sort, limit, params, filter: filter2, searchQuery, staticTypeNames, maxFieldDepth, unstable_enableNewSearch } = options;
  const sortBy = sort.by;
  const extendedProjection = sort == null ? void 0 : sort.extendedProjection;
  const events$ = defer(() => {
    return client.listen("*[".concat(filter2, "]"), params, { events: ["welcome", "mutation", "reconnect"], includeResult: false, visibility: "query" });
  }).pipe(mergeMap((ev, i) => {
    const isFirst = i === 0;
    if (isFirst && ev.type !== "welcome") {
      return throwError(() => new Error(ev.type === "reconnect" ? "Could not establish EventSource connection" : 'Received unexpected type of first event "'.concat(ev.type, '"')));
    }
    return of(ev);
  }), share());
  const [welcome$, mutationAndReconnect$] = partition(events$, (ev) => ev.type === "welcome");
  return merge(welcome$.pipe(take(1)), mutationAndReconnect$.pipe(throttleTime(1e3, asyncScheduler, { leading: true, trailing: true }))).pipe(exhaustMapWithTrailing((event) => {
    const typeNames$ = staticTypeNames ? of(staticTypeNames) : client.observable.fetch("array::unique(*[".concat(filter2, "][]._type)"), params);
    return typeNames$.pipe(mergeMap((typeNames) => {
      const types = getSearchableTypes(schema2).filter((type) => {
        if (typeNames.includes(type.name)) {
          getExtendedProjection(type, sort.by, true);
          return true;
        }
        return false;
      });
      const search = createSearch(types, client, { filter: filter2, params, unstable_enableNewSearch, maxDepth: maxFieldDepth });
      const doFetch = () => {
        const searchTerms = { filter: filter2, query: searchQuery || "", types };
        const searchOptions = { __unstable_extendedProjection: extendedProjection, comments: ["findability-source: ".concat(searchQuery ? "list-query" : "list")], limit, skipSortByScore: true, sort: sortBy };
        return search(searchTerms, searchOptions).pipe(map((result) => (
          // eslint-disable-next-line max-nested-callbacks
          result.hits.map((_ref113) => {
            let { hit } = _ref113;
            return hit;
          })
        )));
      };
      if (event.type === "mutation" && event.visibility !== "query") {
        return timer(1200).pipe(mergeMap(doFetch));
      }
      return doFetch();
    }));
  }));
}
var EMPTY_ARRAY$4 = [];
var INITIAL_STATE$1 = { error: null, onRetry: void 0, result: null };
var INITIAL_QUERY_RESULTS = { result: null, error: null };
function useDocumentList(opts) {
  const { filter: filter2, params: paramsProp, sortOrder, searchQuery, apiVersion } = opts;
  const client = useClient({ ...DEFAULT_STUDIO_CLIENT_OPTIONS, apiVersion: apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion });
  const { unstable_enableNewSearch = false } = useWorkspace().search;
  const schema2 = useSchema();
  const maxFieldDepth = useSearchMaxFieldDepth();
  const [resultState, setResult] = (0, import_react2.useState)(INITIAL_STATE$1);
  const { onRetry, error, result } = resultState;
  const documents = result == null ? void 0 : result.documents;
  const items = (0, import_react2.useMemo)(() => documents ? removePublishedWithDrafts(documents) : EMPTY_ARRAY$4, [documents]);
  const [isLazyLoading, setIsLazyLoading] = (0, import_react2.useState)(false);
  const [hasFullList, setHasFullList] = (0, import_react2.useState)(false);
  const [shouldFetchFullList, setShouldFetchFullList] = (0, import_react2.useState)(false);
  const typeNameFromFilter = (0, import_react2.useMemo)(() => getTypeNameFromSingleTypeFilter(filter2, paramsProp), [filter2, paramsProp]);
  const isLoading = result === null && !error;
  const hasMaxItems = (documents == null ? void 0 : documents.length) === FULL_LIST_LIMIT;
  const onListChange = (0, import_react2.useCallback)(() => {
    if (isLoading || hasFullList || shouldFetchFullList)
      return;
    setShouldFetchFullList(true);
  }, [isLoading, hasFullList, shouldFetchFullList]);
  const handleSetResult = (0, import_react2.useCallback)((res) => {
    var _a2, _b2;
    if (res.error) {
      setResult(res);
      return;
    }
    const documentsLength = ((_b2 = (_a2 = res.result) == null ? void 0 : _a2.documents) == null ? void 0 : _b2.length) || 0;
    const isLoadingMoreItems = !res.error && (res == null ? void 0 : res.result) === null && shouldFetchFullList;
    if (isLoadingMoreItems) {
      setIsLazyLoading(true);
      return;
    }
    if (documentsLength < PARTIAL_PAGE_LIMIT && documentsLength !== 0 && !shouldFetchFullList) {
      setHasFullList(true);
    }
    if ((res == null ? void 0 : res.result) === null) {
      setResult((prev) => ({ ...prev.error ? res : prev }));
      return;
    }
    setIsLazyLoading(false);
    setResult(res);
  }, [shouldFetchFullList]);
  const queryResults$ = (0, import_react2.useMemo)(() => {
    const onRetry$ = new Subject();
    const _onRetry = () => onRetry$.next();
    const limit = shouldFetchFullList ? FULL_LIST_LIMIT : PARTIAL_PAGE_LIMIT;
    const sort = sortOrder || DEFAULT_ORDERING;
    return listenSearchQuery({ client, filter: filter2, limit, params: paramsProp, schema: schema2, searchQuery: searchQuery || "", sort, staticTypeNames: typeNameFromFilter ? [typeNameFromFilter] : void 0, maxFieldDepth, unstable_enableNewSearch }).pipe(map((results) => ({ result: { documents: results }, error: null })), startWith(INITIAL_QUERY_RESULTS), catchError((err) => {
      if (err instanceof ProgressEvent) {
        return throwError(() => new Error("Request error"));
      }
      return throwError(() => err);
    }), catchError((err, caught$) => {
      return concat(of({ result: null, error: err }), merge(fromEvent(window, "online"), onRetry$).pipe(take(1), mergeMap(() => caught$)));
    }), scan((prev, next) => ({ ...prev, ...next, onRetry: _onRetry })));
  }, [shouldFetchFullList, sortOrder, client, filter2, paramsProp, schema2, searchQuery, typeNameFromFilter, maxFieldDepth, unstable_enableNewSearch]);
  (0, import_react2.useEffect)(() => {
    const sub = queryResults$.subscribe(handleSetResult);
    return () => {
      sub.unsubscribe();
    };
  }, [handleSetResult, queryResults$]);
  const reset = (0, import_react2.useCallback)(() => {
    setHasFullList(false);
    setIsLazyLoading(false);
    setResult(INITIAL_STATE$1);
    setShouldFetchFullList(false);
  }, []);
  (0, import_react2.useEffect)(() => {
    reset();
  }, [reset, filter2, paramsProp, sortOrder, searchQuery]);
  return { error, hasMaxItems, isLazyLoading, isLoading, isSearchReady: !error, items, onListChange, onRetry };
}
var __freeze$j = Object.freeze;
var __defProp$j = Object.defineProperty;
var __template$j = (cooked, raw) => __freeze$j(__defProp$j(cooked, "raw", { value: __freeze$j(raw || cooked.slice()) }));
var _a$j;
var _b$7;
var EMPTY_ARRAY$3 = [];
var rotate = ht(_a$j || (_a$j = __template$j(["\n  from {\n    transform: rotate(0deg);\n  }\n  to {\n    transform: rotate(360deg);\n  }\n"])));
var AnimatedSpinnerIcon = ut(SpinnerIcon)(_b$7 || (_b$7 = __template$j(["\n  animation: ", " 500ms linear infinite;\n"])), rotate);
function useShallowUnique(value) {
  const valueRef = (0, import_react2.useRef)(value);
  if (!(0, import_shallow_equals.default)(valueRef.current, value)) {
    valueRef.current = value;
  }
  return valueRef.current;
}
var addSelectedStateToMenuItems = (options) => {
  const { menuItems, sortOrderRaw, layout } = options;
  return menuItems == null ? void 0 : menuItems.map((item) => {
    var _a2, _b2, _c2, _d2;
    if ((_a2 = item.params) == null ? void 0 : _a2.layout) {
      return { ...item, selected: layout === ((_b2 = item.params) == null ? void 0 : _b2.layout) };
    }
    if ((_c2 = item == null ? void 0 : item.params) == null ? void 0 : _c2.by) {
      return { ...item, selected: (0, import_isEqual2.default)(sortOrderRaw == null ? void 0 : sortOrderRaw.by, ((_d2 = item == null ? void 0 : item.params) == null ? void 0 : _d2.by) || EMPTY_ARRAY$3) };
    }
    return { ...item, selected: false };
  });
};
var DocumentListPane = (0, import_react2.memo)(function DocumentListPane2(props) {
  const { childItemId, index, isActive, isSelected, pane, paneKey } = props;
  const schema2 = useSchema();
  const { name: parentSourceName } = useSource();
  const { defaultLayout = "default", displayOptions, initialValueTemplates = EMPTY_ARRAY$3, menuItemGroups, menuItems, options } = pane;
  const { apiVersion, defaultOrdering = EMPTY_ARRAY$3, filter: filter2 } = options;
  const params = useShallowUnique(options.params || EMPTY_RECORD);
  const sourceName = pane.source;
  const typeName = (0, import_react2.useMemo)(() => getTypeNameFromSingleTypeFilter(filter2, params), [filter2, params]);
  const showIcons = (displayOptions == null ? void 0 : displayOptions.showIcons) !== false;
  const [layout, setLayout] = useStructureToolSetting("layout", typeName, defaultLayout);
  const { t } = useTranslation2(structureLocaleNamespace);
  const { title } = useI18nText(pane);
  const [searchQuery, setSearchQuery] = (0, import_react2.useState)("");
  const [searchInputValue, setSearchInputValue] = (0, import_react2.useState)("");
  const [searchInputElement, setSearchInputElement] = (0, import_react2.useState)(null);
  const showSearchLoadingRef = (0, import_react2.useRef)(false);
  const defaultSortOrder = (0, import_react2.useMemo)(() => {
    return (defaultOrdering == null ? void 0 : defaultOrdering.length) > 0 ? { by: defaultOrdering } : DEFAULT_ORDERING;
  }, [defaultOrdering]);
  const [sortOrderRaw, setSortOrder] = useStructureToolSetting("sort-order", typeName, defaultSortOrder);
  const sortWithOrderingFn = typeName && sortOrderRaw ? applyOrderingFunctions(sortOrderRaw, schema2.get(typeName)) : sortOrderRaw;
  const sortOrder = useUnique(sortWithOrderingFn);
  const filterIsSimpleTypeConstraint = isSimpleTypeFilter(filter2);
  const { error, hasMaxItems, isLazyLoading, isLoading, isSearchReady, items, onListChange, onRetry } = useDocumentList({ apiVersion, filter: filter2, params, searchQuery: searchQuery == null ? void 0 : searchQuery.trim(), sortOrder });
  const menuItemsWithSelectedState = (0, import_react2.useMemo)(() => addSelectedStateToMenuItems({ menuItems, sortOrderRaw, layout }), [layout, menuItems, sortOrderRaw]);
  const handleQueryChange = useObservableCallback((event$) => {
    return event$.pipe(map((event) => event.target.value), tap(setSearchInputValue), debounce((value) => value === "" ? of("") : timer(300)), tap(setSearchQuery));
  }, []);
  const handleClearSearch = (0, import_react2.useCallback)(() => {
    setSearchQuery("");
    setSearchInputValue("");
  }, []);
  const handleSearchKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "Escape") {
      handleClearSearch();
    }
  }, [handleClearSearch]);
  (0, import_react2.useEffect)(() => {
    if (showSearchLoadingRef.current === false && !isLoading) {
      showSearchLoadingRef.current = true;
    }
    return () => {
      showSearchLoadingRef.current = false;
    };
  }, [isLoading]);
  (0, import_react2.useEffect)(() => {
    handleClearSearch();
    showSearchLoadingRef.current = false;
  }, [paneKey, handleClearSearch]);
  const loadingVariant = (0, import_react2.useMemo)(() => {
    const showSpinner = isLoading && items.length === 0 && showSearchLoadingRef.current;
    if (showSpinner)
      return "spinner";
    return "initial";
  }, [isLoading, items.length]);
  const searchInput = (0, import_jsx_runtime.jsx)(Box, { paddingX: 3, paddingBottom: 3, children: (0, import_jsx_runtime.jsx)(TextInput, { "aria-label": t("panes.document-list-pane.search-input.aria-label"), autoComplete: "off", border: false, clearButton: Boolean(searchQuery), disabled: !isSearchReady, fontSize: [2, 2, 1], icon: loadingVariant === "spinner" ? AnimatedSpinnerIcon : SearchIcon, onChange: handleQueryChange, onClear: handleClearSearch, onKeyDown: handleSearchKeyDown, padding: 2, placeholder: t("panes.document-list-pane.search-input.placeholder"), radius: 2, ref: setSearchInputElement, spellCheck: false, value: searchInputValue }) });
  return (0, import_jsx_runtime.jsx)(SourceProvider, { name: sourceName || parentSourceName, children: (0, import_jsx_runtime.jsxs)(Pane, { currentMaxWidth: 350, "data-ui": "DocumentListPane", id: paneKey, maxWidth: 640, minWidth: 320, selected: isSelected, children: [_DEBUG, (0, import_jsx_runtime.jsx)(DocumentListPaneHeader, { contentAfter: searchInput, index, initialValueTemplates, menuItemGroups, menuItems: menuItemsWithSelectedState, setLayout, setSortOrder, title }), (0, import_jsx_runtime.jsx)(DocumentListPaneContent, { childItemId, error, filterIsSimpleTypeConstraint, hasMaxItems, hasSearchQuery: Boolean(searchQuery), isActive, isLazyLoading, isLoading, items, layout, loadingVariant, onListChange, onRetry, paneTitle: title, searchInputElement, showIcons }, paneKey)] }) });
});
var SerializeError = class extends Error {
  constructor(message, parentPath, pathSegment, hint) {
    super(message);
    const segment = typeof pathSegment === "undefined" ? "<unknown>" : "".concat(pathSegment);
    this.path = (parentPath || []).concat(hint ? "".concat(segment, " (").concat(hint, ")") : segment);
  }
  withHelpUrl(id) {
    this.helpId = id;
    return this;
  }
};
var HELP_URL = ((HELP_URL2) => {
  HELP_URL2["ID_REQUIRED"] = "structure-node-id-required";
  HELP_URL2["TITLE_REQUIRED"] = "structure-title-required";
  HELP_URL2["FILTER_REQUIRED"] = "structure-filter-required";
  HELP_URL2["INVALID_LIST_ITEM"] = "structure-invalid-list-item";
  HELP_URL2["COMPONENT_REQUIRED"] = "structure-view-component-required";
  HELP_URL2["DOCUMENT_ID_REQUIRED"] = "structure-document-id-required";
  HELP_URL2["DOCUMENT_TYPE_REQUIRED"] = "structure-document-type-required";
  HELP_URL2["SCHEMA_TYPE_REQUIRED"] = "structure-schema-type-required";
  HELP_URL2["SCHEMA_TYPE_NOT_FOUND"] = "structure-schema-type-not-found";
  HELP_URL2["LIST_ITEMS_MUST_BE_ARRAY"] = "structure-list-items-must-be-array";
  HELP_URL2["QUERY_PROVIDED_FOR_FILTER"] = "structure-query-provided-for-filter";
  HELP_URL2["ACTION_OR_INTENT_REQUIRED"] = "structure-action-or-intent-required";
  HELP_URL2["LIST_ITEM_IDS_MUST_BE_UNIQUE"] = "structure-list-item-ids-must-be-unique";
  HELP_URL2["ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE"] = "structure-action-and-intent-mutually-exclusive";
  HELP_URL2["API_VERSION_REQUIRED_FOR_CUSTOM_FILTER"] = "structure-api-version-required-for-custom-filter";
  return HELP_URL2;
})(HELP_URL || {});
var ORDER_BY_UPDATED_AT = { title: "Last edited", i18n: { title: { key: "menu-items.sort-by.last-edited", ns: structureLocaleNamespace } }, name: "lastEditedDesc", by: [{ field: "_updatedAt", direction: "desc" }] };
var ORDER_BY_CREATED_AT = { title: "Created", i18n: { title: { key: "menu-items.sort-by.created", ns: structureLocaleNamespace } }, name: "lastCreatedDesc", by: [{ field: "_createdAt", direction: "desc" }] };
var DEFAULT_SELECTED_ORDERING_OPTION = ORDER_BY_UPDATED_AT;
var DEFAULT_ORDERING_OPTIONS = [
  ORDER_BY_UPDATED_AT,
  // _updatedAt
  ORDER_BY_CREATED_AT
  // _createdAt
];
function maybeSerializeMenuItem(item, index, path) {
  return item instanceof MenuItemBuilder ? item.serialize({ path, index }) : item;
}
var MenuItemBuilder = class _MenuItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    this.spec = spec ? spec : {};
  }
  /**
  * Set menu item action
  * @param action - menu item action. See {@link MenuItemActionType}
  * @returns menu item builder based on action provided. See {@link MenuItemBuilder}
  */
  action(action) {
    return this.clone({ action });
  }
  /**
  * Get menu item action
  * @returns menu item builder action. See {@link PartialMenuItem}
  */
  getAction() {
    return this.spec.action;
  }
  /**
  * Set menu item intent
  * @param intent - menu item intent. See {@link Intent}
  * @returns menu item builder based on intent provided. See {@link MenuItemBuilder}
  */
  intent(intent) {
    return this.clone({ intent });
  }
  /**
  * Get menu item intent
  * @returns menu item intent. See {@link PartialMenuItem}
  */
  getIntent() {
    return this.spec.intent;
  }
  /**
  * Set menu item title
  * @param title - menu item title
  * @returns menu item builder based on title provided. See {@link MenuItemBuilder}
  */
  title(title) {
    return this.clone({ title });
  }
  /**
  * Get menu item title. Note that the `i18n` configuration will take
  * precedence and this title is left here for compatibility.
  * @returns menu item title
  */
  getTitle() {
    return this.spec.title;
  }
  /**
  * Set the i18n key and namespace used to populate the localized title.
  * @param i18n - object with i18n key and related namespace
  * @returns menu item builder based on i18n config provided. See {@link MenuItemBuilder}
  */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /**
  * Get the i18n key and namespace used to populate the localized title.
  * @returns the i18n key and namespace used to populate the localized title.
  */
  getI18n() {
    return this.spec.i18n;
  }
  /**
  * Set menu item group
  * @param group - menu item group
  * @returns menu item builder based on group provided. See {@link MenuItemBuilder}
  */
  group(group) {
    return this.clone({ group });
  }
  /**
  * Get menu item group
  * @returns menu item group. See {@link PartialMenuItem}
  */
  getGroup() {
    return this.spec.group;
  }
  /**
  * Set menu item icon
  * @param icon - menu item icon
  * @returns menu item builder based on icon provided. See {@link MenuItemBuilder}
  */
  icon(icon) {
    return this.clone({ icon });
  }
  /**
  * Get menu item icon
  * @returns menu item icon. See {@link PartialMenuItem}
  */
  getIcon() {
    return this.spec.icon;
  }
  /**
  * Set menu item parameters
  * @param params - menu item parameters. See {@link MenuItemParamsType}
  * @returns menu item builder based on parameters provided. See {@link MenuItemBuilder}
  */
  params(params) {
    return this.clone({ params });
  }
  /**
  * Get meny item parameters
  * @returns menu item parameters. See {@link PartialMenuItem}
  */
  getParams() {
    return this.spec.params;
  }
  /**
  * Set menu item to show as action
  * @param showAsAction - determine if menu item should show as action
  * @returns menu item builder based on if it should show as action. See {@link MenuItemBuilder}
  */
  showAsAction() {
    let showAsAction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return this.clone({ showAsAction: Boolean(showAsAction) });
  }
  /**
  * Check if menu item should show as action
  * @returns true if menu item should show as action, false if not. See {@link PartialMenuItem}
  */
  getShowAsAction() {
    return this.spec.showAsAction;
  }
  /** Serialize menu item builder
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns menu item node based on path provided in options. See {@link MenuItem}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const { title, action, intent } = this.spec;
    if (!title) {
      const hint = typeof action === "string" ? 'action: "'.concat(action, '"') : void 0;
      throw new SerializeError("`title` is required for menu item", options.path, options.index, hint).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    if (!action && !intent) {
      throw new SerializeError("`action` or `intent` required for menu item with title ".concat(this.spec.title), options.path, options.index, '"'.concat(title, '"')).withHelpUrl(HELP_URL.ACTION_OR_INTENT_REQUIRED);
    }
    if (intent && action) {
      throw new SerializeError("cannot set both `action` AND `intent`", options.path, options.index, '"'.concat(title, '"')).withHelpUrl(HELP_URL.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE);
    }
    return { ...this.spec, title };
  }
  /** Clone menu item builder
  * @param withSpec - menu item options. See {@link PartialMenuItem}
  * @returns menu item builder based on context and spec provided. See {@link MenuItemBuilder}
  */
  clone(withSpec) {
    const builder = new _MenuItemBuilder(this._context);
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
function getOrderingMenuItem(context, _ref114, extendedProjection) {
  let { by, title, i18n } = _ref114;
  let builder = new MenuItemBuilder(context).group("sorting").title(context.i18n.t("default-menu-item.fallback-title", {
    // note this lives in the `studio` bundle because that one is loaded by default
    ns: "studio",
    replace: { title }
    // replaces the `{{title}}` option
  })).icon(SortIcon).action("setSortOrder").params({ by, extendedProjection });
  if (i18n) {
    builder = builder.i18n(i18n);
  }
  return builder;
}
function getOrderingMenuItemsForSchemaType(context, typeName) {
  const { schema: schema2 } = context;
  const type = typeof typeName === "string" ? schema2.get(typeName) : typeName;
  if (!type || !("orderings" in type)) {
    return [];
  }
  return (type.orderings ? type.orderings.concat(DEFAULT_ORDERING_OPTIONS) : DEFAULT_ORDERING_OPTIONS).map((ordering) => getOrderingMenuItem(context, ordering, getExtendedProjection(type, ordering.by)));
}
function maybeSerializeMenuItemGroup(item, index, path) {
  return item instanceof MenuItemGroupBuilder ? item.serialize({ path, index }) : item;
}
var MenuItemGroupBuilder = class _MenuItemGroupBuilder {
  constructor(_context, spec) {
    this._context = _context;
    this._id = spec ? spec.id : "";
    this._title = spec ? spec.title : "";
    this._i18n = spec ? spec.i18n : void 0;
  }
  /**
  * Set menu item group ID
  * @param id - menu item group ID
  * @returns menu item group builder based on ID provided. See {@link MenuItemGroupBuilder}
  */
  id(id) {
    return new _MenuItemGroupBuilder(this._context, { id, title: this._title, i18n: this._i18n });
  }
  /**
  * Get menu item group ID
  * @returns menu item group ID
  */
  getId() {
    return this._id;
  }
  /**
  * Set menu item group title
  * @param title - menu item group title
  * @returns menu item group builder based on title provided. See {@link MenuItemGroupBuilder}
  */
  title(title) {
    return new _MenuItemGroupBuilder(this._context, { title, id: this._id, i18n: this._i18n });
  }
  /**
  * Get menu item group title
  * @returns menu item group title
  */
  getTitle() {
    return this._title;
  }
  /**
  * Set the i18n key and namespace used to populate the localized title.
  * @param i18n - object with i18n key and related namespace
  * @returns menu item group builder based on i18n info provided. See {@link MenuItemGroupBuilder}
  */
  i18n(i18n) {
    return new _MenuItemGroupBuilder(this._context, { i18n, id: this._id, title: this._title });
  }
  /**
  * Get the i18n key and namespace used to populate the localized title.
  * @returns the i18n key and namespace used to populate the localized title.
  */
  getI18n() {
    return this._i18n;
  }
  /**
  * Serialize menu item group builder
  * @param options - serialization options (path). See {@link SerializeOptions}
  * @returns menu item group based on path provided in options. See {@link MenuItemGroup}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const { _id, _title, _i18n } = this;
    if (!_id) {
      throw new SerializeError("`id` is required for a menu item group", options.path, options.index, _title).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!_title) {
      throw new SerializeError("`title` is required for a menu item group", options.path, _id).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    return { id: _id, title: _title, i18n: _i18n };
  }
};
var disallowedPattern = /([^A-Za-z0-9-_.])/;
function validateId(id, parentPath, pathSegment) {
  if (typeof id !== "string") {
    throw new SerializeError("Structure node id must be of type string, got ".concat(typeof id), parentPath, pathSegment);
  }
  const [disallowedChar] = id.match(disallowedPattern) || [];
  if (disallowedChar) {
    throw new SerializeError('Structure node id cannot contain character "'.concat(disallowedChar, '"'), parentPath, pathSegment);
  }
  if (id.startsWith("__edit__")) {
    throw new SerializeError("Structure node id cannot start with __edit__", parentPath, pathSegment);
  }
  return id;
}
function getStructureNodeId(title, id) {
  if (id) {
    return id;
  }
  const camelCased = (0, import_camelCase.default)(title);
  return disallowedPattern.test(camelCased) ? (0, import_camelCase.default)((0, import_speakingurl.default)(title)) : camelCased;
}
var ComponentBuilder = class _ComponentBuilder {
  constructor(spec) {
    this.spec = { options: {}, ...spec ? spec : {} };
  }
  /** Set Component ID
  * @param id - component ID
  * @returns component builder based on ID provided
  */
  id(id) {
    return this.clone({ id });
  }
  /** Get ID
  * @returns ID
  */
  getId() {
    return this.spec.id;
  }
  /** Set Component title
  * @param title - component title
  * @returns component builder based on title provided (and ID)
  */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get Component title
  * @returns title
  */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
  * @param i18n - the key and namespaced used to populate the localized title.
  * @returns component builder based on i18n key and ns provided
  */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
  * @returns the i18n key and namespace used to populate the localized title
  */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Component child
  * @param child - child component
  * @returns component builder based on child component provided
  */
  child(child) {
    return this.clone({ child });
  }
  /** Get Component child
  * @returns child component
  */
  getChild() {
    return this.spec.child;
  }
  /** Set component
  * @param component - user built component
  * @returns component builder based on component provided
  */
  component(component2) {
    return this.clone({ component: component2 });
  }
  /** Get Component
  * @returns component
  */
  getComponent() {
    return this.spec.component;
  }
  /** Set Component options
  * @param options - component options
  * @returns component builder based on options provided
  */
  options(options) {
    return this.clone({ options });
  }
  /** Get Component options
  * @returns component options
  */
  getOptions() {
    return this.spec.options || {};
  }
  /** Set Component menu items
  * @param menuItems - component menu items
  * @returns component builder based on menuItems provided
  */
  menuItems(menuItems) {
    return this.clone({ menuItems });
  }
  /** Get Component menu items
  * @returns menu items
  */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set Component menu item groups
  * @param menuItemGroups - component menu item groups
  * @returns component builder based on menuItemGroups provided
  */
  menuItemGroups(menuItemGroups) {
    return this.clone({ menuItemGroups });
  }
  /** Get Component menu item groups
  * @returns menu item groups
  */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Serialize component
  * @param options - serialization options
  * @returns component object based on path provided in options
  *
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const { id, title, child, options: componentOptions, component: component2 } = this.spec;
    if (!id) {
      throw new SerializeError("`id` is required for `component` structure item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!component2) {
      throw new SerializeError("`component` is required for `component` structure item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    return { id: validateId(id, options.path, options.index), title, type: "component", child, component: component2, options: componentOptions || {}, menuItems: (this.spec.menuItems || []).map((item, i) => maybeSerializeMenuItem(item, i, options.path)), menuItemGroups: (this.spec.menuItemGroups || []).map((item, i) => maybeSerializeMenuItemGroup(item, i, options.path)) };
  }
  /** Clone component builder (allows for options overriding)
  * @param withSpec - component builder options
  * @returns cloned builder
  */
  clone(withSpec) {
    const builder = new _ComponentBuilder();
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
async function resolveTypeForDocument(getClient, id) {
  const query = "*[_id in [$documentId, $draftId]]._type";
  const documentId = getPublishedId(id);
  const draftId = getDraftId(id);
  const types = await getClient(DEFAULT_STUDIO_CLIENT_OPTIONS).fetch(query, { documentId, draftId }, { tag: "structure.resolve-type" });
  return types[0];
}
var GenericViewBuilder = class {
  constructor() {
    this.spec = {};
  }
  /** Set generic view ID
  * @param id - generic view ID
  * @returns generic view builder based on ID provided.
  */
  id(id) {
    return this.clone({ id });
  }
  /** Get generic view ID
  * @returns generic view ID
  */
  getId() {
    return this.spec.id;
  }
  /** Set generic view title
  * @param title - generic view title
  * @returns generic view builder based on title provided and (if provided) its ID.
  */
  title(title) {
    return this.clone({ title, id: this.spec.id || (0, import_kebabCase.default)(title) });
  }
  /** Get generic view title
  * @returns generic view title
  */
  getTitle() {
    return this.spec.title;
  }
  /** Set generic view icon
  * @param icon - generic view icon
  * @returns generic view builder based on icon provided.
  */
  icon(icon) {
    return this.clone({ icon });
  }
  /** Get generic view icon
  * @returns generic view icon
  */
  getIcon() {
    return this.spec.icon;
  }
  /** Serialize generic view
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns generic view object based on path provided in options. See {@link BaseView}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const { id, title, icon } = this.spec;
    if (!id) {
      throw new SerializeError("`id` is required for view item", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!title) {
      throw new SerializeError("`title` is required for view item", options.path, options.index).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    return { id: validateId(id, options.path, options.index), title, icon };
  }
};
function isSerializable(view) {
  return typeof view.serialize === "function";
}
function maybeSerializeView(item, index, path) {
  return isSerializable(item) ? item.serialize({ path, index }) : item;
}
var isComponentSpec = (spec) => isRecord$4(spec) && spec.type === "component";
var ComponentViewBuilder = class _ComponentViewBuilder extends GenericViewBuilder {
  constructor(componentOrSpec) {
    const spec = isComponentSpec(componentOrSpec) ? { ...componentOrSpec } : { options: {} };
    super();
    this.spec = spec;
    const userComponent = typeof componentOrSpec === "function" ? componentOrSpec : this.spec.component;
    if (userComponent) {
      this.spec = this.component(userComponent).spec;
    }
  }
  /** Set view Component
  * @param component - component view component. See {@link UserViewComponent}
  * @returns component view builder based on component view provided. See {@link ComponentViewBuilder}
  */
  component(component2) {
    return this.clone({ component: component2 });
  }
  /** Get view Component
  * @returns Partial component view. See {@link ComponentView}
  */
  getComponent() {
    return this.spec.component;
  }
  /** Set view Component options
  * @param options - component view options
  * @returns component view builder based on options provided. See {@link ComponentViewBuilder}
  */
  options(options) {
    return this.clone({ options });
  }
  /** Get view Component options
  * @returns component view options. See {@link ComponentView}
  */
  getOptions() {
    return this.spec.options || {};
  }
  /** Serialize view Component
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns component view based on path provided in options. See {@link ComponentView}
  *
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const base = super.serialize(options);
    const component2 = this.spec.component;
    if (typeof component2 !== "function") {
      throw new SerializeError("`component` is required and must be a function for `component()` view item", options.path, options.index).withHelpUrl(HELP_URL.COMPONENT_REQUIRED);
    }
    return { ...base, component: component2, options: this.spec.options || {}, type: "component" };
  }
  /** Clone Component view builder (allows for options overriding)
  * @param withSpec - partial for component view option. See {@link ComponentView}
  * @returns component view builder. See {@link ComponentViewBuilder}
  */
  clone(withSpec) {
    const builder = new _ComponentViewBuilder();
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
var FormViewBuilder = class _FormViewBuilder extends GenericViewBuilder {
  constructor(spec) {
    super();
    this.spec = { id: "editor", title: "Editor", ...spec ? spec : {} };
  }
  /**
  * Serialize Form view builder
  * @param options - Serialize options. See {@link SerializeOptions}
  * @returns form view builder based on path provided in options. See {@link FormView}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    return { ...super.serialize(options), type: "form" };
  }
  /**
  * Clone Form view builder (allows for options overriding)
  * @param withSpec - Partial form view builder options. See {@link FormView}
  * @returns form view builder. See {@link FormViewBuilder}
  */
  clone(withSpec) {
    const builder = new _FormViewBuilder();
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
var form = (spec) => new FormViewBuilder(spec);
var component = (componentOrSpec) => new ComponentViewBuilder(componentOrSpec);
var views = Object.freeze({ __proto__: null, ComponentViewBuilder, FormViewBuilder, GenericViewBuilder, component, form, maybeSerializeView });
var createDocumentChildResolver = (_ref115) => {
  let { resolveDocumentNode, getClient } = _ref115;
  return async (itemId, _ref116) => {
    let { params, path } = _ref116;
    let type = params.type;
    const parentPath = path.slice(0, path.length - 1);
    const currentSegment = path[path.length - 1];
    if (!type) {
      type = await resolveTypeForDocument(getClient, itemId);
    }
    if (!type) {
      throw new SerializeError("Failed to resolve document, and no type provided in parameters.", parentPath, currentSegment);
    }
    return resolveDocumentNode({ documentId: itemId, schemaType: type });
  };
};
var DocumentBuilder = class _DocumentBuilder {
  constructor(_context, spec) {
    this._context = _context;
    this.spec = spec ? spec : {};
  }
  /** Set Document Builder ID
  * @param id - document builder ID
  * @returns document builder based on ID provided. See {@link DocumentBuilder}
  */
  id(id) {
    return this.clone({ id });
  }
  /** Get Document Builder ID
  * @returns document ID. See {@link PartialDocumentNode}
  */
  getId() {
    return this.spec.id;
  }
  /** Set Document title
  * @param title - document title
  * @returns document builder based on title provided (and ID). See {@link DocumentBuilder}
  */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get Document title
  * @returns document title. See {@link PartialDocumentNode}
  */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
  * @param i18n - the key and namespaced used to populate the localized title.
  * @returns component builder based on i18n key and ns provided
  */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
  * @returns the i18n key and namespace used to populate the localized title
  */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set Document child
  * @param child - document child
  * @returns document builder based on child provided. See {@link DocumentBuilder}
  */
  child(child) {
    return this.clone({ child });
  }
  /** Get Document child
  * @returns document child. See {@link PartialDocumentNode}
  */
  getChild() {
    return this.spec.child;
  }
  /** Set Document ID
  * @param documentId - document ID
  * @returns document builder with document based on ID provided. See {@link DocumentBuilder}
  */
  documentId(documentId) {
    const paneId = this.spec.id || documentId;
    return this.clone({ id: paneId, options: { ...this.spec.options || {}, id: documentId } });
  }
  /** Get Document ID
  * @returns document ID. See {@link DocumentOptions}
  */
  getDocumentId() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.id;
  }
  /** Set Document Type
  * @param documentType - document type
  * @returns document builder with document based on type provided. See {@link DocumentBuilder}
  */
  schemaType(documentType) {
    return this.clone({ options: { ...this.spec.options || {}, type: typeof documentType === "string" ? documentType : documentType.name } });
  }
  /** Get Document Type
  * @returns document type. See {@link DocumentOptions}
  */
  getSchemaType() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.type;
  }
  /** Set Document Template
  * @param templateId - document template ID
  * @param parameters - document template parameters
  * @returns document builder with document based on template provided. See {@link DocumentBuilder}
  */
  initialValueTemplate(templateId, parameters) {
    return this.clone({ options: { ...this.spec.options || {}, template: templateId, templateParameters: parameters } });
  }
  /** Get Document Template
  * @returns document template. See {@link DocumentOptions}
  */
  getInitialValueTemplate() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.template;
  }
  /** Get Document's initial value Template parameters
  * @returns document template parameters. See {@link DocumentOptions}
  */
  getInitialValueTemplateParameters() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.templateParameters;
  }
  /** Set Document views
  * @param views - document views. See {@link ViewBuilder} and {@link View}
  * @returns document builder with document based on views provided. See {@link DocumentBuilder}
  */
  views(views2) {
    return this.clone({ views: views2 });
  }
  /** Get Document views
  * @returns document views. See {@link ViewBuilder} and {@link View}
  */
  getViews() {
    return this.spec.views || [];
  }
  /** Serialize Document builder
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns document node based on path, index and hint provided in options. See {@link DocumentNode}
  */
  serialize() {
    let { path = [], index, hint } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const urlId = path[index || path.length - 1];
    const id = this.spec.id || urlId && "".concat(urlId) || "";
    const options = { id, type: void 0, template: void 0, templateParameters: void 0, ...this.spec.options };
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for document nodes", path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!options || !options.id) {
      throw new SerializeError("document id (`id`) is required for document nodes", path, id, hint).withHelpUrl(HELP_URL.DOCUMENT_ID_REQUIRED);
    }
    if (!options || !options.type) {
      throw new SerializeError("document type (`schemaType`) is required for document nodes", path, id, hint);
    }
    const views2 = (this.spec.views && this.spec.views.length > 0 ? this.spec.views : [form()]).map((item, i) => maybeSerializeView(item, i, path));
    const viewIds = views2.map((view) => view.id);
    const dupes = (0, import_uniq.default)(viewIds.filter((viewId, i) => viewIds.includes(viewId, i + 1)));
    if (dupes.length > 0) {
      throw new SerializeError("document node has views with duplicate IDs: ".concat(dupes.join(",  ")), path, id, hint);
    }
    return { ...this.spec, child: this.spec.child || createDocumentChildResolver(this._context), id: validateId(id, path, index), type: "document", options: getDocumentOptions(options), views: views2 };
  }
  /** Clone Document builder
  * @param withSpec - partial document node specification used to extend the cloned builder. See {@link PartialDocumentNode}
  * @returns document builder based on context and spec provided. See {@link DocumentBuilder}
  */
  clone() {
    let withSpec = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const builder = new _DocumentBuilder(this._context);
    const options = { ...this.spec.options || {}, ...withSpec.options || {} };
    builder.spec = { ...this.spec, ...withSpec, options };
    return builder;
  }
};
function getDocumentOptions(spec) {
  const opts = { id: spec.id || "", type: spec.type || "*" };
  if (spec.template) {
    opts.template = spec.template;
  }
  if (spec.templateParameters) {
    opts.templateParameters = spec.templateParameters;
  }
  return opts;
}
function documentFromEditor(context, spec) {
  let doc = (spec == null ? void 0 : spec.type) ? (
    // Use user-defined document fragment as base if possible
    context.resolveDocumentNode({ schemaType: spec.type })
  ) : (
    // Fall back to plain old document builder
    new DocumentBuilder(context)
  );
  if (!spec)
    return doc;
  const { id, type, template: template2, templateParameters } = spec.options;
  doc = doc.id(spec.id).documentId(id);
  if (type) {
    doc = doc.schemaType(type);
  }
  if (template2) {
    doc = doc.initialValueTemplate(template2, templateParameters);
  }
  if (spec.child) {
    doc = doc.child(spec.child);
  }
  return doc;
}
function documentFromEditorWithInitialValue(_ref117, templateId, parameters) {
  let { resolveDocumentNode, templates } = _ref117;
  const template2 = templates.find((t) => t.id === templateId);
  if (!template2) {
    throw new Error('Template with ID "'.concat(templateId, '" not defined'));
  }
  return resolveDocumentNode({ schemaType: template2.schemaType }).initialValueTemplate(templateId, parameters);
}
var InitialValueTemplateItemBuilder = class _InitialValueTemplateItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    this.spec = spec ? spec : {};
  }
  /** Set initial value template item builder ID
  * @param id - initial value template item ID
  * @returns initial value template item based on ID provided. See {@link InitialValueTemplateItemBuilder}
  */
  id(id) {
    return this.clone({ id });
  }
  /** Get initial value template item builder ID
  * @returns initial value template item ID. See {@link InitialValueTemplateItem}
  */
  getId() {
    return this.spec.id;
  }
  /** Set initial value template item title
  * @param title - initial value template item title
  * @returns initial value template item based on title provided. See {@link InitialValueTemplateItemBuilder}
  */
  title(title) {
    return this.clone({ title });
  }
  /** Get initial value template item title
  * @returns initial value template item title. See {@link InitialValueTemplateItem}
  */
  getTitle() {
    return this.spec.title;
  }
  /** Set initial value template item description
  * @param description - initial value template item description
  * @returns initial value template item builder based on description provided. See {@link InitialValueTemplateItemBuilder}
  */
  description(description) {
    return this.clone({ description });
  }
  /** Get initial value template item description
  * @returns initial value template item description. See {@link InitialValueTemplateItem}
  */
  getDescription() {
    return this.spec.description;
  }
  /** Set initial value template ID
  * @param templateId - initial value template item template ID
  * @returns initial value template item based builder on template ID provided. See {@link InitialValueTemplateItemBuilder}
  */
  templateId(templateId) {
    const paneId = this.spec.id || templateId;
    return this.clone({ id: paneId, templateId });
  }
  /** Get initial value template item template ID
  * @returns initial value template item ID. See {@link InitialValueTemplateItem}
  */
  getTemplateId() {
    return this.spec.templateId;
  }
  /** Get initial value template item template parameters
  * @param parameters - initial value template item parameters
  * @returns initial value template item builder based on parameters provided. See {@link InitialValueTemplateItemBuilder}
  */
  parameters(parameters) {
    return this.clone({ parameters });
  }
  /** Get initial value template item template parameters
  * @returns initial value template item parameters. See {@link InitialValueTemplateItem}
  */
  getParameters() {
    return this.spec.parameters;
  }
  /** Serialize initial value template item
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns initial value template item object based on the path, index and hint provided in options. See {@link InitialValueTemplateItem}
  */
  serialize() {
    let { path = [], index, hint } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const { spec, _context } = this;
    const { templates } = _context;
    if (typeof spec.id !== "string" || !spec.id) {
      throw new SerializeError("`id` is required for initial value template item nodes", path, index, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!spec.templateId) {
      throw new SerializeError("template id (`templateId`) is required for initial value template item nodes", path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    const template2 = templates.find((t) => t.id === spec.templateId);
    if (!template2) {
      throw new SerializeError("template id (`templateId`) is required for initial value template item nodes", path, spec.id, hint).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    return { id: spec.id, templateId: spec.id, schemaType: template2.schemaType, type: "initialValueTemplateItem", description: spec.description || template2.description, title: spec.title || template2.title, subtitle: spec.subtitle, icon: spec.icon || template2.icon, initialDocumentId: spec.initialDocumentId, parameters: spec.parameters };
  }
  /** Clone generic view builder (allows for options overriding)
  * @param withSpec - initial value template item builder options. See {@link InitialValueTemplateItemBuilder}
  * @returns initial value template item builder based on the context and options provided. See {@link InitialValueTemplateItemBuilder}
  */
  clone() {
    let withSpec = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const builder = new _InitialValueTemplateItemBuilder(this._context);
    builder.spec = { ...this.spec, ...withSpec };
    return builder;
  }
};
function defaultInitialValueTemplateItems(context) {
  const { schema: schema2, getStructureBuilder, templates } = context;
  const typeNames = schema2.getTypeNames();
  const ordered = templates.filter((tpl) => {
    var _a2;
    return !((_a2 = tpl.parameters) == null ? void 0 : _a2.length);
  }).sort((a, b) => typeNames.indexOf(a.schemaType) - typeNames.indexOf(b.schemaType));
  return ordered.map((tpl) => getStructureBuilder().initialValueTemplateItem(tpl.id));
}
function maybeSerializeInitialValueTemplateItem(item, index, path) {
  return item instanceof InitialValueTemplateItemBuilder ? item.serialize({ path, index }) : item;
}
function menuItemsFromInitialValueTemplateItems(context, templateItems) {
  const { schema: schema2, templates } = context;
  return templateItems.map((item) => {
    const template2 = templates.find((t) => t.id === item.templateId);
    const title = item.title || (template2 == null ? void 0 : template2.title) || "Create";
    const params = {};
    if (template2 && template2.schemaType) {
      params.type = template2.schemaType;
    }
    if (item.templateId) {
      params.template = item.templateId;
    }
    const intentParams = item.parameters ? [params, item.parameters] : params;
    const schemaType = template2 && schema2.get(template2.schemaType);
    const i18n = item.i18n || (template2 == null ? void 0 : template2.i18n);
    let builder = new MenuItemBuilder(context).title(title).icon(template2 && template2.icon || (schemaType == null ? void 0 : schemaType.icon) || AddIcon).intent({ type: "create", params: intentParams });
    if (i18n) {
      builder = builder.i18n(i18n);
    }
    return builder.serialize();
  });
}
var DEFAULT_INTENT_HANDLER = Symbol("Document type list canHandleIntent");
var defaultIntentChecker = (intentName, params, _ref118) => {
  let { pane } = _ref118;
  var _a2, _b2;
  const isEdit = intentName === "edit";
  const isCreate = intentName === "create";
  const typedSpec = pane;
  const paneFilter = ((_a2 = typedSpec.options) == null ? void 0 : _a2.filter) || "";
  const paneParams = ((_b2 = typedSpec.options) == null ? void 0 : _b2.params) || {};
  const typeNames = typedSpec.schemaTypeName ? [typedSpec.schemaTypeName] : getTypeNamesFromFilter(paneFilter, paneParams);
  const initialValueTemplates = typedSpec.initialValueTemplates || [];
  if (isCreate && params.template) {
    return initialValueTemplates.some((tpl) => tpl.templateId === params.template);
  }
  return isEdit && params.id && typeNames.includes(params.type) || isCreate && typeNames.includes(params.type);
};
defaultIntentChecker.identity = DEFAULT_INTENT_HANDLER;
var layoutOptions = ["default", "card", "media", "detail", "block"];
function noChildResolver() {
  return void 0;
}
var shallowIntentChecker = (intentName, params, _ref119) => {
  let { pane, index } = _ref119;
  return index <= 1 && defaultIntentChecker(intentName, params, { pane, index });
};
var GenericListBuilder = class {
  constructor() {
    this.initialValueTemplatesSpecified = false;
    this.spec = {};
  }
  /** Set generic list ID
  * @param id - generic list ID
  * @returns generic list builder based on ID provided.
  */
  id(id) {
    return this.clone({ id });
  }
  /** Get generic list ID
  * @returns generic list ID
  */
  getId() {
    return this.spec.id;
  }
  /** Set generic list title
  * @param title - generic list title
  * @returns generic list builder based on title and ID provided.
  */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /** Get generic list title
  * @returns generic list title
  */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
  * @param i18n - the key and namespaced used to populate the localized title.
  * @returns component builder based on i18n key and ns provided
  */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
  * @returns the i18n key and namespace used to populate the localized title
  */
  getI18n() {
    return this.spec.i18n;
  }
  /** Set generic list layout
  * @param defaultLayout - generic list layout key.
  * @returns generic list builder based on layout provided.
  */
  defaultLayout(defaultLayout) {
    return this.clone({ defaultLayout });
  }
  /** Get generic list layout
  * @returns generic list layout
  */
  getDefaultLayout() {
    return this.spec.defaultLayout;
  }
  /** Set generic list menu items
  * @param menuItems - generic list menu items. See {@link MenuItem} and {@link MenuItemBuilder}
  * @returns generic list builder based on menu items provided.
  */
  menuItems(menuItems) {
    return this.clone({ menuItems });
  }
  /** Get generic list menu items
  * @returns generic list menu items
  */
  getMenuItems() {
    return this.spec.menuItems;
  }
  /** Set generic list menu item groups
  * @param menuItemGroups - generic list menu item groups. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder}
  * @returns generic list builder based on menu item groups provided.
  */
  menuItemGroups(menuItemGroups) {
    return this.clone({ menuItemGroups });
  }
  /** Get generic list menu item groups
  * @returns generic list menu item groups
  */
  getMenuItemGroups() {
    return this.spec.menuItemGroups;
  }
  /** Set generic list child
  * @param child - generic list child. See {@link Child}
  * @returns generic list builder based on child provided (clone).
  */
  child(child) {
    return this.clone({ child });
  }
  /** Get generic list child
  * @returns generic list child
  */
  getChild() {
    return this.spec.child;
  }
  /** Set generic list can handle intent
  * @param canHandleIntent - generic list intent checker. See {@link IntentChecker}
  * @returns generic list builder based on can handle intent provided.
  */
  canHandleIntent(canHandleIntent) {
    return this.clone({ canHandleIntent });
  }
  /** Get generic list can handle intent
  * @returns generic list can handle intent
  */
  getCanHandleIntent() {
    return this.spec.canHandleIntent;
  }
  /** Set generic list display options
  * @param enabled - allow / disallow for showing icons
  * @returns generic list builder based on display options (showIcons) provided.
  */
  showIcons() {
    let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return this.clone({ displayOptions: { ...this.spec.displayOptions || {}, showIcons: enabled } });
  }
  /** Get generic list display options
  * @returns generic list display options (specifically showIcons)
  */
  getShowIcons() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcons : void 0;
  }
  /** Set generic list initial value templates
  * @param templates - generic list initial value templates. See {@link InitialValueTemplateItemBuilder}
  * @returns generic list builder based on templates provided.
  */
  initialValueTemplates(templates) {
    this.initialValueTemplatesSpecified = true;
    return this.clone({ initialValueTemplates: Array.isArray(templates) ? templates : [templates] });
  }
  /** Get generic list initial value templates
  * @returns generic list initial value templates
  */
  getInitialValueTemplates() {
    return this.spec.initialValueTemplates;
  }
  /** Serialize generic list
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns generic list object based on path provided in options. See {@link GenericList}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const id = this.spec.id || "";
    const path = options.path;
    const defaultLayout = this.spec.defaultLayout;
    if (defaultLayout && !layoutOptions.includes(defaultLayout)) {
      throw new SerializeError("`layout` must be one of ".concat(layoutOptions.map((item) => '"'.concat(item, '"')).join(", ")), path, id || options.index, this.spec.title);
    }
    const initialValueTemplates = (this.spec.initialValueTemplates || []).map((item, i) => maybeSerializeInitialValueTemplateItem(item, i, path));
    return { id: validateId(id, options.path, id || options.index), title: this.spec.title, i18n: this.spec.i18n, type: "genericList", defaultLayout, child: this.spec.child || noChildResolver, canHandleIntent: this.spec.canHandleIntent || shallowIntentChecker, displayOptions: this.spec.displayOptions, initialValueTemplates, menuItems: (this.spec.menuItems || []).map((item, i) => maybeSerializeMenuItem(item, i, path)), menuItemGroups: (this.spec.menuItemGroups || []).map((item, i) => maybeSerializeMenuItemGroup(item, i, path)) };
  }
};
var validateFilter = (spec, options) => {
  var _a2;
  const filter2 = ((_a2 = spec.options) == null ? void 0 : _a2.filter.trim()) || "";
  if (["*", "{"].includes(filter2[0])) {
    throw new SerializeError("`filter` cannot start with `".concat(filter2[0], "` - looks like you are providing a query, not a filter"), options.path, spec.id, spec.title).withHelpUrl(HELP_URL.QUERY_PROVIDED_FOR_FILTER);
  }
  return filter2;
};
var createDocumentChildResolverForItem = (context) => (itemId, options) => {
  var _a2;
  const parentItem = options.parent;
  const template2 = ((_a2 = options.params) == null ? void 0 : _a2.template) ? context.templates.find((tpl) => tpl.id === options.params.template) : void 0;
  const type = template2 ? template2.schemaType : parentItem.schemaTypeName || resolveTypeForDocument(context.getClient, itemId);
  return Promise.resolve(type).then((schemaType) => schemaType ? context.resolveDocumentNode({ schemaType, documentId: itemId }) : new DocumentBuilder(context).id("editor").documentId(itemId).schemaType(""));
};
var DocumentListBuilder = class _DocumentListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super();
    this._context = _context;
    this.spec = spec || {};
    this.initialValueTemplatesSpecified = Boolean(spec == null ? void 0 : spec.initialValueTemplates);
  }
  /** Set API version
  * @param apiVersion - API version
  * @returns document list builder based on the options and API version provided. See {@link DocumentListBuilder}
  */
  apiVersion(apiVersion) {
    return this.clone({ options: { ...this.spec.options || { filter: "" }, apiVersion } });
  }
  /** Get API version
  * @returns API version
  */
  getApiVersion() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.apiVersion;
  }
  /** Set Document list filter
  * @param filter - filter
  * @returns document list builder based on the options and filter provided. See {@link DocumentListBuilder}
  */
  filter(filter2) {
    return this.clone({ options: { ...this.spec.options || {}, filter: filter2 } });
  }
  /** Get Document list filter
  * @returns filter
  */
  getFilter() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.filter;
  }
  /** Set Document list schema type name
  * @param type - schema type name.
  * @returns document list builder based on the schema type name provided. See {@link DocumentListBuilder}
  */
  schemaType(type) {
    const schemaTypeName = typeof type === "string" ? type : type.name;
    return this.clone({ schemaTypeName });
  }
  /** Get Document list schema type name
  * @returns schema type name
  */
  getSchemaType() {
    return this.spec.schemaTypeName;
  }
  /** Set Document list options' parameters
  * @param params - parameters
  * @returns document list builder based on the options provided. See {@link DocumentListBuilder}
  */
  params(params) {
    return this.clone({ options: { ...this.spec.options || { filter: "" }, params } });
  }
  /** Get Document list options' parameters
  * @returns options
  */
  getParams() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.params;
  }
  /** Set Document list default ordering
  * @param ordering - default sort ordering array. See {@link SortOrderingItem}
  * @returns document list builder based on ordering provided. See {@link DocumentListBuilder}
  */
  defaultOrdering(ordering) {
    if (!Array.isArray(ordering)) {
      throw new Error("`defaultOrdering` must be an array of order clauses");
    }
    return this.clone({ options: { ...this.spec.options || { filter: "" }, defaultOrdering: ordering } });
  }
  /** Get Document list default ordering
  * @returns default ordering. See {@link SortOrderingItem}
  */
  getDefaultOrdering() {
    var _a2;
    return (_a2 = this.spec.options) == null ? void 0 : _a2.defaultOrdering;
  }
  /** Serialize Document list
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns document list object based on path provided in options. See {@link DocumentList}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    var _a2;
    if (typeof this.spec.id !== "string" || !this.spec.id) {
      throw new SerializeError("`id` is required for document lists", options.path, options.index, this.spec.title).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!this.spec.options || !this.spec.options.filter) {
      throw new SerializeError("`filter` is required for document lists", options.path, this.spec.id, this.spec.title).withHelpUrl(HELP_URL.FILTER_REQUIRED);
    }
    const hasSimpleFilter = ((_a2 = this.spec.options) == null ? void 0 : _a2.filter) === "_type == $type";
    if (!hasSimpleFilter && this.spec.options.filter && !this.spec.options.apiVersion) {
      console.warn("No apiVersion specified for document type list with custom filter: `".concat(this.spec.options.filter, "`. This will be required in the future. See %s for more info."), generateHelpUrl(HELP_URL.API_VERSION_REQUIRED_FOR_CUSTOM_FILTER));
    }
    return { ...super.serialize(options), type: "documentList", schemaTypeName: this.spec.schemaTypeName, child: this.spec.child || createDocumentChildResolverForItem(this._context), options: {
      ...this.spec.options,
      // @todo: make specifying .apiVersion required when using custom (non-simple) filters in v4
      apiVersion: this.spec.options.apiVersion || DEFAULT_STUDIO_CLIENT_OPTIONS.apiVersion,
      filter: validateFilter(this.spec, options)
    } };
  }
  /** Clone Document list builder (allows for options overriding)
  * @param withSpec - override document list spec. See {@link PartialDocumentList}
  * @returns document list builder. See {@link DocumentListBuilder}
  */
  clone(withSpec) {
    const builder = new _DocumentListBuilder(this._context);
    builder.spec = { ...this.spec, ...withSpec || {} };
    if (!this.initialValueTemplatesSpecified) {
      builder.spec.initialValueTemplates = inferInitialValueTemplates(this._context, builder.spec);
    }
    if (!builder.spec.schemaTypeName) {
      builder.spec.schemaTypeName = inferTypeName(builder.spec);
    }
    return builder;
  }
  /** Get Document list spec
  * @returns document list spec. See {@link PartialDocumentList}
  */
  getSpec() {
    return this.spec;
  }
};
function inferInitialValueTemplates(context, spec) {
  const { document: document2 } = context;
  const { schemaTypeName, options } = spec;
  const { filter: filter2, params } = options || { filter: "", params: {} };
  const typeNames = schemaTypeName ? [schemaTypeName] : Array.from(new Set(getTypeNamesFromFilter(filter2, params)));
  if (typeNames.length === 0) {
    return void 0;
  }
  return typeNames.flatMap((schemaType) => document2.resolveNewDocumentOptions({ type: "structure", schemaType })).map((option) => ({ ...option, icon: AddIcon }));
}
function inferTypeName(spec) {
  const { options } = spec;
  const { filter: filter2, params } = options || { filter: "", params: {} };
  const typeNames = getTypeNamesFromFilter(filter2, params);
  return typeNames.length === 1 ? typeNames[0] : void 0;
}
function getTypeNamesFromFilter(filter2) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let typeNames = getTypeNamesFromEqualityFilter(filter2, params);
  if (typeNames.length === 0) {
    typeNames = getTypeNamesFromInTypesFilter(filter2, params);
  }
  return typeNames;
}
function getTypeNamesFromEqualityFilter(filter2) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const pattern = /\b_type\s*==\s*(['"].*?['"]|\$.*?(?:\s|$))|\B(['"].*?['"]|\$.*?(?:\s|$))\s*==\s*_type/g;
  const matches = [];
  let match;
  while ((match = pattern.exec(filter2)) !== null) {
    matches.push(match[1] || match[2]);
  }
  return matches.map((candidate) => {
    const typeName = candidate[0] === "$" ? params[candidate.slice(1)] : candidate;
    const normalized = (typeName || "").trim().replace(/^["']|["']$/g, "");
    return normalized;
  }).filter(Boolean);
}
function getTypeNamesFromInTypesFilter(filter2) {
  let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const pattern = /\b_type\s+in\s+\[(.*?)\]/;
  const matches = filter2.match(pattern);
  if (!matches) {
    return [];
  }
  return matches[1].split(/,\s*/).map((match) => match.trim().replace(/^["']+|["']+$/g, "")).map((item) => item[0] === "$" ? params[item.slice(1)] : item).filter(Boolean);
}
var getArgType = (thing) => {
  if (thing instanceof ListBuilder) {
    return "ListBuilder";
  }
  if (isPromise(thing)) {
    return "Promise";
  }
  return Array.isArray(thing) ? "array" : typeof thing;
};
var isListItem = (item) => {
  return item.type === "listItem";
};
var defaultCanHandleIntent = (intentName, params, context) => {
  const pane = context.pane;
  const items = pane.items || [];
  return items.filter(isDocumentListItem).some((item) => item.schemaType.name === params.type && item._id === params.id) || shallowIntentChecker(intentName, params, context);
};
var resolveChildForItem = (itemId, options) => {
  const parentItem = options.parent;
  const items = parentItem.items.filter(isListItem);
  const target = (items.find((item) => item.id === itemId) || { child: void 0 }).child;
  if (!target || typeof target !== "function") {
    return target;
  }
  return typeof target === "function" ? target(itemId, options) : target;
};
function maybeSerializeListItem(item, index, path) {
  if (item instanceof ListItemBuilder) {
    return item.serialize({ path, index });
  }
  const listItem = item;
  if (listItem && listItem.type === "divider") {
    return item;
  }
  if (!listItem || listItem.type !== "listItem") {
    const gotWhat = listItem && listItem.type || getArgType(listItem);
    const helpText = gotWhat === "array" ? " - did you forget to spread (...moreItems)?" : "";
    throw new SerializeError('List items must be of type "listItem", got "'.concat(gotWhat, '"').concat(helpText), path, index).withHelpUrl(HELP_URL.INVALID_LIST_ITEM);
  }
  return item;
}
function isPromise(thing) {
  return isRecord$4(thing) && typeof thing.then === "function";
}
var ListBuilder = class _ListBuilder extends GenericListBuilder {
  constructor(_context, spec) {
    super();
    this._context = _context;
    this.spec = spec ? spec : {};
    this.initialValueTemplatesSpecified = Boolean(spec && spec.initialValueTemplates);
  }
  /**
  * Set list builder based on items provided
  * @param items - list items. See {@link ListItemBuilder}, {@link ListItem} and {@link Divider}
  * @returns list builder based on items provided. See {@link ListBuilder}
  */
  items(items) {
    return this.clone({ items });
  }
  /** Get list builder items
  * @returns list items. See {@link BuildableList}
  */
  getItems() {
    return this.spec.items;
  }
  /** Serialize list builder
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns list based on path in options. See {@link List}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const id = this.spec.id;
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for lists", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    const items = typeof this.spec.items === "undefined" ? [] : this.spec.items;
    if (!Array.isArray(items)) {
      throw new SerializeError("`items` must be an array of items", options.path, options.index).withHelpUrl(HELP_URL.LIST_ITEMS_MUST_BE_ARRAY);
    }
    const path = (options.path || []).concat(id);
    const serializedItems = items.map((item, index) => maybeSerializeListItem(item, index, path));
    const dupes = serializedItems.filter((val, i) => (0, import_find.default)(serializedItems, { id: val.id }, i + 1));
    if (dupes.length > 0) {
      const dupeIds = dupes.map((item) => item.id).slice(0, 5);
      const dupeDesc = dupes.length > 5 ? "".concat(dupeIds.join(", "), "...") : dupeIds.join(", ");
      throw new SerializeError("List items with same ID found (".concat(dupeDesc, ")"), options.path, options.index).withHelpUrl(HELP_URL.LIST_ITEM_IDS_MUST_BE_UNIQUE);
    }
    return { ...super.serialize(options), type: "list", canHandleIntent: this.spec.canHandleIntent || defaultCanHandleIntent, child: this.spec.child || resolveChildForItem, items: serializedItems };
  }
  /**
  * Clone list builder and return new list builder based on context and spec provided
  * @param withSpec - list options. See {@link BuildableList}
  * @returns new list builder based on context and spec provided. See {@link ListBuilder}
  */
  clone(withSpec) {
    const builder = new _ListBuilder(this._context);
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
var ListItemBuilder = class _ListItemBuilder {
  constructor(_context, spec) {
    this._context = _context;
    this.spec = spec ? spec : {};
  }
  /**
  * Set list item ID
  * @returns list item builder based on ID provided. See {@link ListItemBuilder}
  */
  id(id) {
    return this.clone({ id });
  }
  /**
  * Get list item ID
  * @returns list item ID. See {@link PartialListItem}
  */
  getId() {
    return this.spec.id;
  }
  /**
  * Set list item title
  * @returns list item builder based on title provided. See {@link ListItemBuilder}
  */
  title(title) {
    return this.clone({ title, id: getStructureNodeId(title, this.spec.id) });
  }
  /**
  * Get list item title
  * @returns list item title. See {@link PartialListItem}
  */
  getTitle() {
    return this.spec.title;
  }
  /** Set the i18n key and namespace used to populate the localized title.
  * @param i18n - the key and namespaced used to populate the localized title.
  * @returns component builder based on i18n key and ns provided
  */
  i18n(i18n) {
    return this.clone({ i18n });
  }
  /** Get i18n key and namespace used to populate the localized title
  * @returns the i18n key and namespace used to populate the localized title
  */
  getI18n() {
    return this.spec.i18n;
  }
  /**
  * Set list item icon
  * @returns list item builder based on icon provided. See {@link ListItemBuilder}
  */
  icon(icon) {
    return this.clone({ icon });
  }
  /**
  * Set if list item should show icon
  * @returns list item builder based on showIcon provided. See {@link ListItemBuilder}
  */
  showIcon() {
    let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
    return this.clone({ displayOptions: { ...this.spec.displayOptions || {}, showIcon: enabled } });
  }
  /**
  * Check if list item should show icon
  * @returns true if it should show the icon, false if not, undefined if not set
  */
  getShowIcon() {
    return this.spec.displayOptions ? this.spec.displayOptions.showIcon : void 0;
  }
  /**
  *Get list item icon
  * @returns list item icon. See {@link PartialListItem}
  */
  getIcon() {
    return this.spec.icon;
  }
  /**
  * Set list item child
  * @param child - list item child. See {@link UnserializedListItemChild}
  * @returns list item builder based on child provided. See {@link ListItemBuilder}
  */
  child(child) {
    return this.clone({ child });
  }
  /**
  * Get list item child
  * @returns list item child. See {@link PartialListItem}
  */
  getChild() {
    return this.spec.child;
  }
  /**
  * Set list item schema type
  * @param schemaType - list item schema type. See {@link SchemaType}
  * @returns list item builder based on schema type provided. See {@link ListItemBuilder}
  */
  schemaType(schemaType) {
    return this.clone({ schemaType });
  }
  /**
  * Get list item schema type
  * @returns list item schema type. See {@link PartialListItem}
  */
  getSchemaType() {
    const schemaType = this.spec.schemaType;
    if (typeof schemaType === "string") {
      return this._context.schema.get(schemaType);
    }
    return this.spec.schemaType;
  }
  /** Serialize list item builder
  * @param options - serialization options. See {@link ListItemSerializeOptions}
  * @returns list item node based on path provided in options. See {@link ListItem}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const { id, title, child } = this.spec;
    if (typeof id !== "string" || !id) {
      throw new SerializeError("`id` is required for list items", options.path, options.index).withHelpUrl(HELP_URL.ID_REQUIRED);
    }
    if (!options.titleIsOptional && (typeof title !== "string" || !title)) {
      throw new SerializeError("`title` is required for list items", options.path, id).withHelpUrl(HELP_URL.TITLE_REQUIRED);
    }
    let schemaType = this.spec.schemaType;
    if (typeof schemaType === "string") {
      const type = this._context.schema.get(schemaType);
      if (!type) {
        throw new SerializeError('Could not find type "'.concat(schemaType, '" in schema'), options.path, id).withHelpUrl(HELP_URL.SCHEMA_TYPE_NOT_FOUND);
      }
      schemaType = type;
    }
    const serializeOptions = { path: options.path.concat(id), hint: "child" };
    let listChild = child instanceof ComponentBuilder || child instanceof DocumentListBuilder || child instanceof DocumentBuilder || child instanceof ListBuilder ? child.serialize(serializeOptions) : child;
    if (typeof listChild === "function") {
      const originalChild = listChild;
      listChild = (itemId, childOptions) => {
        return originalChild(itemId, { ...childOptions, serializeOptions });
      };
    }
    return { ...this.spec, id: validateId(id, options.path, options.index), schemaType, child: listChild, title, type: "listItem" };
  }
  /** Clone list item builder
  * @param withSpec - partial list item options. See {@link PartialListItem}
  * @returns list item builder based on context and spec provided. See {@link ListItemBuilder}
  */
  clone(withSpec) {
    const builder = new _ListItemBuilder(this._context);
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
var createDefaultChildResolver = (context, spec) => (documentId) => {
  const schemaType = spec.schemaType && (typeof spec.schemaType === "string" ? spec.schemaType : spec.schemaType.name);
  return schemaType ? context.resolveDocumentNode({ schemaType, documentId }) : new DocumentBuilder(context).id("documentEditor").documentId(documentId);
};
var DocumentListItemBuilder = class _DocumentListItemBuilder extends ListItemBuilder {
  constructor(_context, spec) {
    super(_context, spec);
    this._context = _context;
    this.spec = spec ? spec : {};
  }
  /**
  * Serialize document list item
  * @param options - serialization options. See {@link SerializeOptions}
  * @returns document list item object based on path provided in options. See {@link DocumentListItem}
  */
  serialize() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { path: [] };
    const spec = super.serialize({ ...options, titleIsOptional: true });
    if (!spec.schemaType) {
      throw new SerializeError("`schemaType` is required for document list items", options.path, options.index).withHelpUrl(HELP_URL.SCHEMA_TYPE_REQUIRED);
    }
    const child = spec.child || createDefaultChildResolver(this._context, spec);
    return { ...spec, child, schemaType: spec.schemaType, _id: spec.id };
  }
  /** Clone Document list item builder (allows for options overriding)
  * @param withSpec - Document list item builder options. See {@link PartialDocumentListItem}
  * @returns document list item builder. See {@link DocumentListItemBuilder}
  */
  clone(withSpec) {
    const builder = new _DocumentListItemBuilder(this._context);
    builder.spec = { ...this.spec, ...withSpec || {} };
    return builder;
  }
};
function isDocumentListItem(item) {
  return isRecord$4(item) && typeof item.schemaType !== "undefined" && typeof item._id === "string";
}
var DocumentTypeListBuilder = class _DocumentTypeListBuilder extends DocumentListBuilder {
  constructor(_context, spec) {
    super(_context);
    this._context = _context;
    this.spec = spec ? spec : {};
  }
  /**
  * Set Document type list child
  * @param child - Child component. See {@link Child}
  * @returns document type list builder based on child component provided without default intent handler. See {@link DocumentTypeListBuilder}
  */
  child(child) {
    return this.cloneWithoutDefaultIntentHandler({ child });
  }
  /** Clone Document type list builder (allows for options overriding)
  * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
  * @returns document type list builder. See {@link DocumentTypeListBuilder}
  */
  clone(withSpec) {
    const parent = super.clone(withSpec);
    const builder = new _DocumentTypeListBuilder(this._context);
    builder.spec = { ...this.spec, ...parent.getSpec(), ...withSpec || {} };
    return builder;
  }
  /** Clone Document type list builder (allows for options overriding) and remove default intent handler
  * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
  * @returns document type list builder without default intent handler. See {@link DocumentTypeListBuilder}
  */
  cloneWithoutDefaultIntentHandler(withSpec) {
    const parent = super.clone(withSpec);
    const builder = new _DocumentTypeListBuilder(this._context);
    const canHandleIntent = this.spec.canHandleIntent;
    const shouldOverride = canHandleIntent && canHandleIntent.identity === DEFAULT_INTENT_HANDLER;
    const override = shouldOverride ? { canHandleIntent: void 0 } : {};
    builder.spec = { ...parent.getSpec(), ...this.spec, ...withSpec || {}, ...override };
    return builder;
  }
};
var BUNDLED_DOC_TYPES = ["sanity.imageAsset", "sanity.fileAsset"];
function isBundledDocType(typeName) {
  return BUNDLED_DOC_TYPES.includes(typeName);
}
function isDocumentType(schemaType) {
  var _a2;
  return ((_a2 = schemaType.type) == null ? void 0 : _a2.name) === "document";
}
function isList(collection) {
  return collection.type === "list";
}
function getDocumentTypes(_ref120) {
  let { schema: schema2 } = _ref120;
  return schema2.getTypeNames().filter((n) => {
    const schemaType = schema2.get(n);
    return schemaType && isDocumentType(schemaType);
  }).filter((n) => !isBundledDocType(n));
}
function getDocumentTypeListItems(context) {
  const types = getDocumentTypes(context);
  return types.map((typeName) => getDocumentTypeListItem(context, typeName));
}
function getDocumentTypeListItem(context, typeName) {
  const { schema: schema2 } = context;
  const type = schema2.get(typeName);
  if (!type) {
    throw new Error('Schema type with name "'.concat(typeName, '" not found'));
  }
  const title = type.title || (0, import_startCase.default)(typeName);
  return new ListItemBuilder(context).id(typeName).title(title).schemaType(type).child((id, childContext) => {
    const parent = childContext.parent;
    const parentItem = isList(parent) ? parent.items.find((item) => item.id === id) : null;
    let list = getDocumentTypeList(context, typeName);
    if (parentItem && parentItem.title) {
      list = list.title(parentItem.title);
    }
    return list;
  });
}
function getDocumentTypeList(context, typeNameOrSpec) {
  const { schema: schema2, resolveDocumentNode } = context;
  const schemaType = typeof typeNameOrSpec === "string" ? typeNameOrSpec : typeNameOrSpec.schemaType;
  const typeName = typeof schemaType === "string" ? schemaType : schemaType.name;
  const spec = typeof typeNameOrSpec === "string" ? { schemaType } : typeNameOrSpec;
  const type = schema2.get(typeName);
  if (!type) {
    throw new Error('Schema type with name "'.concat(typeName, '" not found'));
  }
  const title = type.title || (0, import_startCase.default)(typeName);
  return new DocumentTypeListBuilder(context).id(spec.id || typeName).title(spec.title || title).filter("_type == $type").params({ type: typeName }).schemaType(type).defaultOrdering(DEFAULT_SELECTED_ORDERING_OPTION.by).menuItemGroups(spec.menuItemGroups || [{ id: "sorting", title: "Sort", i18n: { title: { key: "menu-item-groups.actions-group", ns: structureLocaleNamespace } } }, { id: "layout", title: "Layout", i18n: { title: { key: "menu-item-groups.layout-group", ns: structureLocaleNamespace } } }, { id: "actions", title: "Actions", i18n: { title: { key: "menu-item-groups.sorting-group", ns: structureLocaleNamespace } } }]).child(spec.child || ((documentId) => resolveDocumentNode({ schemaType: typeName, documentId }))).canHandleIntent(spec.canHandleIntent || defaultIntentChecker).menuItems(spec.menuItems || [
    // Create new (from action button) will be added in serialization step of GenericList
    // Sort by <Y>
    ...getOrderingMenuItemsForSchemaType(context, type),
    // Display as <Z>
    new MenuItemBuilder(context).group("layout").i18n({ title: { key: "menu-items.layout.compact-view", ns: structureLocaleNamespace } }).title("Compact view").icon(StackCompactIcon).action("setLayout").params({ layout: "default" }),
    new MenuItemBuilder(context).group("layout").i18n({ title: { key: "menu-items.layout.detailed-view", ns: structureLocaleNamespace } }).title("Detailed view").icon(StackIcon).action("setLayout").params({ layout: "detail" })
    // Create new (from menu) will be added in serialization step of GenericList
  ]);
}
function hasIcon(schemaType) {
  if (!schemaType || typeof schemaType === "string") {
    return false;
  }
  return Boolean(schemaType.icon);
}
function getDefaultStructure(context) {
  const items = getDocumentTypeListItems(context);
  return new ListBuilder(context).id("__root__").title("Content").i18n({ title: { key: "default-definition.content-title", ns: structureLocaleNamespace } }).items(items).showIcons(items.some((item) => hasIcon(item.getSchemaType())));
}
function createStructureBuilder(_ref121) {
  let { defaultDocumentNode, source } = _ref121;
  const configContext = getConfigContextFromSource(source);
  const context = { ...source, getStructureBuilder: () => structureBuilder, resolveDocumentNode: (options) => {
    let builder = (defaultDocumentNode == null ? void 0 : defaultDocumentNode(structureBuilder, { ...options, ...configContext })) || new DocumentBuilder(context);
    if (!builder.getId()) {
      builder = builder.id("documentEditor");
    }
    if (options.documentId) {
      builder = builder.documentId(getPublishedId(options.documentId));
    }
    return builder.schemaType(options.schemaType);
  } };
  const structureBuilder = { defaults: () => getDefaultStructure(context), documentTypeList: function() {
    for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return getDocumentTypeList(context, ...args);
  }, documentTypeListItem: function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return getDocumentTypeListItem(context, ...args);
  }, documentTypeListItems: function() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return getDocumentTypeListItems(context, ...args);
  }, document: function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return new DocumentBuilder(context, ...args);
  }, documentWithInitialValueTemplate: function() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
      args[_key6] = arguments[_key6];
    }
    return documentFromEditorWithInitialValue(context, ...args);
  }, defaultDocument: context.resolveDocumentNode, list: function() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key7 = 0; _key7 < _len6; _key7++) {
      args[_key7] = arguments[_key7];
    }
    return new ListBuilder(context, ...args);
  }, listItem: function() {
    for (var _len7 = arguments.length, args = new Array(_len7), _key8 = 0; _key8 < _len7; _key8++) {
      args[_key8] = arguments[_key8];
    }
    return new ListItemBuilder(context, ...args);
  }, menuItem: function() {
    for (var _len8 = arguments.length, args = new Array(_len8), _key9 = 0; _key9 < _len8; _key9++) {
      args[_key9] = arguments[_key9];
    }
    return new MenuItemBuilder(context, ...args);
  }, menuItemGroup: function() {
    for (var _len9 = arguments.length, args = new Array(_len9), _key10 = 0; _key10 < _len9; _key10++) {
      args[_key10] = arguments[_key10];
    }
    return new MenuItemGroupBuilder(context, ...args);
  }, menuItemsFromInitialValueTemplateItems: function() {
    for (var _len10 = arguments.length, args = new Array(_len10), _key11 = 0; _key11 < _len10; _key11++) {
      args[_key11] = arguments[_key11];
    }
    return menuItemsFromInitialValueTemplateItems(context, ...args);
  }, documentList: function() {
    for (var _len11 = arguments.length, args = new Array(_len11), _key12 = 0; _key12 < _len11; _key12++) {
      args[_key12] = arguments[_key12];
    }
    return new DocumentListBuilder(context, ...args);
  }, documentListItem: function() {
    for (var _len12 = arguments.length, args = new Array(_len12), _key13 = 0; _key13 < _len12; _key13++) {
      args[_key13] = arguments[_key13];
    }
    return new DocumentListItemBuilder(context, ...args);
  }, orderingMenuItem: function() {
    for (var _len13 = arguments.length, args = new Array(_len13), _key14 = 0; _key14 < _len13; _key14++) {
      args[_key14] = arguments[_key14];
    }
    return getOrderingMenuItem(context, ...args);
  }, orderingMenuItemsForType: function() {
    for (var _len14 = arguments.length, args = new Array(_len14), _key15 = 0; _key15 < _len14; _key15++) {
      args[_key15] = arguments[_key15];
    }
    return getOrderingMenuItemsForSchemaType(context, ...args);
  }, editor: function() {
    for (var _len15 = arguments.length, args = new Array(_len15), _key16 = 0; _key16 < _len15; _key16++) {
      args[_key16] = arguments[_key16];
    }
    return documentFromEditor(context, ...args);
  }, defaultInitialValueTemplateItems: function() {
    for (var _len16 = arguments.length, args = new Array(_len16), _key17 = 0; _key17 < _len16; _key17++) {
      args[_key17] = arguments[_key17];
    }
    return defaultInitialValueTemplateItems(context, ...args);
  }, initialValueTemplateItem: (templateId, parameters) => new InitialValueTemplateItemBuilder(context, { id: templateId, parameters, templateId }), component: (spec) => {
    return (0, import_react_is.isValidElementType)(spec) ? new ComponentBuilder().component(spec) : new ComponentBuilder(spec);
  }, divider: () => ({ id: (0, import_uniqueId.default)("__divider__"), type: "divider" }), view: views, context };
  return structureBuilder;
}
var API_VERSION = "2024-03-05";
function ConfigErrorsScreen() {
  return (0, import_jsx_runtime.jsx)("div", { children: "Config errors" });
}
function CurrentWorkspaceProvider(_ref122) {
  let { children } = _ref122;
  return (0, import_jsx_runtime.jsx)(WorkspaceLoaderBoundary, { LoadingComponent: LoadingBlock, ConfigErrorsComponent: ConfigErrorsScreen, children });
}
function getTargetValue(_ref123) {
  let { documentId, documentType, dataset, projectId } = _ref123;
  return { documentType, document: { _ref: getPublishedId(documentId), _type: "crossDatasetReference", _dataset: dataset, _projectId: projectId, _weak: true } };
}
function getMentionedUsers(description) {
  if (!description)
    return [];
  const subscribers = [];
  description == null ? void 0 : description.forEach((block) => {
    if (isPortableTextTextBlock(block)) {
      block.children.forEach((child) => {
        if (child._type === "mention" && typeof child.userId === "string" && !subscribers.includes(child.userId)) {
          subscribers.push(child.userId);
        }
      });
    }
  });
  return subscribers;
}
var FIELDS_TO_GROUP = ["title", "description", "target"];
var GROUP_TIME = 2 * 60 * 1e3;
function groupChanges(changes) {
  const groupedChanges = [];
  for (const change of changes) {
    const lastChangeProcessed = groupedChanges[groupedChanges.length - 1];
    if (!lastChangeProcessed) {
      groupedChanges.push(change);
      continue;
    }
    if (!FIELDS_TO_GROUP.includes(change.field)) {
      groupedChanges.push(change);
      continue;
    }
    if (lastChangeProcessed.author === change.author && lastChangeProcessed.field === change.field) {
      const lastChangeDate = new Date(lastChangeProcessed.timestamp);
      const changeDate = new Date(change.timestamp);
      const diff2 = Math.abs(lastChangeDate.getTime() - changeDate.getTime());
      if (diff2 <= GROUP_TIME) {
        lastChangeProcessed.to = change.to;
        lastChangeProcessed.timestamp = change.timestamp;
        continue;
      }
    }
    groupedChanges.push(change);
  }
  return groupedChanges;
}
function omitRev(document2) {
  const { _rev, ...doc } = document2;
  return doc;
}
function trackFieldChanges(newestDocument, transactions, fieldsToTrack) {
  let currentDocument = omitRev(newestDocument);
  const changes = [];
  let previousDocument = currentDocument;
  for (const transaction of transactions) {
    const { timestamp, effects } = transaction;
    const documentId = transaction.documentIDs[0];
    const effect = effects[documentId];
    if (!effect || !effect.revert)
      continue;
    previousDocument = applyPatch(currentDocument, effect.revert);
    fieldsToTrack.forEach((field) => {
      if ((previousDocument == null ? void 0 : previousDocument[field]) !== (currentDocument == null ? void 0 : currentDocument[field])) {
        changes.push({ field, from: previousDocument == null ? void 0 : previousDocument[field], to: currentDocument == null ? void 0 : currentDocument[field], timestamp, author: transaction.author });
      }
    });
    currentDocument = previousDocument;
  }
  const changesSortedByTimestamp = changes.sort((a, b) => a.timestamp.localeCompare(b.timestamp));
  const createdByUserIndex = changesSortedByTimestamp.findIndex((change) => change.field === "createdByUser");
  return groupChanges(changesSortedByTimestamp.slice(createdByUserIndex + 1));
}
var TASK_STATUS = [{ value: "open", title: "To Do", icon: (0, import_jsx_runtime.jsx)(CircleIcon, {}) }, { value: "closed", title: "Done", icon: (0, import_jsx_runtime.jsx)(CheckmarkCircleIcon, {}) }];
function useDocumentPreviewValues(options) {
  var _a2;
  const { documentId, documentType } = options || {};
  const schemaType = useSchema().get(documentType);
  const documentPreviewStore = useDocumentPreviewStore();
  const previewState = useMemoObservable(() => {
    if (!documentId || !schemaType)
      return of(null);
    return getPreviewStateObservable(documentPreviewStore, schemaType, documentId, "");
  }, [documentId, documentPreviewStore, schemaType]);
  const isLoading = (_a2 = previewState == null ? void 0 : previewState.isLoading) != null ? _a2 : true;
  const { published, draft } = previewState || {};
  const documentTitle = (draft == null ? void 0 : draft.title) || (published == null ? void 0 : published.title);
  const subtitle = (draft == null ? void 0 : draft.subtitle) || (published == null ? void 0 : published.subtitle);
  const description = (draft == null ? void 0 : draft.description) || (published == null ? void 0 : published.description);
  const media = (draft == null ? void 0 : draft.media) || (published == null ? void 0 : published.media);
  return { isLoading, value: { title: documentTitle, subtitle, media, description } };
}
var __freeze$i = Object.freeze;
var __defProp$i = Object.defineProperty;
var __template$i = (cooked, raw) => __freeze$i(__defProp$i(cooked, "raw", { value: __freeze$i(raw || cooked.slice()) }));
var _a$i;
var _b$6;
var DATE_FORMAT_OPTIONS = { month: "long", day: "2-digit", minute: "2-digit", hour: "2-digit", second: "2-digit" };
var RELATIVE_TIME_OPTIONS = { minimal: true, useTemporalPhrase: true };
var Strong = ut.strong(_a$i || (_a$i = __template$i(["\n  font-weight: 600;\n"])));
function UpdatedTimeAgo(timestamp) {
  const date = new Date(timestamp);
  const dateFormatter = useDateTimeFormat(DATE_FORMAT_OPTIONS);
  const formattedDate = dateFormatter.format(date);
  const updatedTimeAgo = useRelativeTime(date || "", RELATIVE_TIME_OPTIONS);
  return { timeAgo: updatedTimeAgo, formattedDate };
}
function UserName(_ref124) {
  let { userId } = _ref124;
  const [user, isLoading] = useUser(userId);
  return isLoading ? (0, import_jsx_runtime.jsx)(TextSkeleton, { style: { width: "15ch" } }) : (0, import_jsx_runtime.jsx)(Strong, { children: user == null ? void 0 : user.displayName });
}
var DUE_BY_DATE_OPTIONS = { month: "short", day: "numeric" };
function DueByChange(_ref125) {
  let { date } = _ref125;
  const dueBy = new Date(date);
  const dateFormatter = useDateTimeFormat(DUE_BY_DATE_OPTIONS);
  const formattedDate = dateFormatter.format(dueBy);
  return (0, import_jsx_runtime.jsx)(Strong, { children: formattedDate });
}
var LinkWrapper = ut.span(_b$6 || (_b$6 = __template$i(["\n  > a {\n    color: var(--card-fg-muted-color);\n    text-decoration: underline;\n    text-underline-offset: 1px;\n    font-weight: 600;\n  }\n"])));
function TargetContentChange(_ref126) {
  let { target } = _ref126;
  const schema2 = useSchema();
  const documentId = target.document._ref;
  const documentType = target.documentType;
  const documentSchema = schema2.get(documentType);
  const { isLoading, value } = useDocumentPreviewValues({ documentId, documentType });
  if (isLoading) {
    return (0, import_jsx_runtime.jsx)(TextSkeleton, { style: { width: "15ch" } });
  }
  if (!documentSchema) {
    return null;
  }
  return (0, import_jsx_runtime.jsx)(LinkWrapper, { children: (0, import_jsx_runtime.jsx)(IntentLink, { intent: "edit", params: { id: documentId, type: documentType }, children: value == null ? void 0 : value.title }) });
}
function getChangeDetails(activity) {
  var _a2, _b2;
  switch (activity.field) {
    case "status": {
      const statusTitle = (_a2 = TASK_STATUS.find((s) => s.value === activity.to)) == null ? void 0 : _a2.title;
      return { text: "changed status to", icon: ((_b2 = TASK_STATUS.find((s) => s.value === activity.to)) == null ? void 0 : _b2.icon) || (0, import_jsx_runtime.jsx)(CircleIcon, {}), changeTo: (0, import_jsx_runtime.jsx)(Strong, { children: statusTitle }) };
    }
    case "target":
      if (!activity.to)
        return { text: "removed target content", icon: (0, import_jsx_runtime.jsx)(LinkIcon, {}), changeTo: void 0 };
      return { text: "set target content to", icon: (0, import_jsx_runtime.jsx)(LinkIcon, {}), changeTo: (0, import_jsx_runtime.jsx)(TargetContentChange, { target: activity.to }) };
    case "dueBy":
      if (!activity.from) {
        return { text: "set the due date to", icon: (0, import_jsx_runtime.jsx)(CalendarIcon, {}), changeTo: (0, import_jsx_runtime.jsx)(DueByChange, { date: activity.to }) };
      }
      if (!activity.to) {
        return { text: "removed the due date", icon: (0, import_jsx_runtime.jsx)(CalendarIcon, {}), changeTo: void 0 };
      }
      return { text: "changed the due date to", icon: (0, import_jsx_runtime.jsx)(CalendarIcon, {}), changeTo: (0, import_jsx_runtime.jsx)(DueByChange, { date: activity.to }) };
    case "assignedTo":
      if (!activity.to) {
        return { text: "unassigned this task", icon: (0, import_jsx_runtime.jsx)(UserIcon, {}), changeTo: void 0 };
      }
      return { text: "assigned to", icon: (0, import_jsx_runtime.jsx)(UserIcon, {}), changeTo: (0, import_jsx_runtime.jsx)(UserName, { userId: activity.to }) };
    case "description":
      return { text: "updated the task description", icon: (0, import_jsx_runtime.jsx)(EditIcon, {}), changeTo: void 0 };
    case "title":
      return { text: "updated the task title", icon: (0, import_jsx_runtime.jsx)(EditIcon, {}), changeTo: void 0 };
    default:
      return { text: "", icon: (0, import_jsx_runtime.jsx)(CircleIcon, {}) };
  }
}
var EditedAt = (0, import_react2.memo)(function EditedAt2(props) {
  const { activity } = props;
  const { formattedDate, timeAgo } = UpdatedTimeAgo(activity.timestamp);
  const { icon, text, changeTo } = getChangeDetails(activity);
  return (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, children: [(0, import_jsx_runtime.jsx)(Box, { marginTop: 1, marginLeft: 1, marginRight: 3, children: (0, import_jsx_runtime.jsx)(Box, { marginRight: 1, children: (0, import_jsx_runtime.jsx)(Text, { children: icon }) }) }), (0, import_jsx_runtime.jsxs)(Text, { muted: true, size: 1, children: [(0, import_jsx_runtime.jsx)(UserName, { userId: activity.author }), " ", text, " ", changeTo, " •", " ", (0, import_jsx_runtime.jsx)(Tooltip, { content: formattedDate, placement: "top-end", children: (0, import_jsx_runtime.jsx)("time", { dateTime: formattedDate, children: timeAgo }) })] })] });
}, (prevProps, nextProps) => {
  return prevProps.activity.timestamp === nextProps.activity.timestamp;
});
var __freeze$h = Object.freeze;
var __defProp$h = Object.defineProperty;
var __template$h = (cooked, raw) => __freeze$h(__defProp$h(cooked, "raw", { value: __freeze$h(raw || cooked.slice()) }));
var _a$h;
var _b$5;
var AvatarRoot = ut.div((props) => {
  var _a2, _b2;
  const theme = getTheme_v2(props.theme);
  return at(_a$h || (_a$h = __template$h(["\n      min-height: ", "px;\n      min-width: ", "px;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      border-radius: 50%;\n      ", ";\n      ", "\n    "])), (_a2 = theme.avatar.sizes[props.$size]) == null ? void 0 : _a2.size, (_b2 = theme.avatar.sizes[props.$size]) == null ? void 0 : _b2.size, props.$border ? "box-shadow: inset 0 0 0 1px var(--card-border-color);" : "", props.$removeBg ? "--card-avatar-gray-bg-color: transparent;" : "");
});
var AvatarSkeleton = ut(Skeleton)((props) => {
  var _a2, _b2;
  const theme = getTheme_v2(props.theme);
  return at(_b$5 || (_b$5 = __template$h(["\n    height: ", "px;\n    width: ", "px;\n    border-radius: 50%;\n  "])), (_a2 = theme.avatar.sizes[props.$size]) == null ? void 0 : _a2.size, (_b2 = theme.avatar.sizes[props.$size]) == null ? void 0 : _b2.size);
});
function TasksUserAvatar(props) {
  const { user, size = 0, border = true } = props;
  const [loadedUser, loading] = useUser((user == null ? void 0 : user.id) || "");
  if (loading) {
    return (0, import_jsx_runtime.jsx)(AvatarSkeleton, { $size: size, animated: true });
  }
  if (!user || !loadedUser) {
    return (0, import_jsx_runtime.jsx)(AvatarRoot, { $size: size, $border: border, children: (0, import_jsx_runtime.jsx)(Text, { size, children: (0, import_jsx_runtime.jsx)(UserIcon, {}) }) });
  }
  return (0, import_jsx_runtime.jsx)(AvatarRoot, { $size: size, $removeBg: !!(loadedUser == null ? void 0 : loadedUser.imageUrl), children: (0, import_jsx_runtime.jsx)(UserAvatar, { user: loadedUser, size, ...(loadedUser == null ? void 0 : loadedUser.imageUrl) ? { color: void 0 } : {} }) });
}
var __freeze$g = Object.freeze;
var __defProp$g = Object.defineProperty;
var __template$g = (cooked, raw) => __freeze$g(__defProp$g(cooked, "raw", { value: __freeze$g(raw || cooked.slice()) }));
var _a$g;
var ActivityItemChildrenContainer = ut.div(_a$g || (_a$g = __template$g(["\n  width: 100%;\n"])));
function ActivityItem(_ref127) {
  let { userId, children } = _ref127;
  return (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, children: [(0, import_jsx_runtime.jsx)(Box, { marginRight: 3, paddingTop: 1, children: (0, import_jsx_runtime.jsx)(TasksUserAvatar, { user: { id: userId }, size: 0 }) }), (0, import_jsx_runtime.jsx)(ActivityItemChildrenContainer, { children })] });
}
function TasksActivityCommentInput(props) {
  const { mentionOptions, currentUser, onSubmit } = props;
  const [value, setValue] = (0, import_react2.useState)(null);
  const editorRef = (0, import_react2.useRef)(null);
  const hasValue = (0, import_react2.useMemo)(() => hasCommentMessageValue(value), [value]);
  const handleChange = (0, import_react2.useCallback)((nextValue) => {
    setValue(nextValue);
  }, []);
  const handleSubmit = (0, import_react2.useCallback)(() => {
    if (hasValue) {
      onSubmit(value);
      setValue(null);
    }
  }, [hasValue, onSubmit, value]);
  const handleDiscardCancel = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = editorRef.current) == null ? void 0 : _a2.discardDialogController.close();
  }, []);
  const handleDiscardConfirm = (0, import_react2.useCallback)(() => {
    var _a2;
    (_a2 = editorRef.current) == null ? void 0 : _a2.discardDialogController.close();
    setValue(null);
  }, []);
  const handleKeyDown = (0, import_react2.useCallback)((e2) => {
    var _a2, _b2;
    if (e2.key === "Escape") {
      e2.preventDefault();
      e2.stopPropagation();
      if (hasValue) {
        (_a2 = editorRef.current) == null ? void 0 : _a2.discardDialogController.open();
      } else {
        (_b2 = editorRef.current) == null ? void 0 : _b2.discardDialogController.close();
        setValue(null);
      }
    }
  }, [hasValue]);
  return (0, import_jsx_runtime.jsx)(ActivityItem, { userId: currentUser.id, children: (0, import_jsx_runtime.jsx)(Card, { tone: "transparent", radius: 3, paddingY: 1, paddingX: 2, children: (0, import_jsx_runtime.jsx)(CommentInput, { withAvatar: false, currentUser, expandOnFocus: true, mentionOptions, onChange: handleChange, onDiscardConfirm: handleDiscardConfirm, onDiscardCancel: handleDiscardCancel, onKeyDown: handleKeyDown, onSubmit: handleSubmit, placeholder: "Add a comment...", ref: editorRef, value }) }) });
}
var __freeze$f = Object.freeze;
var __defProp$f = Object.defineProperty;
var __template$f = (cooked, raw) => __freeze$f(__defProp$f(cooked, "raw", { value: __freeze$f(raw || cooked.slice()) }));
var _a$f;
var UserSkeleton = ut(TextSkeleton)(_a$f || (_a$f = __template$f(["\n  max-width: 15ch;\n  width: '100%';\n"])));
var TasksActivityCreatedAt = (0, import_react2.memo)(function TasksActivityCreatedAt2(props) {
  var _a2;
  const { createdAt, authorId } = props;
  const [user, loading] = useUser(authorId);
  const { timeAgo, formattedDate } = UpdatedTimeAgo(createdAt);
  return (0, import_jsx_runtime.jsx)(ActivityItem, { userId: authorId, children: (0, import_jsx_runtime.jsx)(Flex, { align: "center", paddingTop: 1, children: (0, import_jsx_runtime.jsxs)(Text, { size: 1, muted: true, children: [(0, import_jsx_runtime.jsxs)("strong", { style: { fontWeight: 600 }, children: [loading ? (0, import_jsx_runtime.jsx)(UserSkeleton, {}) : (_a2 = user == null ? void 0 : user.displayName) != null ? _a2 : "Unknown user", " "] }), "created this task •", " ", (0, import_jsx_runtime.jsx)(Tooltip, { content: formattedDate, placement: "top-end", children: (0, import_jsx_runtime.jsx)("time", { dateTime: createdAt, children: timeAgo }) })] }) }) });
}, (prevProps, nextProps) => {
  return prevProps.createdAt === nextProps.createdAt;
});
function TasksSubscribers(props) {
  var _a2, _b2;
  const { value, onChange, path, currentUserId } = props;
  const userIsSubscribed = (_a2 = value.subscribers) == null ? void 0 : _a2.includes(currentUserId);
  const buttonText = userIsSubscribed ? "Unsubscribe" : "Subscribe";
  const handleToggleSubscribe = (0, import_react2.useCallback)(() => {
    const subscribers = value.subscribers || [];
    if (!subscribers.includes(currentUserId)) {
      onChange(set(subscribers.concat(currentUserId), path));
    }
    if (subscribers.includes(currentUserId)) {
      onChange(set(subscribers.filter((subscriberId) => subscriberId !== currentUserId), path));
    }
  }, [value.subscribers, currentUserId, onChange, path]);
  return (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, align: "center", children: [(0, import_jsx_runtime.jsx)(Button2, { mode: "bleed", text: buttonText, onClick: handleToggleSubscribe }), value.subscribers && ((_b2 = value.subscribers) == null ? void 0 : _b2.length) > 0 && (0, import_jsx_runtime.jsx)(TasksSubscriberAvatars, { subscriberIds: value.subscribers })] });
}
function TasksSubscriberAvatars(props) {
  const { subscriberIds } = props;
  return (0, import_jsx_runtime.jsx)(AnimatePresence, { initial: false, children: (0, import_jsx_runtime.jsx)(AvatarStack, { maxLength: 3, size: 0, children: subscriberIds && subscriberIds.map((subscriberId) => (0, import_jsx_runtime.jsx)(motion.div, { exit: { opacity: 0, translateX: "2px", scale: 0.9 }, animate: { opacity: 1, translateX: 0, scale: 1, transition: { type: "just", duration: 0.2 } }, initial: { opacity: 0, translateX: "2px", scale: 0.9 }, children: (0, import_jsx_runtime.jsx)(TasksUserAvatar, { user: { id: subscriberId }, size: 0 }) }, subscriberId)) }) });
}
var __freeze$e = Object.freeze;
var __defProp$e = Object.defineProperty;
var __template$e = (cooked, raw) => __freeze$e(__defProp$e(cooked, "raw", { value: __freeze$e(raw || cooked.slice()) }));
var _a$e;
function useActivityLog(task) {
  const [changes, setChanges] = (0, import_react2.useState)([]);
  const client = useClient({ apiVersion: API_VERSION });
  const { dataset, token } = client.config();
  const queryParams = "tag=sanity.studio.tasks.history&effectFormat=mendoza&excludeContent=true&includeIdentifiedDocumentsOnly=true&reverse=true";
  const transactionsUrl = client.getUrl("/data/history/".concat(dataset, "/transactions/").concat(getPublishedId(task._id), "?").concat(queryParams));
  const fetchAndParse = (0, import_react2.useCallback)(async (newestTaskDocument) => {
    try {
      const transactions = [];
      const stream = await getJsonStream(transactionsUrl, token);
      const reader = stream.getReader();
      let result;
      for (; ; ) {
        result = await reader.read();
        if (result.done) {
          break;
        }
        if ("error" in result.value) {
          throw new Error(result.value.error.description || result.value.error.type);
        }
        transactions.push(result.value);
      }
      const fieldsToTrack = ["createdByUser", "title", "description", "dueBy", "assignedTo", "status", "target"];
      const parsedChanges = await trackFieldChanges(newestTaskDocument, [...transactions], fieldsToTrack);
      setChanges(parsedChanges);
    } catch (error) {
      console.error("Failed to fetch and parse activity log", error);
    }
  }, [transactionsUrl, token]);
  (0, import_react2.useEffect)(() => {
    fetchAndParse(task);
  }, [fetchAndParse, task._rev]);
  return { changes };
}
var EMPTY_ARRAY$2 = [];
var VARIANTS$1 = { hidden: { opacity: 0, x: 0 }, visible: { opacity: 1, x: 0 } };
var COMMENTS_LIST_ITEM_AVATAR_CONFIG = { parentCommentAvatar: false, threadCommentsAvatar: true, replyAvatar: true, avatarSize: 0 };
var MotionStack = ut(motion(Stack))(_a$e || (_a$e = __template$e([""])));
function TasksActivityLog(props) {
  const { value, onChange, path } = props;
  const currentUser = useCurrentUser();
  const { title: workspaceTitle, basePath } = useWorkspace();
  const { comments: comments2, mentionOptions, operation, getComment } = useComments();
  const loading = comments2.loading;
  const taskComments = comments2.data.open;
  const handleGetNotificationValue = (0, import_react2.useCallback)((message, commentId) => {
    const studioUrl = new URL("".concat(window.location.origin).concat(basePath, "/"));
    studioUrl.searchParams.set("sidebar", "tasks");
    studioUrl.searchParams.set("selectedTask", value == null ? void 0 : value._id);
    studioUrl.searchParams.set("viewMode", "edit");
    studioUrl.searchParams.set("commentId", commentId);
    const mentionedUsers = getMentionedUsers(message);
    const subscribers = Array.from(/* @__PURE__ */ new Set([...value.subscribers || [], ...mentionedUsers]));
    return { documentTitle: value.title || "Sanity task", url: studioUrl.toString(), workspaceTitle, subscribers };
  }, [basePath, value == null ? void 0 : value._id, value.title, workspaceTitle, value.subscribers]);
  const handleCommentCreate = (0, import_react2.useCallback)((message) => {
    const commentId = v4_default();
    const notification = handleGetNotificationValue(message, commentId);
    const nextComment = { id: commentId, type: "task", message, parentCommentId: void 0, reactions: EMPTY_ARRAY$2, status: "open", threadId: v4_default(), context: { notification } };
    onChange(set(notification.subscribers, ["subscribers"]));
    operation.create(nextComment);
  }, [operation, handleGetNotificationValue, onChange]);
  const handleCommentReply = (0, import_react2.useCallback)((nextComment) => {
    const commentId = v4_default();
    const notification = handleGetNotificationValue(nextComment.message, commentId);
    onChange(set(notification.subscribers, ["subscribers"]));
    operation.create({ id: commentId, type: "task", message: nextComment.message, parentCommentId: nextComment.parentCommentId, reactions: EMPTY_ARRAY$2, status: "open", threadId: nextComment.threadId, context: { notification } });
  }, [operation, handleGetNotificationValue, onChange]);
  const handleCommentCreateRetry = (0, import_react2.useCallback)((id) => {
    const comment = getComment(id);
    if (!comment)
      return;
    const notification = handleGetNotificationValue(comment.message, comment._id);
    onChange(set(notification.subscribers, ["subscribers"]));
    operation.create({ type: "task", id: comment._id, message: comment.message, parentCommentId: comment.parentCommentId, reactions: comment.reactions || EMPTY_ARRAY$2, status: comment.status, threadId: comment.threadId, context: { notification } });
  }, [getComment, operation, handleGetNotificationValue, onChange]);
  const handleCommentReact = (0, import_react2.useCallback)((id, reaction) => {
    operation.react(id, reaction);
  }, [operation]);
  const handleCommentRemove = (0, import_react2.useCallback)((id) => {
    operation.remove(id);
  }, [operation]);
  const handleCommentEdit = (0, import_react2.useCallback)((id, next) => {
    operation.update(id, next);
  }, [operation]);
  const activityData = useActivityLog(value).changes;
  const activity = (0, import_react2.useMemo)(() => {
    const taskActivity = activityData.map((item) => ({ _type: "activity", payload: item, timestamp: item.timestamp }));
    const commentsActivity = taskComments.map((comment) => ({ _type: "comment", payload: comment, timestamp: comment.parentComment._createdAt }));
    return taskActivity.concat(commentsActivity).sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
  }, [activityData, taskComments]);
  return (0, import_jsx_runtime.jsxs)(Stack, { space: 5, children: [(0, import_jsx_runtime.jsxs)(Flex, { align: "center", children: [(0, import_jsx_runtime.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime.jsx)(Text, { size: 2, weight: "semibold", children: "Activity" }) }), (currentUser == null ? void 0 : currentUser.id) && (0, import_jsx_runtime.jsx)(TasksSubscribers, { currentUserId: currentUser.id, value, onChange, path })] }), loading && (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true, title: "Loading activity" }), (0, import_jsx_runtime.jsx)(AnimatePresence, { children: !loading && (0, import_jsx_runtime.jsxs)(MotionStack, { animate: "visible", initial: "hidden", space: 3, variants: VARIANTS$1, children: [value.createdByUser && (0, import_jsx_runtime.jsx)(Stack, { paddingBottom: 1, children: (0, import_jsx_runtime.jsx)(TasksActivityCreatedAt, { createdAt: value.createdByUser, authorId: value.authorId }) }), currentUser && (0, import_jsx_runtime.jsx)(CurrentWorkspaceProvider, { children: (0, import_jsx_runtime.jsxs)(Stack, { space: 4, marginTop: 1, children: [activity.map((item) => {
    if (item._type === "activity") {
      return (0, import_jsx_runtime.jsx)(EditedAt, { activity: item.payload }, item.timestamp);
    }
    return (0, import_jsx_runtime.jsx)(ActivityItem, { userId: item.payload.parentComment.authorId, children: (0, import_jsx_runtime.jsx)(CommentsListItem, { avatarConfig: COMMENTS_LIST_ITEM_AVATAR_CONFIG, canReply: true, currentUser, innerPadding: 1, isSelected: false, mentionOptions, mode: "default", onCreateRetry: handleCommentCreateRetry, onDelete: handleCommentRemove, onEdit: handleCommentEdit, onReactionSelect: handleCommentReact, onReply: handleCommentReply, parentComment: item.payload.parentComment, replies: item.payload.replies }, item.payload.parentComment._id) }, item.payload.parentComment._id);
  }), (0, import_jsx_runtime.jsx)(TasksActivityCommentInput, { currentUser, mentionOptions, onSubmit: handleCommentCreate })] }) })] }) })] });
}
var TasksEnabledContext = (0, import_react2.createContext)(null);
function TasksEnabledProvider(_ref128) {
  let { children } = _ref128;
  var _a2;
  const { enabled, isLoading } = useFeatureEnabled("studioTasks");
  const isWorkspaceEnabled = (_a2 = useWorkspace().tasks) == null ? void 0 : _a2.enabled;
  const value = (0, import_react2.useMemo)(() => {
    if (!enabled || !isWorkspaceEnabled || isLoading) {
      return { enabled: false, mode: null };
    }
    return { enabled: true, mode: "default" };
  }, [enabled, isLoading, isWorkspaceEnabled]);
  return (0, import_jsx_runtime.jsx)(TasksEnabledContext.Provider, { value, children });
}
function useTasksEnabled() {
  const context = (0, import_react2.useContext)(TasksEnabledContext);
  if (!context) {
    throw new Error("useTasks must be used within a TasksEnabledProvider");
  }
  return context;
}
var MentionUserContext = (0, import_react2.createContext)(null);
function MentionUserProvider(props) {
  const [selectedDocument, setSelectedDocument] = (0, import_react2.useState)(null);
  const mentionOptions = useUserListWithPermissions({ documentValue: selectedDocument, permission: "read" });
  const value = (0, import_react2.useMemo)(() => ({ mentionOptions, selectedDocument, setSelectedDocument }), [mentionOptions, selectedDocument, setSelectedDocument]);
  return (0, import_jsx_runtime.jsx)(MentionUserContext.Provider, { value, children: props.children });
}
function useMentionUser() {
  const context = (0, import_react2.useContext)(MentionUserContext);
  if (!context) {
    throw new Error("useMentionUser must be used within a MentionUserProvider");
  }
  return context;
}
var TasksNavigationContext = (0, import_react2.createContext)(null);
var initialState = { viewMode: "list", selectedTask: null, activeTabId: "assigned", duplicateTaskValues: null, isOpen: false };
function reducer(state2, action) {
  switch (action.type) {
    case "TOGGLE_TASKS_VIEW": {
      if (action.payload === false) {
        return { ...initialState, isOpen: action.payload };
      }
      return { ...state2, isOpen: action.payload };
    }
    case "CREATE_TASK":
      return { ...state2, viewMode: "create", selectedTask: v4_default() };
    case "EDIT_TASK":
      return { ...state2, viewMode: "edit", selectedTask: action.payload.id };
    case "EDIT_DRAFT":
      return { ...state2, viewMode: "draft", selectedTask: action.payload.id };
    case "DUPLICATE_TASK":
      return { ...state2, viewMode: "duplicate", selectedTask: v4_default(), duplicateTaskValues: action.payload.duplicateTaskValues };
    case "SET_ACTIVE_TAB":
      return { ...state2, viewMode: "list", activeTabId: action.payload };
    case "NAVIGATE_TO_LIST":
      return { ...state2, viewMode: "list" };
    default:
      return state2;
  }
}
var TasksNavigationProvider = (_ref129) => {
  let { children } = _ref129;
  const [state2, dispatch] = (0, import_react2.useReducer)(reducer, initialState);
  const router2 = useRouter();
  const toast = useToast();
  const setViewMode = (0, import_react2.useCallback)((viewMode) => {
    switch (viewMode.type) {
      case "list":
        dispatch({ type: "NAVIGATE_TO_LIST" });
        break;
      case "create":
        dispatch({ type: "CREATE_TASK" });
        break;
      case "edit":
        dispatch({ type: "EDIT_TASK", payload: { id: viewMode.id } });
        break;
      case "duplicate":
        dispatch({ type: "DUPLICATE_TASK", payload: { duplicateTaskValues: viewMode.duplicateTaskValues } });
        break;
      case "draft":
        dispatch({ type: "EDIT_DRAFT", payload: { id: viewMode.id } });
        break;
    }
  }, []);
  const setActiveTab = (0, import_react2.useCallback)((tabId) => {
    dispatch({ type: "SET_ACTIVE_TAB", payload: tabId });
  }, []);
  const handleCloseTasks = (0, import_react2.useCallback)(() => {
    dispatch({ type: "TOGGLE_TASKS_VIEW", payload: false });
  }, []);
  const handleOpenTasks = (0, import_react2.useCallback)(() => {
    dispatch({ type: "TOGGLE_TASKS_VIEW", payload: true });
  }, []);
  const handleCopyLinkToTask = (0, import_react2.useCallback)(() => {
    const url = new URL(window.location.href);
    url.searchParams.set("sidebar", "tasks");
    url.searchParams.set("viewMode", state2.viewMode);
    if (state2.selectedTask) {
      url.searchParams.set("selectedTask", state2.selectedTask);
    }
    navigator.clipboard.writeText(url.toString()).then(() => {
      toast.push({ closable: true, status: "info", title: "Copied link to clipboard" });
    }).catch(() => {
      toast.push({ closable: true, status: "error", title: "Failed to copy link to clipboard" });
    });
  }, [state2.selectedTask, state2.viewMode, toast]);
  const searchParamsAsString = new URLSearchParams(router2.state._searchParams).toString();
  (0, import_react2.useEffect)(() => {
    if (searchParamsAsString) {
      const searchParams = new URLSearchParams(searchParamsAsString);
      const sidebar = searchParams.get("sidebar");
      if (sidebar !== "tasks") {
        return;
      }
      dispatch({ type: "TOGGLE_TASKS_VIEW", payload: true });
      const viewMode = searchParams.get("viewMode");
      const selectedTask = searchParams.get("selectedTask");
      if (viewMode === "edit" && selectedTask) {
        dispatch({ type: "EDIT_TASK", payload: { id: selectedTask } });
      }
    }
  }, [searchParamsAsString]);
  return (0, import_jsx_runtime.jsx)(TasksNavigationContext.Provider, { value: { state: state2, setViewMode, setActiveTab, handleCloseTasks, handleOpenTasks, handleCopyLinkToTask }, children });
};
function useTasksNavigation() {
  const context = (0, import_react2.useContext)(TasksNavigationContext);
  if (!context) {
    return { state: { activeTabId: "assigned", viewMode: "list", selectedTask: null, isOpen: false, duplicateTaskValues: null }, setActiveTab: () => null, setViewMode: () => null, handleCloseTasks: () => null, handleCopyLinkToTask: () => null, handleOpenTasks: () => null };
  }
  return context;
}
var TasksContext = (0, import_react2.createContext)(null);
function createTasksSet(tasks2) {
  const tasksById = tasks2.reduce((acc, task) => ({ ...acc, [task._id]: task }), {});
  return tasksById;
}
function tasksReducer(state2, action) {
  switch (action.type) {
    case "TASKS_SET": {
      const tasksById = createTasksSet(action.tasks);
      return { ...state2, tasks: tasksById };
    }
    case "TASK_ADDED": {
      const nextTaskResult = action.payload;
      const nextTaskValue = nextTaskResult;
      const nextTask = { [nextTaskResult._id]: {
        ...state2.tasks[nextTaskResult._id],
        ...nextTaskValue,
        _state: nextTaskResult._state || void 0,
        // If the task is created optimistically, it won't have a createdAt date as this is set on the server.
        // However, we need to set a createdAt date to be able to sort the tasks correctly.
        // Therefore, we set the createdAt date to the current date here if it's missing while creating the task.
        // Once the task is created and received from the server, the createdAt date will be updated to the correct value.
        _createdAt: nextTaskResult._createdAt || (/* @__PURE__ */ new Date()).toISOString()
      } };
      return { ...state2, tasks: { ...state2.tasks, ...nextTask } };
    }
    case "TASK_RECEIVED": {
      const nextTaskResult = action.payload;
      return { ...state2, tasks: { ...state2.tasks, [nextTaskResult._id]: nextTaskResult } };
    }
    case "TASK_DELETED": {
      const { [action.id]: _, ...restTasks } = state2.tasks;
      return { ...state2, tasks: restTasks };
    }
    case "TASK_UPDATED": {
      const updatedTask = action.payload;
      const id = updatedTask._id;
      const task = state2.tasks[id];
      const nextTask = {
        // Add existing task data
        ...task,
        // Add incoming task data
        ...updatedTask
      };
      return { ...state2, tasks: { ...state2.tasks, [id]: nextTask } };
    }
    default:
      return state2;
  }
}
var INITIAL_STATE = { tasks: {} };
var LISTEN_OPTIONS = { events: ["welcome", "mutation", "reconnect"], includeResult: true, visibility: "query" };
var SORT_FIELD = "_createdAt";
var SORT_ORDER = "desc";
var QUERY_FILTERS = ['_type == "tasks.task"'];
var QUERY_PROJECTION = "{\n  ...,\n}";
var QUERY_SORT_ORDER = "order(".concat(SORT_FIELD, " ").concat(SORT_ORDER, ")");
var QUERY = "*[".concat(QUERY_FILTERS.join(" && "), "] ").concat(QUERY_PROJECTION, " | ").concat(QUERY_SORT_ORDER);
function useTasksStore(opts) {
  const { client } = useAddonDataset();
  const { documentId } = opts;
  const [state2, dispatch] = (0, import_react2.useReducer)(tasksReducer, INITIAL_STATE);
  const [isLoading, setIsLoading] = (0, import_react2.useState)(client !== null);
  const [error, setError] = (0, import_react2.useState)(null);
  const params = (0, import_react2.useMemo)(() => ({ documentId: documentId ? getPublishedId(documentId) : null }), [documentId]);
  const initialFetch = (0, import_react2.useCallback)(async () => {
    if (!client) {
      setIsLoading(false);
      return;
    }
    try {
      const res = await client.fetch(QUERY, params);
      dispatch({ type: "TASKS_SET", tasks: res });
      setIsLoading(false);
    } catch (err) {
      setError(err);
    }
  }, [client, params]);
  const handleListenerEvent = (0, import_react2.useCallback)(async (event) => {
    if (event.type === "welcome") {
      setIsLoading(true);
      await initialFetch();
      setIsLoading(false);
    }
    if (event.type === "reconnect") {
      setIsLoading(true);
    }
    if (event.type === "mutation") {
      if (event.transition === "appear") {
        const nextTask = event.result;
        if (nextTask) {
          dispatch({ type: "TASK_RECEIVED", payload: nextTask });
        }
      }
      if (event.transition === "disappear") {
        dispatch({ type: "TASK_DELETED", id: event.documentId });
      }
      if (event.transition === "update") {
        const updatedTask = event.result;
        if (updatedTask) {
          dispatch({ type: "TASK_UPDATED", payload: updatedTask });
        }
      }
    }
  }, [initialFetch]);
  const listener$ = (0, import_react2.useMemo)(() => {
    if (!client)
      return of();
    const events$ = client.observable.listen(QUERY, params, LISTEN_OPTIONS).pipe(catchError((err) => {
      setError(err);
      return of(err);
    }));
    return events$;
  }, [client, params]);
  (0, import_react2.useEffect)(() => {
    const sub = listener$.subscribe(handleListenerEvent);
    return () => {
      sub == null ? void 0 : sub.unsubscribe();
    };
  }, [handleListenerEvent, listener$]);
  const tasksAsArray = (0, import_react2.useMemo)(() => Object.values(state2.tasks), [state2.tasks]);
  return { data: tasksAsArray, dispatch, error, isLoading };
}
var EMPTY_ARRAY$1 = [];
function TasksProvider(props) {
  const { children } = props;
  const [activeDocument, setActiveDocument] = (0, import_react2.useState)(null);
  const { data = EMPTY_ARRAY$1, isLoading } = useTasksStore({});
  const value = (0, import_react2.useMemo)(() => ({ activeDocument, setActiveDocument, isLoading, data: data != null ? data : [] }), [activeDocument, data, isLoading]);
  return (0, import_jsx_runtime.jsx)(TasksContext.Provider, { value, children });
}
function useTasks() {
  const context = (0, import_react2.useContext)(TasksContext);
  if (!context) {
    return { activeDocument: null, setActiveDocument: () => null, data: [], isLoading: false };
  }
  return context;
}
var __freeze$d = Object.freeze;
var __defProp$d = Object.defineProperty;
var __template$d = (cooked, raw) => __freeze$d(__defProp$d(cooked, "raw", { value: __freeze$d(raw || cooked.slice()) }));
var _a$d;
function MentionUserMenuItem(props) {
  const { user, onSelect, pressed } = props;
  const handleSelect = (0, import_react2.useCallback)(() => onSelect(user.id), [user, onSelect]);
  return (0, import_jsx_runtime.jsx)(MenuItem, { onClick: handleSelect, padding: 1, disabled: !user.granted, pressed, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [(0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, flex: 1, children: [(0, import_jsx_runtime.jsx)(TasksUserAvatar, { user: user.id ? user : void 0, size: 1 }), (0, import_jsx_runtime.jsx)(Text, { size: 1, textOverflow: "ellipsis", title: user.displayName, children: user.displayName })] }), !user.granted && (0, import_jsx_runtime.jsx)(Badge, { fontSize: 1, mode: "outline", children: "Unauthorized" })] }) });
}
var StyledMenu = ut(Menu)(_a$d || (_a$d = __template$d(["\n  width: 308px;\n  border-radius: 3px;\n"])));
var IGNORED_KEYS = ["Control", "Shift", "Alt", "Enter", "Home", "End", "PageUp", "PageDown", "Meta", "Tab", "CapsLock"];
var NO_ASSIGNEE_OPTION = { id: "", displayName: "No assignee", granted: true };
function MentionsMenu(_ref130) {
  let { onSelect, value = "" } = _ref130;
  const [searchTerm, setSearchTerm] = (0, import_react2.useState)("");
  const { mentionOptions } = useMentionUser();
  const inputRef = (0, import_react2.useRef)(null);
  const options = [NO_ASSIGNEE_OPTION].concat(mentionOptions.data || []);
  const handleSearchChange = (0, import_react2.useCallback)((event) => {
    setSearchTerm(event.currentTarget.value);
  }, []);
  const filteredOptions = (0, import_react2.useMemo)(() => {
    var _a2;
    if (!searchTerm)
      return options || [];
    const deburredSearchTerm = (0, import_deburr.default)(searchTerm).toLocaleLowerCase();
    const deburredOptions = options == null ? void 0 : options.map((option) => ({ ...option, displayName: (0, import_deburr.default)(option.displayName || "").toLocaleLowerCase() }));
    const filtered = (_a2 = deburredOptions == null ? void 0 : deburredOptions.filter((option) => {
      var _a3;
      return (_a3 = option == null ? void 0 : option.displayName) == null ? void 0 : _a3.includes(deburredSearchTerm);
    })) == null ? void 0 : _a2.sort((a, b) => {
      var _a3, _b2;
      const matchA = (_a3 = a.displayName) == null ? void 0 : _a3.startsWith(deburredSearchTerm);
      const matchB = (_b2 = b.displayName) == null ? void 0 : _b2.startsWith(deburredSearchTerm);
      if (matchA && !matchB)
        return -1;
      if (!matchA && matchB)
        return 1;
      return 0;
    });
    return filtered || [];
  }, [options, searchTerm]);
  const renderItem2 = (0, import_react2.useCallback)((user) => {
    return (0, import_jsx_runtime.jsx)(MentionUserMenuItem, { user, onSelect, pressed: user.id === value }, user.id);
  }, [onSelect, value]);
  const handleKeyDown = (0, import_react2.useCallback)((event) => {
    var _a2;
    if (event.target === inputRef.current) {
      return;
    }
    if (!IGNORED_KEYS.includes(event.key)) {
      (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
    }
  }, []);
  if (mentionOptions.loading) {
    return (0, import_jsx_runtime.jsx)(Container, { width: 0, children: (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true }) });
  }
  return (0, import_jsx_runtime.jsxs)("div", { onKeyDown: handleKeyDown, children: [(0, import_jsx_runtime.jsx)(TextInput, { placeholder: "Search username", autoFocus: true, border: false, onChange: handleSearchChange, value: searchTerm, fontSize: 1, icon: UserIcon, ref: inputRef }), (0, import_jsx_runtime.jsx)("div", { style: { maxHeight: "320px", overflowY: "scroll", paddingTop: "8px" }, children: filteredOptions.length === 0 ? (0, import_jsx_runtime.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime.jsx)(Text, { align: "center", size: 1, muted: true, children: "No users found" }) }) : filteredOptions.map(renderItem2) })] });
}
function AssigneeSelectionMenu(props) {
  const { onSelect, menuButton, value } = props;
  const ref = (0, import_react2.useRef)(null);
  return (0, import_jsx_runtime.jsx)(motion.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, ref, children: (0, import_jsx_runtime.jsx)(MenuButton, { button: menuButton, id: "assign-user-menu", menu: (0, import_jsx_runtime.jsx)(StyledMenu, { children: (0, import_jsx_runtime.jsx)(MentionsMenu, { onSelect, value }) }), popover: { placement: "bottom", portal: true } }) });
}
var __freeze$c = Object.freeze;
var __defProp$c = Object.defineProperty;
var __template$c = (cooked, raw) => __freeze$c(__defProp$c(cooked, "raw", { value: __freeze$c(raw || cooked.slice()) }));
var _a$c;
var FocusableCard = ut(Card)((props) => {
  const theme = getTheme_v2(props.theme);
  return at(_a$c || (_a$c = __template$c(["\n    &[data-as='button'] {\n      border: 1px solid var(--card-border-color);\n      &:focus-within {\n        border: 1px solid var(--card-focus-ring-color);\n      }\n      --card-muted-fg-color: ", ";\n    }\n  "])), theme.color.input.default.enabled.placeholder);
});
function AssigneeCreateFormField(props) {
  const { value, onChange } = props;
  const { mentionOptions } = useMentionUser();
  const mentionedUser = (0, import_react2.useMemo)(() => {
    var _a2;
    return (_a2 = mentionOptions.data) == null ? void 0 : _a2.find((u) => u.id === value);
  }, [mentionOptions.data, value]);
  const onSelect = (0, import_react2.useCallback)((userId) => onChange(set(userId)), [onChange]);
  const displayText = (0, import_react2.useMemo)(() => {
    if (value) {
      if (mentionOptions.loading)
        return (0, import_jsx_runtime.jsx)(TextSkeleton, { animated: true, style: { width: "10ch" } });
      if (mentionedUser)
        return mentionedUser.displayName || mentionedUser.email;
      if (!mentionedUser)
        return "User not found";
    }
    return "Search username";
  }, [mentionOptions.loading, mentionedUser, value]);
  return (0, import_jsx_runtime.jsx)(AssigneeSelectionMenu, { onSelect, value, menuButton: (0, import_jsx_runtime.jsx)(FocusableCard, { "data-as": "button", padding: 1, radius: 2, tabIndex: 0, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [(0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, flex: 1, children: [(0, import_jsx_runtime.jsx)(TasksUserAvatar, { user: mentionedUser, size: 1, border: false }), (0, import_jsx_runtime.jsx)(Text, { size: 1, textOverflow: "ellipsis", muted: !mentionedUser, children: displayText })] }), value && mentionedUser && !mentionedUser.granted && (0, import_jsx_runtime.jsx)(Badge, { fontSize: 1, mode: "outline", children: "Unauthorized" })] }) }) });
}
var __freeze$b = Object.freeze;
var __defProp$b = Object.defineProperty;
var __template$b = (cooked, raw) => __freeze$b(__defProp$b(cooked, "raw", { value: __freeze$b(raw || cooked.slice()) }));
var _a$b;
var StyledButton = ut(Button)(_a$b || (_a$b = __template$b(["\n  padding: 3px 6px;\n"])));
function AssigneeEditFormField(props) {
  const { value, onChange, path } = props;
  const subscribers = useFormValue(["subscribers"]);
  const { mentionOptions } = useMentionUser();
  const mentionedUser = (0, import_react2.useMemo)(() => {
    var _a2;
    return (_a2 = mentionOptions.data) == null ? void 0 : _a2.find((u) => u.id === value);
  }, [mentionOptions.data, value]);
  const onSelect = (0, import_react2.useCallback)((userId) => {
    onChange(set(userId, path));
    if (subscribers && !subscribers.includes(userId)) {
      onChange(set([...subscribers, userId], ["subscribers"]));
    }
  }, [onChange, path, subscribers]);
  const displayText = (0, import_react2.useMemo)(() => {
    if (value) {
      if (mentionOptions.loading)
        return (0, import_jsx_runtime.jsx)(TextSkeleton, { animated: true, style: { width: "10ch" } });
      if (mentionedUser)
        return mentionedUser.displayName || mentionedUser.email;
      if (!mentionedUser)
        return "User not found";
    }
    return "Not assigned";
  }, [mentionOptions.loading, mentionedUser, value]);
  return (0, import_jsx_runtime.jsx)(AssigneeSelectionMenu, { onSelect, value, menuButton: (0, import_jsx_runtime.jsx)(StyledButton, { mode: "ghost", padding: 0, children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 3, children: [(0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, flex: 1, children: [(0, import_jsx_runtime.jsx)(TasksUserAvatar, { user: mentionedUser, size: 0 }), (0, import_jsx_runtime.jsx)(Box, { children: (0, import_jsx_runtime.jsx)(Text, { size: 1, textOverflow: "ellipsis", children: displayText }) })] }), value && mentionedUser && !mentionedUser.granted && (0, import_jsx_runtime.jsx)(Badge, { fontSize: 1, mode: "outline", children: "Unauthorized" })] }) }) });
}
var serialize = (date) => format(date, DEFAULT_DATE_FORMAT);
var deserialize = (value) => parse(value, DEFAULT_DATE_FORMAT);
function DateEditFormField(props) {
  var _a2;
  const { value, onChange, path } = props;
  const { t } = useTranslation2();
  const [pickerOpen, setPickerOpen] = (0, import_react2.useState)(false);
  const [popoverRef, setPopoverRef] = (0, import_react2.useState)(null);
  const buttonRef = (0, import_react2.useRef)(null);
  const dateFormatter = useDateTimeFormat({ dateStyle: "long" });
  const dueByeDisplayValue = (0, import_react2.useMemo)(() => {
    if (!value)
      return { short: "----", full: "----" };
    const dueFormated = dateFormatter.format(new Date(value));
    const [monthAndDay] = dueFormated.split(",");
    return { short: monthAndDay, full: dueFormated };
  }, [dateFormatter, value]);
  useClickOutside(() => setPickerOpen(false), [popoverRef]);
  const handleKeyUp = (0, import_react2.useCallback)((e2) => {
    if (e2.key === "Escape") {
      setPickerOpen(false);
    }
  }, []);
  const handleClick = (0, import_react2.useCallback)(() => setPickerOpen((p) => !p), []);
  const calendarLabels = (0, import_react2.useMemo)(() => getCalendarLabels(t), [t]);
  const handleChange = (0, import_react2.useCallback)((nextDate) => {
    if (nextDate) {
      onChange(set(serialize(nextDate), path));
    } else {
      onChange(unset(path));
    }
    setPickerOpen(false);
  }, [onChange, path]);
  const deserializedValue = deserialize(value);
  const handleDeactivation = (0, import_react2.useCallback)(() => {
    var _a22;
    (_a22 = buttonRef.current) == null ? void 0 : _a22.focus();
  }, [buttonRef]);
  const dueDateIsThisYear = ((_a2 = deserializedValue == null ? void 0 : deserializedValue.date) == null ? void 0 : _a2.getFullYear()) === (/* @__PURE__ */ new Date()).getFullYear();
  return (0, import_jsx_runtime.jsx)(Popover2, { constrainSize: true, "data-testid": "date-input-dialog", portal: true, ref: setPopoverRef, content: (0, import_jsx_runtime.jsx)(Box, { overflow: "auto", children: (0, import_jsx_runtime.jsxs)(es2015_default, { onDeactivation: handleDeactivation, children: [(0, import_jsx_runtime.jsx)(DatePicker, { calendarLabels, selectTime: false, timeStep: 1, onKeyUp: handleKeyUp, value: deserializedValue.date, onChange: handleChange }), value && (0, import_jsx_runtime.jsx)(Flex, { justify: "flex-start", padding: 3, paddingTop: 0, children: (0, import_jsx_runtime.jsx)(Button2, { mode: "bleed", text: "Remove", onClick: () => handleChange(null), tone: "critical" }) })] }) }), open: pickerOpen, placement: "bottom", fallbackPlacements: ["bottom-start", "bottom-end"], children: (0, import_jsx_runtime.jsx)(Button2, { icon: CalendarIcon, mode: "ghost", text: dueDateIsThisYear ? dueByeDisplayValue.short : dueByeDisplayValue.full, onClick: handleClick, ref: buttonRef }) });
}
var __freeze$a = Object.freeze;
var __defProp$a = Object.defineProperty;
var __template$a = (cooked, raw) => __freeze$a(__defProp$a(cooked, "raw", { value: __freeze$a(raw || cooked.slice()) }));
var _a$a;
var DescriptionInputRoot = ut.div((props) => {
  const theme = getTheme_v2(props.theme);
  const verticalPadding = props.$mode === "edit" ? theme.space[1] : theme.space[3];
  return at(_a$a || (_a$a = __template$a(["\n    /* select editable-wrap and change the padding */\n    [data-ui='editable-wrap'] {\n      overflow: hidden;\n      padding: ", ";\n      min-height: ", "px !important;\n    }\n    #comment-input-root {\n      box-shadow: ", ";\n    }\n    [data-ui='CommentInputActions'] {\n      display: none !important;\n    }\n  "])), props.$mode === "edit" ? "".concat(verticalPadding, "px 0px") : "".concat(verticalPadding, "px ").concat(theme.space[2], "px"), Math.max(props.$minHeight + verticalPadding, 200), props.$mode === "edit" ? "none" : "");
});
function DescriptionInput(props) {
  const { value: _propValue, mode, inputProps: { onChange } } = props;
  const value = _propValue;
  const currentUser = useCurrentUser();
  const { mentionOptions } = useMentionUser();
  const handleChange = (0, import_react2.useCallback)((next) => onChange(set(next)), [onChange]);
  const rootRef = (0, import_react2.useRef)(null);
  const [textBoxScrollHeight, setTextBoxScrollHeight] = (0, import_react2.useState)(200);
  const setTextboxHeight = (0, import_react2.useCallback)((ref) => {
    const textBox = ref.querySelector('[role="textbox"]');
    if (!textBox)
      return;
    const height = textBox.scrollHeight;
    setTextBoxScrollHeight(height);
  }, []);
  const setRootRef = (0, import_react2.useCallback)((ref) => {
    if (!ref)
      return;
    setTextboxHeight(ref);
    rootRef.current = ref;
  }, [setTextboxHeight]);
  (0, import_react2.useEffect)(() => {
    if (!rootRef.current)
      return;
    setTextboxHeight(rootRef.current);
  }, [value, setTextboxHeight]);
  if (!currentUser)
    return null;
  return (0, import_jsx_runtime.jsx)(DescriptionInputRoot, { $mode: mode, ref: setRootRef, $minHeight: textBoxScrollHeight || 200, children: (0, import_jsx_runtime.jsx)(CommentInput, { expandOnFocus: false, currentUser, mentionOptions, onChange: handleChange, value: value != null ? value : [], withAvatar: false, placeholder: "Optional additional description", onDiscardConfirm: () => null }) });
}
var __freeze$9 = Object.freeze;
var __defProp$9 = Object.defineProperty;
var __template$9 = (cooked, raw) => __freeze$9(__defProp$9(cooked, "raw", { value: __freeze$9(raw || cooked.slice()) }));
var _a$9;
var FieldWrapperRoot = ut.div((props) => {
  const theme = getTheme_v2(props.theme);
  return at(_a$9 || (_a$9 = __template$9(["\n    // Reset the padding of the field header content box\n    [data-ui='fieldHeaderContentBox'] {\n      padding: 0;\n      label {\n        font-weight: ", ";\n      }\n    }\n  "])), theme.font.text.weights.regular);
});
function FieldWrapper(props) {
  return (0, import_jsx_runtime.jsx)(FieldWrapperRoot, { children: props.renderDefault(props) });
}
var StatusMenuButton = (0, import_react2.forwardRef)(function StatusMenuButton2(props, ref) {
  var _a2;
  const { value, options, ...rest } = props;
  const selectedOption = options.find((option) => option.value === value);
  const icon = (_a2 = TASK_STATUS.find((status) => status.value === value)) == null ? void 0 : _a2.icon;
  return (0, import_jsx_runtime.jsx)(Button2, { ...rest, ref, tooltipProps: null, icon, text: (selectedOption == null ? void 0 : selectedOption.title) || value, tone: "default", mode: "ghost" });
});
function StatusSelector(props) {
  const { value, onChange, options, path } = props;
  return (0, import_jsx_runtime.jsx)(MenuButton, { button: (0, import_jsx_runtime.jsx)(StatusMenuButton, { value, options }), id: "reference-menuButton", menu: (0, import_jsx_runtime.jsx)(Menu, { children: options.map((option) => {
    var _a2;
    const isSelected = value === option.value;
    const icon = (_a2 = TASK_STATUS.find((status) => status.value === option.value)) == null ? void 0 : _a2.icon;
    return (0, import_jsx_runtime.jsx)(MenuItem2, { icon: isString(option.value) ? icon || CircleIcon : CircleIcon, text: option.title || option.value, pressed: isSelected, iconRight: isSelected && (0, import_jsx_runtime.jsx)(CheckmarkIcon, {}), onClick: () => onChange(set(option.value, path)) }, option.title);
  }) }) });
}
var __freeze$8 = Object.freeze;
var __defProp$8 = Object.defineProperty;
var __template$8 = (cooked, raw) => __freeze$8(__defProp$8(cooked, "raw", { value: __freeze$8(raw || cooked.slice()) }));
var _a$8;
var _b$4;
var _c$2;
var EmptyReferenceRoot = ut(Card)((props) => {
  const theme = getTheme_v2(props.theme);
  return at(_a$8 || (_a$8 = __template$8(["\n    &:focus {\n      border: 1px solid var(--card-focus-ring-color);\n    }\n    &:focus-visible {\n      outline: none;\n      border: 1px solid var(--card-focus-ring-color);\n    }\n    &:hover {\n      border-color: ", ";\n    }\n  "])), theme.color.input.default.hovered.border);
});
var Placeholder = ut(Text)((props) => {
  const theme = getTheme_v2(props.theme);
  return "\n      color: ".concat(theme.color.input.default.enabled.placeholder, ";\n      margin-left: 3px;\n  ");
});
var TargetRoot = ut(Card)(_b$4 || (_b$4 = __template$8(["\n  position: relative;\n  [data-ui='show-on-hover'] {\n    opacity: 0;\n    position: absolute;\n    right: 6px;\n    top: 4px;\n    display: flex;\n  }\n  &:focus-within,\n  &:hover {\n    padding-right: 36px;\n    /* Hides the preview status dot, the button will take it's position. */\n    [data-testid='compact-preview__status'] {\n      opacity: 0;\n    }\n    [data-ui='show-on-hover'] {\n      transition: opacity 200ms;\n      opacity: 1;\n    }\n  }\n"])));
var StyledIntentLink$1 = ut(IntentLink)(() => {
  return at(_c$2 || (_c$2 = __template$8(["\n    text-decoration: none;\n    width: 100%;\n    overflow: hidden;\n    cursor: pointer;\n    &:focus {\n      box-shadow: 0 0 0 1px var(--card-focus-ring-color);\n    }\n    &:focus-visible {\n      outline: none;\n      box-shadow: 0 0 0 1px var(--card-focus-ring-color);\n    }\n  "])));
});
function Preview(props) {
  const { value, handleRemove } = props;
  const documentId = value.document._ref;
  const documentType = value.documentType;
  const schema2 = useSchema();
  const schemaType = schema2.get(value.documentType);
  const documentPresence = useDocumentPresence(documentId);
  const CardLink = (0, import_react2.useMemo)(() => (0, import_react2.forwardRef)(function LinkComponent(linkProps, ref) {
    return (0, import_jsx_runtime.jsx)(StyledIntentLink$1, { ...linkProps, intent: "edit", params: { id: documentId, type: documentType }, ref });
  }), [documentId, documentType]);
  if (!schemaType) {
    return (0, import_jsx_runtime.jsx)(Text, { children: "Schema not found" });
  }
  return (0, import_jsx_runtime.jsx)(TargetRoot, { border: true, radius: 2, children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, align: "center", justify: "space-between", children: [(0, import_jsx_runtime.jsx)(Card, { as: CardLink, radius: 2, "data-as": "button", children: (0, import_jsx_runtime.jsx)(SearchResultItemPreview, { documentId: value.document._ref, layout: "compact", presence: documentPresence, schemaType, showBadge: false }) }), (0, import_jsx_runtime.jsx)("div", { "data-ui": "show-on-hover", children: (0, import_jsx_runtime.jsx)(Button2, { icon: CloseIcon, mode: "bleed", onClick: handleRemove, tooltipProps: { content: "Remove target content" } }) })] }) });
}
function TargetField(props) {
  const [open, setOpen] = (0, import_react2.useState)(false);
  const { dataset, projectId } = useWorkspace();
  const { mode, inputProps: { onChange }, value: _propValue } = props;
  const value = _propValue;
  const handleItemSelect = (0, import_react2.useCallback)((item) => {
    onChange(set(getTargetValue({ documentId: item._id, documentType: item._type, dataset, projectId })));
  }, [dataset, projectId, onChange]);
  const handleRemove = (0, import_react2.useCallback)(() => {
    onChange(unset());
  }, [onChange]);
  const handleOpenSearch = (0, import_react2.useCallback)(() => {
    setOpen(true);
  }, [setOpen]);
  const handleCloseSearch = (0, import_react2.useCallback)(() => {
    setOpen(false);
  }, [setOpen]);
  const handleKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.key === "Enter" || event.key === " ")
      setOpen(true);
  }, []);
  return (0, import_jsx_runtime.jsx)(Card, { borderBottom: mode === "edit", paddingBottom: mode === "edit" ? 4 : 0, children: (0, import_jsx_runtime.jsx)(FieldWrapperRoot, { children: (0, import_jsx_runtime.jsx)(LayerProvider, { zOffset: 100, children: (0, import_jsx_runtime.jsxs)(CurrentWorkspaceProvider, { children: [(0, import_jsx_runtime.jsxs)(Stack, { space: 2, children: [mode === "create" && (0, import_jsx_runtime.jsx)(Box, { "data-ui": "fieldHeaderContentBox", children: (0, import_jsx_runtime.jsx)(FormFieldHeaderText, { description: props.description, inputId: props.inputId, title: props.title, validation: props.validation, deprecated: void 0 }) }), value ? (0, import_jsx_runtime.jsx)(Preview, { value, handleRemove }) : (0, import_jsx_runtime.jsx)(EmptyReferenceRoot, { border: true, radius: 2, paddingX: 2, paddingY: 3, onClick: handleOpenSearch, onKeyDown: handleKeyDown, tabIndex: 0, children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, justify: "flex-start", align: "center", children: [(0, import_jsx_runtime.jsx)(Box, { paddingX: 1, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(DocumentIcon, {}) }) }), (0, import_jsx_runtime.jsx)(Placeholder, { size: 1, children: "Search document" })] }) })] }), (0, import_jsx_runtime.jsx)(SearchProvider, { children: (0, import_jsx_runtime.jsx)(SearchPopover, { open, onClose: handleCloseSearch, onOpen: handleOpenSearch, onItemSelect: handleItemSelect, disableIntentLink: true }) })] }) }) }) });
}
var __freeze$7 = Object.freeze;
var __defProp$7 = Object.defineProperty;
var __template$7 = (cooked, raw) => __freeze$7(__defProp$7(cooked, "raw", { value: __freeze$7(raw || cooked.slice()) }));
var _a$7;
var Root = ut.div((props) => {
  const theme = getTheme_v2(props.theme);
  return "\n      display: grid;\n      grid-template-columns: 1fr;\n      padding-top: ".concat(theme.space[3], "px;\n    ");
});
var TitleInput = ut.textarea((props) => {
  const { color, font } = getTheme_v2(props.theme);
  return at(_a$7 || (_a$7 = __template$7(["\n    resize: none;\n    overflow: hidden;\n    appearance: none;\n    background: none;\n    border: 0;\n    padding: 0;\n    border-radius: 0;\n    outline: none;\n    width: 100%;\n    box-sizing: border-box;\n    font-family: ", ";\n    font-weight: ", ";\n    font-size: ", "px;\n    line-height: ", "px;\n    margin: 0;\n    position: relative;\n    z-index: 1;\n    display: block;\n    transition: height 500ms;\n    /* NOTE: This is a hack to disable Chrome’s autofill styles */\n    &:-webkit-autofill,\n    &:-webkit-autofill:hover,\n    &:-webkit-autofill:focus,\n    &:-webkit-autofill:active {\n      -webkit-text-fill-color: var(--input-fg-color) !important;\n      transition: background-color 5000s;\n      transition-delay: 86400s /* 24h */;\n    }\n\n    color: ", ";\n\n    &::placeholder {\n      color: ", ";\n    }\n  "])), font.text.family, font.text.weights.semibold, font.text.sizes[3].fontSize, font.text.sizes[3].lineHeight, color.input.default.enabled.fg, color.input.default.enabled.placeholder);
});
function Title(props) {
  const { value, onChange, placeholder, path } = props;
  const ref = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    if (!ref.current)
      return;
    ref.current.style.height = "auto";
    ref.current.style.height = "".concat(ref.current.scrollHeight, "px");
  }, [value]);
  const handleChange = (0, import_react2.useCallback)((event) => {
    const inputValue = event.currentTarget.value;
    if (!inputValue)
      onChange(unset(path));
    return onChange(set(inputValue.replace(/\n/g, ""), path));
  }, [onChange, path]);
  return (0, import_jsx_runtime.jsx)(Root, { children: (0, import_jsx_runtime.jsx)(TitleInput, { ref, autoFocus: !value, value, placeholder, onChange: handleChange, rows: 1 }) });
}
function TitleField(props) {
  const { value, inputProps } = props;
  const { onChange, schemaType } = inputProps;
  return (0, import_jsx_runtime.jsx)(Title, { value, onChange, placeholder: schemaType.placeholder });
}
function useTaskOperations() {
  const { client, createAddonDataset } = useAddonDataset();
  const currentUser = useCurrentUser();
  const handleCreate = (0, import_react2.useCallback)(async (payload) => {
    if (!currentUser) {
      throw new Error("No current user found. Unable to create task.");
    }
    const task = { ...payload, authorId: currentUser.id, _type: "tasks.task" };
    if (!client) {
      try {
        const newCreatedClient = await createAddonDataset();
        if (!newCreatedClient)
          throw new Error("No addon client found. Unable to create task.");
        const created = await newCreatedClient.create(task);
        return created;
      } catch (err) {
        throw err;
      }
    }
    try {
      const created = await client.create(task);
      return created;
    } catch (err) {
      throw err;
    }
  }, [client, createAddonDataset, currentUser]);
  const handleEdit = (0, import_react2.useCallback)(async (id, set2) => {
    try {
      if (!client) {
        throw new Error("No client. Unable to create task.");
      }
      const edited = await client.patch(id).set(set2).commit();
      return edited;
    } catch (e2) {
      throw e2;
    }
  }, [client]);
  const handleRemove = (0, import_react2.useCallback)(async (id) => {
    try {
      if (!client) {
        throw new Error("No client. Unable to create task.");
      }
      await client.delete(id);
    } catch (e2) {
      throw e2;
    }
  }, [client]);
  const operations = (0, import_react2.useMemo)(() => ({ create: handleCreate, edit: handleEdit, remove: handleRemove }), [handleCreate, handleEdit, handleRemove]);
  return operations;
}
function useRemoveTask(_ref131) {
  let { id, onError, onRemoved } = _ref131;
  const [removeStatus, setRemoveStatus] = (0, import_react2.useState)("idle");
  const [showDialog, setShowDialog] = (0, import_react2.useState)(false);
  const [error, setError] = (0, import_react2.useState)(null);
  const operations = useTaskOperations();
  const handleRemove = (0, import_react2.useCallback)(async () => {
    try {
      setRemoveStatus("loading");
      await operations.remove(id);
      onRemoved == null ? void 0 : onRemoved();
      setRemoveStatus("idle");
      await new Promise((resolve) => setTimeout(resolve, 300));
      setShowDialog(false);
    } catch (e2) {
      onError == null ? void 0 : onError(e2.message);
      setError(e2.message);
      setRemoveStatus("error");
    } finally {
      setRemoveStatus("idle");
    }
  }, [id, operations, onError, onRemoved]);
  const handleOpenDialog = (0, import_react2.useCallback)(() => {
    setShowDialog(true);
  }, [setShowDialog]);
  const handleCloseDialog = (0, import_react2.useCallback)(() => {
    setShowDialog(false);
  }, [setShowDialog]);
  return { removeStatus, showDialog, error, handleRemove, handleOpenDialog, handleCloseDialog };
}
var getTaskSubscribers = (task) => {
  const subscribers = task.subscribers || [];
  getMentionedUsers(task.description).forEach((user) => {
    if (!subscribers.includes(user))
      subscribers.push(user);
  });
  if (task.assignedTo) {
    if (!subscribers.includes(task.assignedTo)) {
      subscribers.push(task.assignedTo);
    }
  }
  return subscribers;
};
function FormCreate(props) {
  const [createMore, setCreateMore] = (0, import_react2.useState)(false);
  const { setViewMode, setActiveTab, state: { viewMode } } = useTasksNavigation();
  const toast = useToast();
  const handleCreateMore = (0, import_react2.useCallback)(() => setCreateMore((p) => !p), []);
  const { onChange } = props;
  const value = props.value;
  const onRemove = (0, import_react2.useCallback)(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]);
  const { handleRemove, removeStatus } = useRemoveTask({ id: value._id, onRemoved: onRemove });
  const handleCreate = (0, import_react2.useCallback)(() => {
    if (!(value == null ? void 0 : value.title)) {
      toast.push({ closable: true, status: "error", title: "Title is required" });
      return;
    }
    onChange([set(getTaskSubscribers(value), ["subscribers"]), set((/* @__PURE__ */ new Date()).toISOString(), ["createdByUser"])]);
    if (createMore) {
      setViewMode({ type: "create" });
    } else {
      setActiveTab("subscribed");
    }
    toast.push({ closable: true, status: "success", title: "Task created" });
  }, [setViewMode, setActiveTab, onChange, createMore, toast, value]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [props.renderDefault(props), (0, import_jsx_runtime.jsx)(Box, { paddingTop: 5, children: (0, import_jsx_runtime.jsxs)(Flex, { justify: "flex-end", paddingTop: 1, gap: 3, children: [(0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, style: { flexGrow: viewMode === "draft" ? 1 : 0 }, children: [(0, import_jsx_runtime.jsx)(Switch, { onChange: handleCreateMore, checked: createMore }), (0, import_jsx_runtime.jsx)(Text, { size: 1, muted: true, children: "Create more" })] }), viewMode === "draft" && (0, import_jsx_runtime.jsx)(Button2, { text: "Discard", onClick: handleRemove, mode: "bleed", disabled: removeStatus === "loading", loading: removeStatus === "loading" }), (0, import_jsx_runtime.jsx)(Button2, { text: "Create Task", onClick: handleCreate })] }) })] });
}
function RemoveTaskDialog(props) {
  const { handleCloseDialog, handleRemove, removeStatus, showDialog } = props;
  if (showDialog) {
    return (0, import_jsx_runtime.jsx)(Dialog2, { id: "remove-task", header: "Remove task", onClose: handleCloseDialog, footer: { cancelButton: { text: "Cancel", onClick: handleCloseDialog }, confirmButton: { text: "Remove", tone: "critical", onClick: handleRemove, loading: removeStatus === "loading" } }, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 3, children: [(0, import_jsx_runtime.jsx)(Text, { as: "p", children: "Are you sure you want to delete this task?" }), (0, import_jsx_runtime.jsx)(Text, { as: "p", children: "Once deleted, it cannot be restored." })] }) });
  }
  return null;
}
var __freeze$6 = Object.freeze;
var __defProp$6 = Object.defineProperty;
var __template$6 = (cooked, raw) => __freeze$6(__defProp$6(cooked, "raw", { value: __freeze$6(raw || cooked.slice()) }));
var _a$6;
var FirstRow = ut(Flex)((props) => {
  const theme = getTheme_v2(props.theme);
  return at(_a$6 || (_a$6 = __template$6(["\n    column-gap: ", "px;\n    row-gap: ", "px;\n  "])), theme.space[2], theme.space[3]);
});
function FormActionsMenu(_ref132) {
  let { id, value } = _ref132;
  const { setViewMode, handleCopyLinkToTask } = useTasksNavigation();
  const onTaskRemoved = (0, import_react2.useCallback)(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]);
  const removeTask = useRemoveTask({ id, onRemoved: onTaskRemoved });
  const duplicateTask = (0, import_react2.useCallback)(() => {
    setViewMode({ type: "duplicate", duplicateTaskValues: value });
  }, [setViewMode, value]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Box, { paddingTop: 3, children: (0, import_jsx_runtime.jsx)(MenuButton, { id: "edit-task-menu", button: (0, import_jsx_runtime.jsx)(ContextMenuButton, {}), popover: { placement: "bottom", fallbackPlacements: ["bottom-end", "bottom-start"] }, menu: (0, import_jsx_runtime.jsxs)(Menu, { children: [(0, import_jsx_runtime.jsx)(MenuItem2, { text: "Duplicate task", icon: CopyIcon, onClick: duplicateTask }), (0, import_jsx_runtime.jsx)(MenuItem2, { text: "Copy link to task", icon: LinkIcon, onClick: handleCopyLinkToTask }), (0, import_jsx_runtime.jsx)(MenuDivider, {}), (0, import_jsx_runtime.jsx)(MenuItem2, { text: "Delete task", icon: TrashIcon, onClick: removeTask.handleOpenDialog, tone: "critical" })] }) }) }), (0, import_jsx_runtime.jsx)(RemoveTaskDialog, { ...removeTask })] });
}
function FormEditInner(props) {
  var _a2, _b2, _c2, _d2, _e2, _f2;
  const statusField = props.schemaType.fields.find((f) => f.name === "status");
  const value = props.value;
  const currentUser = useCurrentUser();
  const handleChangeAndSubscribe = (0, import_react2.useCallback)((patch) => {
    const subscribers = value.subscribers || [];
    props.onChange(patch);
    if (!currentUser)
      return;
    if (!subscribers.includes(currentUser.id)) {
      props.onChange(set([...subscribers, currentUser.id], ["subscribers"]));
    }
  }, [currentUser, props, value.subscribers]);
  if (!statusField) {
    throw new Error("Status field not found");
  }
  if (!((_a2 = props.value) == null ? void 0 : _a2._id)) {
    return (0, import_jsx_runtime.jsx)(LoadingBlock, {});
  }
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsxs)(Flex, { align: "flex-start", gap: 3, children: [(0, import_jsx_runtime.jsx)("div", { style: { flex: 1 }, children: (0, import_jsx_runtime.jsx)(Title, { onChange: handleChangeAndSubscribe, value: (_b2 = props.value) == null ? void 0 : _b2.title, path: ["title"], placeholder: "Task title" }) }), (0, import_jsx_runtime.jsx)(FormActionsMenu, { id: (_c2 = props.value) == null ? void 0 : _c2._id, value })] }), (0, import_jsx_runtime.jsx)(Card, { borderTop: true, marginTop: 3, children: (0, import_jsx_runtime.jsxs)(FirstRow, { paddingBottom: 3, paddingTop: 4, align: "flex-start", justify: "flex-start", wrap: "wrap", children: [(0, import_jsx_runtime.jsx)(StatusSelector, { value: (_d2 = props.value) == null ? void 0 : _d2.status, path: ["status"], onChange: handleChangeAndSubscribe, options: statusField.type.options.list }), (0, import_jsx_runtime.jsx)(AssigneeEditFormField, { value: (_e2 = props.value) == null ? void 0 : _e2.assignedTo, onChange: handleChangeAndSubscribe, path: ["assignedTo"] }), (0, import_jsx_runtime.jsx)(DateEditFormField, { value: (_f2 = props.value) == null ? void 0 : _f2.dueBy, onChange: handleChangeAndSubscribe, path: ["dueBy"] })] }) }), props.renderDefault(props), (0, import_jsx_runtime.jsx)(CommentsProvider, { documentId: value._id, documentType: "tasks.task", sortOrder: "asc", type: "task", children: (0, import_jsx_runtime.jsx)(Card, { borderTop: true, paddingTop: 4, marginTop: 4, children: (0, import_jsx_runtime.jsx)(TasksActivityLog, { value, onChange: props.onChange, path: ["subscribers"] }) }) })] });
}
function FormEdit(props) {
  const value = props.value;
  const currentUser = useCurrentUser();
  const transformPatches = (0, import_react2.useCallback)((patches) => {
    if (!currentUser)
      return patches;
    if (patches.some((patch) => patch.path[0] === "subscribers")) {
      return patches;
    }
    const subscribers = value.subscribers || [];
    const newSubscribers = [...subscribers];
    const changeAssigneePatch = patches.find((patch) => patch.path[0] === "assignedTo");
    if (changeAssigneePatch && changeAssigneePatch.type === "set" && typeof changeAssigneePatch.value === "string" && !newSubscribers.includes(changeAssigneePatch.value)) {
      newSubscribers.push(changeAssigneePatch.value);
    }
    if (!newSubscribers.includes(currentUser.id)) {
      newSubscribers.push(currentUser.id);
    }
    const changedDescriptionPatch = patches.find((patch) => patch.path[0] === "description" && patch.type === "set");
    if (changedDescriptionPatch) {
      const prevMentionedUser = getMentionedUsers(value.description);
      const newDescription = changedDescriptionPatch.type === "set" ? changedDescriptionPatch.value : void 0;
      const newMentionedUser = getMentionedUsers(newDescription);
      const diff2 = newMentionedUser.filter((user) => !prevMentionedUser.includes(user));
      diff2.forEach((user) => {
        if (!newSubscribers.includes(user)) {
          newSubscribers.push(user);
        }
      });
    }
    if (newSubscribers.length !== subscribers.length) {
      patches.push(set(newSubscribers, ["subscribers"]));
    }
    return patches;
  }, [currentUser, value.subscribers, value.description]);
  return (0, import_jsx_runtime.jsx)(TransformPatches, { transform: transformPatches, children: (0, import_jsx_runtime.jsx)(FormEditInner, { ...props }) });
}
function TasksNotificationTargetInner(props) {
  var _a2, _b2, _c2;
  const { inputProps } = props;
  const { onChange } = inputProps;
  const { target, _id, context } = useFormValue([]);
  const { title: workspaceTitle, basePath } = useWorkspace();
  const client = useClient(DEFAULT_STUDIO_CLIENT_OPTIONS);
  const imageBuilder = (0, import_react2.useMemo)(() => (0, import_image_url.default)(client), [client]);
  const documentId = (_b2 = (_a2 = target == null ? void 0 : target.document) == null ? void 0 : _a2._ref) != null ? _b2 : "";
  const documentType = (_c2 = target == null ? void 0 : target.documentType) != null ? _c2 : "";
  const { isLoading: previewValuesLoading, value } = useDocumentPreviewValues({ documentId, documentType });
  const targetContentTitle = (value == null ? void 0 : value.title) || null;
  const imageUrl = isImageSource(value == null ? void 0 : value.media) ? imageBuilder.image(value.media).width(96).height(96).url() : null;
  (0, import_react2.useEffect)(() => {
    if (documentId && documentType && previewValuesLoading) {
      return;
    }
    const studioUrl = new URL("".concat(window.location.origin).concat(basePath, "/"));
    studioUrl.searchParams.set("sidebar", "tasks");
    studioUrl.searchParams.set("selectedTask", _id);
    studioUrl.searchParams.set("viewMode", "edit");
    const notificationTarget = { url: studioUrl.toString(), workspaceTitle, targetContentImageUrl: imageUrl, targetContentTitle };
    if ((0, import_react_fast_compare.default)(notificationTarget, context == null ? void 0 : context.notification))
      return;
    onChange(set(notificationTarget, ["notification"]));
  }, [_id, basePath, workspaceTitle, documentId, documentType, previewValuesLoading, targetContentTitle, imageUrl, onChange, context]);
  return null;
}
function TasksNotificationTarget(props) {
  return (0, import_jsx_runtime.jsx)(CurrentWorkspaceProvider, { children: (0, import_jsx_runtime.jsx)(TasksNotificationTargetInner, { ...props }) });
}
var targetContentField = (mode) => defineField({ type: "object", name: "target", title: "Target content", components: { field: (props) => (0, import_jsx_runtime.jsx)(TargetField, { ...props, mode }) }, fields: [{ name: "document", type: "crossDatasetReference", dataset: "playground", weak: true, studioUrl: (_ref133) => {
  let { id, type } = _ref133;
  return "intent/edit/id=".concat(id, ";type=").concat(type, "/");
}, to: [{ type: "any_document", preview: { select: { title: "title" } } }] }, { name: "documentType", type: "string", title: "Document type" }] });
var descriptionInputField = (mode) => defineField({ type: "array", name: "description", title: "Description", components: { field: (props) => (0, import_jsx_runtime.jsx)(DescriptionInput, { ...props, mode }) }, of: [{ type: "block", name: "block", of: [{ name: "mention", type: "object", fields: [{ name: "userId", type: "string" }] }], marks: { annotations: [] }, styles: [{ title: "Normal", value: "normal" }], lists: [] }] });
var taskSchema = (mode) => defineType({ type: "document", name: "tasks.task", liveEdit: true, components: { input: mode === "edit" ? FormEdit : FormCreate }, fields: [{ type: "string", title: "Title", name: "title", placeholder: "Task title", components: { field: TitleField }, hidden: mode === "edit" }, ...mode === "edit" ? [targetContentField(mode), descriptionInputField(mode)] : [descriptionInputField(mode), targetContentField(mode)], { type: "string", name: "assignedTo", title: "Assigned to", placeholder: "Search username", components: { field: FieldWrapper, input: AssigneeCreateFormField }, hidden: mode === "edit" }, { type: "date", name: "dueBy", title: "Deadline", placeholder: "Select date", components: { field: FieldWrapper }, hidden: mode === "edit" }, { type: "string", name: "authorId", hidden: true }, { type: "string", name: "createdByUser", hidden: true }, { type: "array", of: [{ type: "string" }], name: "subscribers", hidden: true }, { type: "string", name: "status", title: "Status", options: { list: TASK_STATUS.map((s) => ({ value: s.value, title: s.title })) }, hidden: true }, { type: "object", name: "context", components: { field: TasksNotificationTarget }, fields: [{ type: "object", name: "notification", fields: [{ type: "string", name: "url" }, { type: "string", name: "workspaceTitle" }, { type: "string", name: "targetContentImageUrl" }, { type: "string", name: "targetContentTitle" }] }] }] });
function TasksAddonWorkspaceProviderInner(_ref134) {
  let { children, mode, addonDataset } = _ref134;
  const client = useClient({ apiVersion: API_VERSION });
  const apiHost = client.config().apiHost;
  const basePath = "";
  const source = useSource();
  const addonDatasetConfig = (0, import_react2.useMemo)(() => ({ basePath, dataset: addonDataset, name: "addon-dataset-".concat(addonDataset), projectId: source.projectId, apiHost, schema: { types: [taskSchema(mode)] } }), [source.projectId, mode, apiHost, addonDataset, basePath]);
  const { workspaces } = (0, import_react2.useMemo)(() => prepareConfig(addonDatasetConfig, { basePath }), [addonDatasetConfig, basePath]);
  const addonWorkspace = useWorkspaceLoader(workspaces[0]);
  if (!addonWorkspace)
    return null;
  return (0, import_jsx_runtime.jsx)(WorkspaceProvider, { workspace: addonWorkspace, children: (0, import_jsx_runtime.jsx)(SourceProvider, { source: addonWorkspace.unstable_sources[0], children: (0, import_jsx_runtime.jsx)(ResourceCacheProvider, { children }) }) });
}
function TasksAddonWorkspaceProvider(props) {
  const { client: addonDatasetClient, ready, createAddonDataset } = useAddonDataset();
  const addonDataset = addonDatasetClient == null ? void 0 : addonDatasetClient.config().dataset;
  (0, import_react2.useEffect)(() => {
    if (!addonDataset && ready) {
      createAddonDataset();
    }
  }, [addonDataset, ready, createAddonDataset]);
  if (!addonDataset) {
    return (0, import_jsx_runtime.jsx)(LoadingBlock, {});
  }
  return (0, import_jsx_runtime.jsx)(TasksAddonWorkspaceProviderInner, { ...props, addonDataset });
}
function useTasksFormBuilder(options) {
  const { documentType = "tasks.task", documentId, initialValue = {} } = options;
  const schema2 = useSchema();
  const tasksSchemaType = schema2.get(documentType);
  if (!tasksSchemaType) {
    throw new Error("Schema type for '".concat(documentType, "' not found"));
  }
  const { validation: validationRaw } = useValidationStatus(documentId, documentType);
  const validation = useUnique(validationRaw);
  const [focusPath, setFocusPath] = (0, import_react2.useState)([]);
  const [openPath, setOpenPath] = (0, import_react2.useState)([]);
  const [collapsedPaths, onSetCollapsedPath] = (0, import_react2.useState)();
  const [collapsedFieldSets, onSetCollapsedFieldSets] = (0, import_react2.useState)();
  const [fieldGroupState, onSetFieldGroupState] = (0, import_react2.useState)();
  const [presence] = (0, import_react2.useState)([]);
  const handleFocus = (0, import_react2.useCallback)((nextFocusPath) => {
    setFocusPath(nextFocusPath);
  }, [setFocusPath]);
  const handleBlur = (0, import_react2.useCallback)(() => {
    setFocusPath([]);
  }, []);
  const handleOnSetCollapsedPath = (0, import_react2.useCallback)((path, collapsed) => {
    onSetCollapsedPath((prevState) => setAtPath(prevState, path, collapsed));
  }, []);
  const handleOnSetCollapsedFieldSet = (0, import_react2.useCallback)((path, collapsed) => {
    onSetCollapsedFieldSets((prevState) => setAtPath(prevState, path, collapsed));
  }, []);
  const handleSetActiveFieldGroup = (0, import_react2.useCallback)((path, groupName) => onSetFieldGroupState((prevState) => setAtPath(prevState, path, groupName)), []);
  const { patch } = useDocumentOperation(documentId, documentType);
  const patchRef = (0, import_react2.useRef)(() => {
    throw new Error("Nope");
  });
  patchRef.current = (event) => {
    patch.execute(toMutationPatches(event.patches), initialValue);
  };
  const handleChange = (0, import_react2.useCallback)((event) => patchRef.current(event), []);
  const connectionState = useConnectionState(documentId, documentType);
  const editState = useEditState(documentId, documentType);
  const value = (editState == null ? void 0 : editState.draft) || (editState == null ? void 0 : editState.published) || initialValue;
  const formState = useFormState(tasksSchemaType, { value, comparisonValue: value, readOnly: false, changesOpen: false, presence, focusPath, openPath, collapsedPaths, collapsedFieldSets, fieldGroupState, validation });
  const ready = editState.ready && connectionState === "connected";
  const patchChannel = (0, import_react2.useMemo)(() => createPatchChannel(), []);
  if (formState === null || !ready) {
    return { loading: true };
  }
  return {
    id: "root",
    onChange: handleChange,
    // eslint-disable-next-line camelcase
    __internal_patchChannel: patchChannel,
    // eslint-disable-next-line camelcase
    __internal_fieldActions: void 0,
    onPathFocus: handleFocus,
    onPathOpen: setOpenPath,
    onPathBlur: handleBlur,
    onFieldGroupSelect: handleSetActiveFieldGroup,
    onSetFieldSetCollapsed: handleOnSetCollapsedFieldSet,
    onSetPathCollapsed: handleOnSetCollapsedPath,
    collapsedPaths,
    collapsedFieldSets,
    focusPath: formState.focusPath,
    changed: formState.changed,
    focused: formState.focused,
    groups: formState.groups,
    validation: formState.validation,
    members: formState.members,
    presence: formState.presence,
    schemaType: tasksSchemaType,
    value: formState.value
  };
}
var FormBuilderRoot = ut.div((props) => {
  const theme = getTheme_v2(props.theme);
  return "\n    // Update spacing for the form builder\n    & > [data-ui='Stack'] {\n      grid-gap: ".concat(rem(theme.space[4]), ";\n    }\n");
});
var TasksFormBuilderInner = (_ref135) => {
  let { documentId, initialValue } = _ref135;
  var _a2, _b2;
  const formBuilderProps = useTasksFormBuilder({ documentType: "tasks.task", documentId, initialValue });
  const { setSelectedDocument } = useMentionUser();
  const target = formBuilderProps.loading ? void 0 : (_a2 = formBuilderProps.value) == null ? void 0 : _a2.target;
  const targetId = (_b2 = target == null ? void 0 : target.document) == null ? void 0 : _b2._ref;
  const targetType = target == null ? void 0 : target.documentType;
  (0, import_react2.useEffect)(() => {
    const documentValue = targetId && targetType ? { _id: targetId, _type: targetType } : null;
    setSelectedDocument(documentValue);
  }, [targetId, targetType, setSelectedDocument]);
  return (0, import_jsx_runtime.jsx)(CommentsEnabledProvider, { documentId: "", documentType: "", children: (0, import_jsx_runtime.jsx)(Box, { paddingX: 4, children: formBuilderProps.loading ? (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true }) : (0, import_jsx_runtime.jsx)(FormBuilderRoot, { id: "wrapper", children: (0, import_jsx_runtime.jsx)(FormBuilder, { ...formBuilderProps }) }) }) });
};
function TasksFormBuilder() {
  const currentUser = useCurrentUser();
  const { activeDocument } = useTasks();
  const { dataset, projectId } = useWorkspace();
  const { state: { selectedTask, viewMode, duplicateTaskValues } } = useTasksNavigation();
  const initialValue = (0, import_react2.useMemo)(() => {
    if (!currentUser)
      return void 0;
    if (!selectedTask)
      return void 0;
    if (viewMode === "duplicate") {
      return {
        ...duplicateTaskValues,
        title: "".concat(duplicateTaskValues == null ? void 0 : duplicateTaskValues.title, " (copy)"),
        // Set the new task title
        createdByUser: void 0,
        // Remove the createdByUser field
        _id: selectedTask,
        // Set the new task ID
        _type: "tasks.task",
        authorId: currentUser.id,
        // Set the author ID
        status: "open"
      };
    }
    if (viewMode === "create") {
      return { _id: selectedTask, _type: "tasks.task", authorId: currentUser.id, status: "open", subscribers: [currentUser.id], target: activeDocument ? getTargetValue({ documentId: activeDocument.documentId, documentType: activeDocument.documentType, dataset, projectId }) : void 0 };
    }
    return void 0;
  }, [activeDocument, currentUser, dataset, duplicateTaskValues, projectId, selectedTask, viewMode]);
  if (!currentUser)
    return (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true, title: "Loading current user" });
  if (!selectedTask)
    return null;
  return (
    // This provider needs to be mounted before the TasksAddonWorkspaceProvider.
    (0, import_jsx_runtime.jsx)(MentionUserProvider, { children: (0, import_jsx_runtime.jsx)(TasksAddonWorkspaceProvider, { mode: viewMode === "edit" ? "edit" : "create", children: (0, import_jsx_runtime.jsx)(TasksFormBuilderInner, { documentId: selectedTask, currentUser, initialValue }) }) })
  );
}
var StyledIntentLink = ut(IntentLink)((props) => {
  const theme = getTheme_v2(props.theme);
  return "\n  text-decoration: underline;\n  text-decoration-color: ".concat(theme.color.input.default.enabled.border, ";\n  text-underline-offset: 2px;\n");
});
function DocumentPreview(_ref136) {
  let { documentId, documentType } = _ref136;
  const schema2 = useSchema();
  const documentSchema = schema2.get(documentType);
  const { isLoading, value } = useDocumentPreviewValues({ documentId, documentType });
  const Link2 = (0, import_react2.useMemo)(() => (0, import_react2.forwardRef)(function LinkComponent(linkProps, ref) {
    return (0, import_jsx_runtime.jsx)(StyledIntentLink, { ...linkProps, intent: "edit", params: { id: documentId, type: documentType }, ref });
  }), [documentId, documentType]);
  if (!documentSchema) {
    return null;
  }
  return (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 2, children: [(0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_jsx_runtime.jsx)(DocumentIcon, {}) }), isLoading ? (0, import_jsx_runtime.jsx)(TextSkeleton, { size: 1, muted: true }) : (0, import_jsx_runtime.jsx)(Text, { size: 1, as: Link2, weight: "medium", children: (value == null ? void 0 : value.title) || "Untitled" })] });
}
function TasksStatus(props) {
  const operations = useTaskOperations();
  const { documentId, status } = props;
  const [checkboxValue, setCheckboxValue] = (0, import_react2.useState)(status === "closed");
  const [isLoading, setIsLoading] = (0, import_react2.useState)(false);
  const handleCheckboxChange = (0, import_react2.useCallback)(async (event) => {
    const isChecked = event.target.checked;
    setCheckboxValue(isChecked);
    setIsLoading(true);
    try {
      if (isChecked) {
        await operations.edit(documentId, { status: "closed" });
      } else if (!isChecked) {
        await operations.edit(documentId, { status: "open" });
      }
    } catch (error) {
      console.error("An error occurred while updating the task status", error);
    } finally {
      setIsLoading(false);
    }
  }, [documentId, operations]);
  return (0, import_jsx_runtime.jsx)(Flex, { children: isLoading ? (0, import_jsx_runtime.jsx)("div", { style: { height: "17px", width: "17px" }, children: (0, import_jsx_runtime.jsx)(Spinner, { style: { marginLeft: "3.5px", marginRight: "3.5px", marginTop: "3.5px" } }) }) : (0, import_jsx_runtime.jsx)(Checkbox, { onChange: handleCheckboxChange, checked: checkboxValue, disabled: isLoading }) });
}
var __freeze$5 = Object.freeze;
var __defProp$5 = Object.defineProperty;
var __template$5 = (cooked, raw) => __freeze$5(__defProp$5(cooked, "raw", { value: __freeze$5(raw || cooked.slice()) }));
var _a$5;
var _b$3;
var _c$1;
var TitleButton = ut(Button)(_a$5 || (_a$5 = __template$5(["\n  &:hover {\n    text-decoration: underline;\n    background-color: transparent;\n  }\n"])));
var TaskDetailsRoot = ut(Flex)(_b$3 || (_b$3 = __template$5(["\n  /* Checkbox width is 17px and first row gap is 12px. */\n  margin-left: 29px;\n"])));
var UserDisplayRoot = ut.div(_c$1 || (_c$1 = __template$5(["\n  margin-left: auto;\n  display: flex;\n  align-items: center;\n"])));
function getTargetDocumentMeta(target) {
  var _a2;
  if (!((_a2 = target == null ? void 0 : target.document) == null ? void 0 : _a2._ref)) {
    return void 0;
  }
  return { _ref: target == null ? void 0 : target.document._ref, _type: target == null ? void 0 : target.documentType };
}
function TaskDueDate(_ref137) {
  let { dueBy } = _ref137;
  const fullDateFormatter = useDateTimeFormat({ dateStyle: "medium" });
  const monthAndDayFormatter = useDateTimeFormat({ month: "short", day: "numeric" });
  const dayFormatter = useDateTimeFormat({ weekday: "long" });
  const dateOptions = (0, import_react2.useMemo)(() => {
    const date = new Date(dueBy);
    return { fullDate: fullDateFormatter.format(date), monthAndDay: monthAndDayFormatter.format(date), day: dayFormatter.format(date), isDueByToday: isToday(date), isDueThisWeek: isThisISOWeek(date) };
  }, [dayFormatter, dueBy, fullDateFormatter, monthAndDayFormatter]);
  const { fullDate, monthAndDay, day, isDueByToday, isDueThisWeek } = dateOptions;
  return (0, import_jsx_runtime.jsx)(Tooltip, { content: fullDate, children: (0, import_jsx_runtime.jsx)(Card, { tone: isDueByToday ? "critical" : "transparent", padding: 1, radius: 2, children: (0, import_jsx_runtime.jsx)(Flex, { align: "center", gap: 2, children: (0, import_jsx_runtime.jsx)(Text, {
    as: "time",
    size: 1,
    dateTime: dueBy,
    muted: true,
    // eslint-disable-next-line no-nested-ternary
    children: isDueByToday ? "Today" : isDueThisWeek ? day : monthAndDay
  }) }) }) });
}
function TasksListItem(_ref138) {
  let { assignedTo, title, dueBy, target, onSelect, documentId, status } = _ref138;
  const targetDocument = (0, import_react2.useMemo)(() => getTargetDocumentMeta(target), [target]);
  return (0, import_jsx_runtime.jsx)(Card, { sizing: "border", paddingBottom: 3, borderBottom: true, children: (0, import_jsx_runtime.jsxs)(Stack, { space: 2, paddingY: 1, children: [(0, import_jsx_runtime.jsxs)(Flex, { align: "center", paddingY: 1, gap: 3, children: [(0, import_jsx_runtime.jsx)(TasksStatus, { documentId, status }), (0, import_jsx_runtime.jsx)(TitleButton, { mode: "bleed", padding: 0, onClick: onSelect, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "semibold", children: title || "Untitled" }) }), (0, import_jsx_runtime.jsx)(UserDisplayRoot, { children: (0, import_jsx_runtime.jsx)(TasksUserAvatar, { user: assignedTo ? { id: assignedTo } : void 0 }) })] }), (dueBy || targetDocument) && (0, import_jsx_runtime.jsxs)(TaskDetailsRoot, { align: "center", gap: 2, paddingY: 1, paddingX: 0, children: [dueBy && (0, import_jsx_runtime.jsx)(TaskDueDate, { dueBy }), targetDocument && (0, import_jsx_runtime.jsx)(Box, { marginLeft: 1, children: (0, import_jsx_runtime.jsx)(DocumentPreview, { documentId: targetDocument._ref, documentType: targetDocument._type }) })] })] }) });
}
var __freeze$4 = Object.freeze;
var __defProp$4 = Object.defineProperty;
var __template$4 = (cooked, raw) => __freeze$4(__defProp$4(cooked, "raw", { value: __freeze$4(raw || cooked.slice()) }));
var _a$4;
var _b$2;
var _c;
var checkboxValues = [{ name: "open", label: "To Do" }, { name: "closed", label: "Done" }];
var getLabelForStatus = (status) => {
  const statusConfig = checkboxValues.find((item) => item.name === status);
  return statusConfig == null ? void 0 : statusConfig.label;
};
var TasksListRoot = ut(Box)(_a$4 || (_a$4 = __template$4(["\n  max-height: calc(100% - 140px);\n  overflow-y: auto;\n  // Hide scrollbar\n  scrollbar-width: none;\n"])));
var Details = ut.details(_b$2 || (_b$2 = __template$4(["\n  [data-ui='summary-icon'] {\n    transition: transform 0.2s;\n    transform: rotate(-90deg);\n  }\n  &[open] [data-ui='summary-icon'] {\n    transform: rotate(0);\n  }\n"])));
var Summary = ut.summary(_c || (_c = __template$4(["\n  list-style: none;\n  ::-webkit-details-marker {\n    display: none;\n  }\n"])));
function TasksList(props) {
  var _a2, _b2;
  const { items, onTaskSelect } = props;
  const tasksByStatus = (0, import_react2.useMemo)(() => items.reduce((acc, task) => {
    if (!acc[task.status]) {
      acc[task.status] = [];
    }
    acc[task.status].push(task);
    return acc;
  }, {}), [items]);
  const renderTasksList = (0, import_react2.useCallback)((status) => {
    const tasks2 = tasksByStatus[status] || [];
    if (tasks2.length === 0) {
      return null;
    }
    return (0, import_jsx_runtime.jsxs)(Details, { open: status === "open", children: [(0, import_jsx_runtime.jsx)(Summary, { children: (0, import_jsx_runtime.jsxs)(Flex, { align: "center", gap: 1, paddingY: 1, children: [(0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", muted: true, children: getLabelForStatus(status) }), (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: (0, import_jsx_runtime.jsx)(ChevronDownIcon, { "data-ui": "summary-icon" }) })] }) }), (0, import_jsx_runtime.jsx)(Stack, { space: 3, marginTop: 3, paddingBottom: 5, children: tasks2.map((task) => (0, import_jsx_runtime.jsx)(TasksListItem, { documentId: task._id, title: task.title, dueBy: task.dueBy, assignedTo: task.assignedTo, target: task.target, onSelect: () => onTaskSelect(task._id), status: task.status }, task._id)) })] });
  }, [onTaskSelect, tasksByStatus]);
  const hasOpenTasks = ((_a2 = tasksByStatus.open) == null ? void 0 : _a2.length) > 0;
  const hasClosedTasks = ((_b2 = tasksByStatus.closed) == null ? void 0 : _b2.length) > 0;
  return (0, import_jsx_runtime.jsx)(TasksListRoot, { paddingX: 3, paddingY: 4, children: (0, import_jsx_runtime.jsx)(Stack, { space: 4, paddingTop: 2, paddingX: 1, children: !hasOpenTasks && !hasClosedTasks ? (0, import_jsx_runtime.jsx)(Box, { paddingX: 2, children: (0, import_jsx_runtime.jsx)(Text, { as: "p", size: 1, muted: true, children: "No tasks" }) }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [renderTasksList("open"), renderTasksList("closed")] }) }) });
}
var LIST_STYLES = { marginLeft: "-0.5em", justifyContent: "space-between", display: "flex" };
function TasksListTabs(_ref139) {
  let { activeTabId, onChange } = _ref139;
  const { activeDocument } = useTasks();
  const activeDocumentId = activeDocument == null ? void 0 : activeDocument.documentId;
  const [documentTabIsDisabled, setDocumentTabIsDisabled] = (0, import_react2.useState)(!activeDocumentId);
  (0, import_react2.useEffect)(() => {
    let timeoutId = null;
    if (!activeDocumentId && !documentTabIsDisabled) {
      timeoutId = setTimeout(() => {
        setDocumentTabIsDisabled(true);
        onChange("assigned");
      }, 1e3);
    }
    if (documentTabIsDisabled && activeDocumentId) {
      setDocumentTabIsDisabled(false);
    }
    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
    };
  }, [activeDocumentId, documentTabIsDisabled, onChange]);
  const tabs = (0, import_react2.useMemo)(() => [{ id: "assigned", label: "Assigned" }, { id: "subscribed", label: "Subscribed" }, { id: "document", label: "Open Document", isDisabled: documentTabIsDisabled }], [documentTabIsDisabled]);
  const handleTabChange = (0, import_react2.useCallback)((tab) => {
    if (tab.isDisabled) {
      return;
    }
    onChange(tab.id);
  }, [onChange]);
  return (0, import_jsx_runtime.jsx)(TabList, { space: 2, style: LIST_STYLES, children: tabs.map((tab) => (0, import_jsx_runtime.jsx)(Tab, { "aria-controls": "".concat(tab.id, "-panel"), id: "".concat(tab.id, "-tab"), onClick: () => handleTabChange(tab), disabled: tab == null ? void 0 : tab.isDisabled, selected: tab.id === activeTabId, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "medium", children: tab.label }) }, "".concat(tab.id, "-tab"))) });
}
function TaskSidebarContent(_ref140) {
  let { items, onTaskSelect, activeTabId, setActiveTabId } = _ref140;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Card, { paddingX: 3, paddingY: 2, borderBottom: true, children: (0, import_jsx_runtime.jsx)(TasksListTabs, { activeTabId, onChange: setActiveTabId }) }), (0, import_jsx_runtime.jsx)(TasksList, { items, onTaskSelect })] });
}
var Divider = ut.div((props) => {
  const theme = getTheme_v2(props.theme);
  return "\n    height: 25px;\n    width: 1px;\n    background-color: ".concat(theme.color.input.default.enabled.border, ";\n  ");
});
function TasksActiveTabNavigation(props) {
  const { items: allItems } = props;
  const { state: state2, setViewMode } = useTasksNavigation();
  const { selectedTask } = state2;
  const items = allItems.filter((t) => t.status === "open");
  const currentItemIndex = items.findIndex((item) => item._id === selectedTask);
  const goToPreviousTask = (0, import_react2.useCallback)(() => {
    const prevTaskId = currentItemIndex > 0 ? items[currentItemIndex - 1]._id : items[items.length - 1]._id;
    setViewMode({ type: "edit", id: prevTaskId });
  }, [currentItemIndex, items, setViewMode]);
  const goToNextTask = (0, import_react2.useCallback)(() => {
    const nextTaskId = currentItemIndex < items.length - 1 ? items[currentItemIndex + 1]._id : items[0]._id;
    setViewMode({ type: "edit", id: nextTaskId });
  }, [currentItemIndex, items, setViewMode]);
  if (!items.length)
    return null;
  return (0, import_jsx_runtime.jsx)(TooltipDelayGroupProvider, { children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, align: "center", children: [(0, import_jsx_runtime.jsx)(Button2, { tooltipProps: { content: "Go to previous task" }, mode: "bleed", icon: ChevronLeftIcon, onClick: goToPreviousTask }), (0, import_jsx_runtime.jsx)(Tooltip, { content: "Open tasks", children: (0, import_jsx_runtime.jsx)(Box, { paddingY: 2, children: (0, import_jsx_runtime.jsxs)(Text, { size: 1, children: [currentItemIndex + 1, " / ", items.length] }) }) }), (0, import_jsx_runtime.jsx)(Button2, { tooltipProps: { content: "Go to next task" }, mode: "bleed", icon: ChevronRightIcon, onClick: goToNextTask }), (0, import_jsx_runtime.jsx)(Divider, {})] }) });
}
function DraftsMenu() {
  const { data } = useTasks();
  const { state: state2, setViewMode } = useTasksNavigation();
  const { viewMode, selectedTask } = state2;
  const user = useCurrentUser();
  const draftTasks = (0, import_react2.useMemo)(() => {
    if (!(user == null ? void 0 : user.id))
      return [];
    return data.filter((task) => {
      const isAuthoredByUser = task.authorId === user.id;
      const isDraft = !task.createdByUser;
      const isNotTheTaskBeingCreated = viewMode === "create" ? task._id !== selectedTask : true;
      return isAuthoredByUser && isDraft && isNotTheTaskBeingCreated;
    });
  }, [data, selectedTask, user == null ? void 0 : user.id, viewMode]);
  const renderMenuItem = (0, import_react2.useCallback)((item) => {
    const handleSelectTask = () => {
      setViewMode({ type: "draft", id: item._id });
    };
    const title = item.title || "Untitled";
    const text = selectedTask === item._id ? "(editing) ".concat(title) : title;
    return (0, import_jsx_runtime.jsx)(MenuItem2, { text, onClick: handleSelectTask }, item._id);
  }, [setViewMode, selectedTask]);
  if (!draftTasks.length)
    return null;
  return (0, import_jsx_runtime.jsx)(MenuButton, { id: "edit-task-menu", button: (0, import_jsx_runtime.jsx)(Button2, { text: "Drafts", mode: "ghost", iconRight: ChevronDownIcon }), popover: { placement: "bottom-end", portal: true }, menu: (0, import_jsx_runtime.jsxs)(Menu, { children: [(0, import_jsx_runtime.jsxs)(Flex, { padding: 3, gap: 2, align: "flex-end", children: [(0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "semibold", children: "Drafts" }), (0, import_jsx_runtime.jsx)(Text, { size: 0, muted: true, children: "continue working on your drafts" })] }), (0, import_jsx_runtime.jsx)(MenuDivider, {}), draftTasks.map(renderMenuItem)] }) });
}
function TasksSidebarHeader(props) {
  const { items: allItems } = props;
  const { state: state2, setViewMode, handleCloseTasks } = useTasksNavigation();
  const { viewMode, activeTabId } = state2;
  const handleTaskCreate = (0, import_react2.useCallback)(() => {
    setViewMode({ type: "create" });
  }, [setViewMode]);
  const handleGoBack = (0, import_react2.useCallback)(() => {
    setViewMode({ type: "list" });
  }, [setViewMode]);
  return (0, import_jsx_runtime.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime.jsxs)(Flex, { padding: 1, justify: "space-between", align: "center", gap: 1, children: [(0, import_jsx_runtime.jsxs)(Flex, { align: "center", flex: 1, children: [viewMode === "list" ? (0, import_jsx_runtime.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime.jsx)(Text, { size: 2, weight: "semibold", children: "Tasks" }) }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(Button, { mode: "bleed", space: 2, padding: 2, onClick: handleGoBack, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: "Tasks" }) }), (0, import_jsx_runtime.jsx)(ChevronRightIcon, {}), (0, import_jsx_runtime.jsx)(Box, { paddingX: 2, children: (0, import_jsx_runtime.jsx)(Text, { size: 1, weight: "semibold", style: { textTransform: "capitalize" }, children: viewMode === "create" || viewMode === "draft" ? "Create" : activeTabId }) })] }), (0, import_jsx_runtime.jsx)(BetaBadge, { marginLeft: 2 })] }), (viewMode === "create" || viewMode === "draft") && (0, import_jsx_runtime.jsx)(DraftsMenu, {}), viewMode === "edit" && (0, import_jsx_runtime.jsx)(TasksActiveTabNavigation, { items: allItems }), (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, children: [viewMode === "list" && (0, import_jsx_runtime.jsx)(Button2, { icon: AddIcon, onClick: handleTaskCreate, mode: "bleed", text: "New task" }), (0, import_jsx_runtime.jsx)(Button2, { tooltipProps: { content: "Close sidebar" }, iconRight: CloseIcon, mode: "bleed", onClick: handleCloseTasks })] })] }) });
}
var __freeze$3 = Object.freeze;
var __defProp$3 = Object.defineProperty;
var __template$3 = (cooked, raw) => __freeze$3(__defProp$3(cooked, "raw", { value: __freeze$3(raw || cooked.slice()) }));
var _a$3;
var _b$1;
var SidebarRoot = ut(Card)(_a$3 || (_a$3 = __template$3(["\n  flex: 1;\n"])));
var SidebarContent = ut.div(_b$1 || (_b$1 = __template$3(["\n  max-height: calc(100% - 52px);\n  overflow: scroll;\n"])));
function TasksStudioSidebarInner() {
  const { activeDocument, data, isLoading } = useTasks();
  const { state: state2, setActiveTab, setViewMode } = useTasksNavigation();
  const { activeTabId, viewMode, selectedTask } = state2;
  const currentUser = useCurrentUser();
  const onTaskSelect = (0, import_react2.useCallback)((id) => setViewMode({ type: "edit", id }), [setViewMode]);
  const filteredList = (0, import_react2.useMemo)(() => {
    return data.filter((item) => {
      var _a2, _b2;
      if (!item.createdByUser)
        return false;
      if (activeTabId === "assigned") {
        return item.assignedTo === (currentUser == null ? void 0 : currentUser.id);
      }
      if (activeTabId === "subscribed") {
        return (currentUser == null ? void 0 : currentUser.id) && ((_a2 = item.subscribers) == null ? void 0 : _a2.includes(currentUser.id));
      }
      if (activeTabId === "document") {
        return (activeDocument == null ? void 0 : activeDocument.documentId) && ((_b2 = item.target) == null ? void 0 : _b2.document._ref) === activeDocument.documentId;
      }
      return false;
    });
  }, [activeDocument == null ? void 0 : activeDocument.documentId, activeTabId, data, currentUser]);
  return (0, import_jsx_runtime.jsxs)(SidebarRoot, { height: "fill", flex: 1, children: [(0, import_jsx_runtime.jsx)(TasksSidebarHeader, { items: filteredList }), (0, import_jsx_runtime.jsx)(SidebarContent, { children: viewMode === "list" ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: isLoading ? (0, import_jsx_runtime.jsx)(Box, { padding: 3, children: (0, import_jsx_runtime.jsx)(Flex, { align: "center", justify: "center", children: (0, import_jsx_runtime.jsx)(Spinner, {}) }) }) : (0, import_jsx_runtime.jsx)(TaskSidebarContent, { items: filteredList, onTaskSelect, setActiveTabId: setActiveTab, activeTabId }) }) : (0, import_jsx_runtime.jsx)(TasksFormBuilder, {}, selectedTask) })] });
}
function TasksStudioSidebar() {
  const { enabled } = useTasksEnabled();
  if (!enabled)
    return null;
  return (0, import_jsx_runtime.jsx)(TasksStudioSidebarInner, {});
}
function TaskCreateAction() {
  const { handleOpenTasks, setViewMode } = useTasksNavigation();
  const { enabled } = useTasksEnabled();
  const handleCreateTaskFromDocument = (0, import_react2.useCallback)(() => {
    handleOpenTasks();
    setViewMode({ type: "create" });
  }, [handleOpenTasks, setViewMode]);
  if (!enabled)
    return null;
  return { icon: TaskIcon, label: "Create new task", title: "Create new task", group: ["paneActions"], onHandle: handleCreateTaskFromDocument };
}
function SetActiveDocumentInner(document2) {
  const { documentId, documentType } = document2;
  const { isLast } = usePane();
  const { setActiveDocument } = useTasks();
  (0, import_react2.useEffect)(() => {
    if (documentId && isLast && documentType) {
      setActiveDocument == null ? void 0 : setActiveDocument({ documentId: getPublishedId(documentId), documentType });
    }
    return () => {
      if (isLast) {
        setActiveDocument == null ? void 0 : setActiveDocument(null);
      }
    };
  }, [documentId, documentType, isLast, setActiveDocument]);
  return null;
}
function SetActiveDocument(document2) {
  const { enabled } = useTasksEnabled();
  if (!enabled)
    return null;
  return (0, import_jsx_runtime.jsx)(SetActiveDocumentInner, { ...document2 });
}
function TasksDocumentInputLayout(props) {
  var _a2, _b2;
  const documentId = (_a2 = props.value) == null ? void 0 : _a2._id;
  const documentType = (_b2 = props.value) == null ? void 0 : _b2._type;
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(SetActiveDocument, { documentId, documentType }), props.renderDefault(props)] });
}
var __freeze$2 = Object.freeze;
var __defProp$2 = Object.defineProperty;
var __template$2 = (cooked, raw) => __freeze$2(__defProp$2(cooked, "raw", { value: __freeze$2(raw || cooked.slice()) }));
var _a$2;
var ButtonContainer = ut.div(_a$2 || (_a$2 = __template$2(["\n  position: relative;\n  [data-ui='Badge'] {\n    position: absolute;\n    top: -2px;\n    right: -2px;\n  }\n"])));
function TasksFooterOpenTasks() {
  const { data, activeDocument } = useTasks();
  const { handleOpenTasks, setActiveTab } = useTasksNavigation();
  const { enabled } = useTasksEnabled();
  const mediaIndex = useMediaIndex();
  const pendingTasks = (0, import_react2.useMemo)(() => data.filter((item) => {
    var _a2;
    return ((_a2 = item.target) == null ? void 0 : _a2.document._ref) === (activeDocument == null ? void 0 : activeDocument.documentId) && item.status === "open" && item.createdByUser;
  }), [activeDocument, data]);
  const handleOnClick = (0, import_react2.useCallback)(() => {
    handleOpenTasks();
    setActiveTab("document");
  }, [handleOpenTasks, setActiveTab]);
  if (pendingTasks.length === 0 || !enabled)
    return null;
  const pluralizedTask = "task".concat(pendingTasks.length > 1 ? "s" : "");
  if (mediaIndex < 3) {
    return (0, import_jsx_runtime.jsxs)(ButtonContainer, { children: [(0, import_jsx_runtime.jsx)(Button2, { mode: "bleed", icon: TaskIcon, size: "large", onClick: handleOnClick, tooltipProps: { content: "Open ".concat(pluralizedTask) } }), (0, import_jsx_runtime.jsx)(Badge, { tone: "primary", fontSize: 0, children: pendingTasks.length })] });
  }
  return (0, import_jsx_runtime.jsx)(Button2, { mode: "bleed", tooltipProps: { content: "Open ".concat(pluralizedTask) }, text: "".concat(pendingTasks.length, " open ").concat(pluralizedTask), onClick: handleOnClick });
}
var __freeze$1 = Object.freeze;
var __defProp$1 = Object.defineProperty;
var __template$1 = (cooked, raw) => __freeze$1(__defProp$1(cooked, "raw", { value: __freeze$1(raw || cooked.slice()) }));
var _a$1;
var _b;
var VARIANTS = { hidden: { opacity: 0 }, visible: { opacity: 1 } };
var TRANSITION = { duration: 0.2 };
var FULLSCREEN_MEDIA_INDEX = 1;
var POSITION_ABSOLUTE_MEDIA_INDEX = 2;
var RootFlex = ut(Flex)((_ref141) => {
  let { theme } = _ref141;
  const media = theme.sanity.media;
  return at(_a$1 || (_a$1 = __template$1(["\n    min-height: 100%;\n\n    @media (max-width: ", "px) {\n      position: relative;\n    }\n  "])), media[POSITION_ABSOLUTE_MEDIA_INDEX]);
});
var SidebarMotionLayer = ut(motion(Layer))((_ref142) => {
  let { theme } = _ref142;
  const media = theme.sanity.media;
  return at(_b || (_b = __template$1(["\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n    width: 360px;\n    border-left: 1px solid var(--card-border-color);\n    box-sizing: border-box;\n\n    box-shadow:\n      0px 6px 8px -4px var(--card-shadow-umbra-color),\n      0px 12px 17px -1px var(--card-shadow-penumbra-color);\n\n    @media (max-width: ", "px) {\n      bottom: 0;\n      position: absolute;\n      right: 0;\n      top: 0;\n    }\n\n    @media (max-width: ", "px) {\n      border-left: 0;\n      min-width: 100%;\n      left: 0;\n    }\n  "])), media[POSITION_ABSOLUTE_MEDIA_INDEX], media[FULLSCREEN_MEDIA_INDEX]);
});
function TasksStudioActiveToolLayoutInner(props) {
  const mediaIndex = useMediaIndex();
  const { state: { isOpen } } = useTasksNavigation();
  const scrollLock = mediaIndex <= FULLSCREEN_MEDIA_INDEX && isOpen;
  return (0, import_jsx_runtime.jsxs)(RootFlex, { sizing: "border", height: "fill", children: [(0, import_jsx_runtime.jsx)(Box, { flex: 1, height: "fill", overflow: scrollLock ? "hidden" : "auto", children: props.renderDefault(props) }), (0, import_jsx_runtime.jsx)(AnimatePresence, { initial: false, children: isOpen && (0, import_jsx_runtime.jsx)(SidebarMotionLayer, { animate: "visible", height: "fill", initial: "hidden", transition: TRANSITION, variants: VARIANTS, children: (0, import_jsx_runtime.jsx)(TasksStudioSidebar, {}) }) })] });
}
function TasksStudioActiveToolLayout(props) {
  const { enabled } = useTasksEnabled();
  if (!enabled) {
    return props.renderDefault(props);
  }
  return (0, import_jsx_runtime.jsx)(TasksStudioActiveToolLayoutInner, { ...props });
}
var TasksStudioLayoutInner = (props) => {
  const { enabled } = useTasksEnabled();
  if (!enabled) {
    return props.renderDefault(props);
  }
  return (0, import_jsx_runtime.jsx)(AddonDatasetProvider, { children: (0, import_jsx_runtime.jsx)(TasksProvider, { children: (0, import_jsx_runtime.jsx)(TasksNavigationProvider, { children: props.renderDefault(props) }) }) });
};
function TasksStudioLayout(props) {
  return (0, import_jsx_runtime.jsx)(TasksEnabledProvider, { children: (0, import_jsx_runtime.jsx)(TasksStudioLayoutInner, { ...props }) });
}
var EMPTY_ARRAY = [];
function TasksStudioNavbarInner(props) {
  const { handleCloseTasks, handleOpenTasks, state: { isOpen } } = useTasksNavigation();
  const handleAction = (0, import_react2.useCallback)(() => {
    if (isOpen) {
      handleCloseTasks();
    } else {
      handleOpenTasks();
    }
  }, [handleCloseTasks, handleOpenTasks, isOpen]);
  const actions = (0, import_react2.useMemo)(() => {
    return [...(props == null ? void 0 : props.__internal_actions) || EMPTY_ARRAY, { icon: PanelRightIcon, location: "topbar", name: "tasks-topbar", onAction: handleAction, selected: isOpen, title: "Tasks" }, { icon: TaskIcon, location: "sidebar", name: "tasks-sidebar", onAction: handleAction, selected: isOpen, title: "Tasks" }];
  }, [handleAction, isOpen, props == null ? void 0 : props.__internal_actions]);
  return props.renderDefault({
    ...props,
    // eslint-disable-next-line camelcase
    __internal_actions: actions
  });
}
function TasksStudioNavbar(props) {
  const { enabled } = useTasksEnabled();
  if (!enabled) {
    return props.renderDefault(props);
  }
  return (0, import_jsx_runtime.jsx)(TasksStudioNavbarInner, { ...props });
}
var tasks = definePlugin({
  name: "sanity/tasks",
  // eslint-disable-next-line camelcase
  __internal_tasks: { footerAction: (0, import_jsx_runtime.jsx)(TasksFooterOpenTasks, {}) },
  document: { actions: (prev) => {
    return [...prev, TaskCreateAction].filter(Boolean);
  } },
  studio: { components: { layout: TasksStudioLayout, navbar: TasksStudioNavbar, activeToolLayout: TasksStudioActiveToolLayout } },
  form: { components: { input: (props) => {
    var _a2;
    if (props.id === "root" && ((_a2 = props.schemaType.type) == null ? void 0 : _a2.name) === "document") {
      return (0, import_jsx_runtime.jsx)(TasksDocumentInputLayout, { ...props });
    }
    return props.renderDefault(props);
  } } }
});
var LiveEditBadge = (props) => {
  const { liveEdit } = props;
  if (liveEdit) {
    return { label: "Live", color: "danger" };
  }
  return null;
};
var state = { activePanes: [] };
function setActivePanes(panes) {
  state.activePanes = panes;
}
function getIntentState(intent, params, routerState, payload) {
  var _a2;
  const panes = (routerState == null ? void 0 : routerState.panes) || [];
  const activePanes = state.activePanes || [];
  const editDocumentId = params.id || v4_default();
  const isTemplate = intent === "create" && params.template;
  for (let i = activePanes.length - 1; i >= 0; i--) {
    const pane = activePanes[i];
    if (typeof pane !== "object")
      continue;
    if (((_a2 = pane.canHandleIntent) == null ? void 0 : _a2.call(pane, intent, params, { pane, index: i })) || // see `resolveIntent.ts` for more info
    pane.type === "documentList" && pane.schemaTypeName === params.type && pane.options.filter === "_type == $type") {
      const paneParams = isTemplate ? { template: params.template } : EMPTY_PARAMS$1;
      return { panes: panes.slice(0, i).concat([[{ id: editDocumentId, params: paneParams, payload }]]) };
    }
  }
  return { intent, params, payload };
}
function collectLatestAuthorAnnotations(diff2) {
  const authorMap = /* @__PURE__ */ new Map();
  visitDiff(diff2, (child) => {
    if (child.action === "unchanged" || !("annotation" in child) || !child.annotation) {
      return true;
    }
    const { author, timestamp } = child.annotation;
    const previous = authorMap.get(author);
    if (!previous || previous.timestamp < timestamp) {
      authorMap.set(author, child.annotation);
    }
    return true;
  });
  return Array.from(authorMap.values()).sort((a, b) => a.timestamp < b.timestamp ? 1 : -1);
}
var __freeze = Object.freeze;
var __defProp = Object.defineProperty;
var __template = (cooked, raw) => __freeze(__defProp(cooked, "raw", { value: __freeze(raw || cooked.slice()) }));
var _a;
var Scroller = ut(ScrollContainer)(_a || (_a = __template(["\n  height: 100%;\n  overflow: auto;\n  position: relative;\n  scroll-behavior: smooth;\n"])));
function ChangesInspector(props) {
  const { onClose } = props;
  const { documentId, schemaType, timelineError, timelineStore, value } = useDocumentPane();
  const scrollRef = (0, import_react2.useRef)(null);
  const diff2 = useTimelineSelector(timelineStore, (state2) => state2.diff);
  const onOlderRevision = useTimelineSelector(timelineStore, (state2) => state2.onOlderRevision);
  const selectionState = useTimelineSelector(timelineStore, (state2) => state2.selectionState);
  const sinceTime = useTimelineSelector(timelineStore, (state2) => state2.sinceTime);
  const loading = selectionState === "loading";
  const isComparingCurrent = !onOlderRevision;
  const { t } = useTranslation2("studio");
  const documentContext = (0, import_react2.useMemo)(() => ({ documentId, schemaType, FieldWrapper: ChangeFieldWrapper, rootDiff: diff2, isComparingCurrent, value }), [documentId, diff2, isComparingCurrent, schemaType, value]);
  const changeAnnotations = (0, import_react2.useMemo)(() => diff2 ? collectLatestAuthorAnnotations(diff2) : [], [diff2]);
  return (0, import_jsx_runtime.jsxs)(Flex, { "data-testid": "review-changes-pane", direction: "column", height: "fill", overflow: "hidden", children: [(0, import_jsx_runtime.jsx)(DocumentInspectorHeader, { as: "header", closeButtonLabel: t("changes.action.close-label"), flex: "none", onClose, title: t("changes.title"), children: (0, import_jsx_runtime.jsxs)(Flex, { gap: 1, padding: 3, paddingTop: 0, paddingBottom: 2, children: [(0, import_jsx_runtime.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime.jsx)(TimelineMenu, { mode: "since", chunk: sinceTime, placement: "bottom-start" }) }), (0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsx)(DiffTooltip, { annotations: changeAnnotations, description: t("changes.changes-by-author"), portal: true, children: (0, import_jsx_runtime.jsx)(AvatarStack, { maxLength: 4, "aria-label": t("changes.changes-by-author"), children: changeAnnotations.map((_ref143) => {
    let { author } = _ref143;
    return (0, import_jsx_runtime.jsx)(UserAvatar, { user: author }, author);
  }) }) }) })] }) }), (0, import_jsx_runtime.jsx)(Card, { flex: 1, children: (0, import_jsx_runtime.jsx)(BoundaryElementProvider, { element: scrollRef.current, children: (0, import_jsx_runtime.jsx)(Scroller, { "data-ui": "Scroller", ref: scrollRef, children: (0, import_jsx_runtime.jsx)(Box, { flex: 1, padding: 4, children: (0, import_jsx_runtime.jsx)(Content, { diff: diff2, documentContext, error: timelineError, loading, schemaType }) }) }) }) })] });
}
function Content(_ref144) {
  let { error, diff: diff2, documentContext, loading, schemaType } = _ref144;
  if (error) {
    return (0, import_jsx_runtime.jsx)(NoChanges, {});
  }
  if (loading) {
    return (0, import_jsx_runtime.jsx)(LoadingBlock, { showText: true });
  }
  if (!diff2) {
    return (0, import_jsx_runtime.jsx)(NoChanges, {});
  }
  return (0, import_jsx_runtime.jsx)(DocumentChangeContext.Provider, { value: documentContext, children: (0, import_jsx_runtime.jsx)(ChangeList, { diff: diff2, schemaType }) });
}
var changesInspector = { name: HISTORY_INSPECTOR_NAME, useMenuItem: () => {
  const { features } = useStructureTool();
  const { t } = useTranslation2();
  return { hidden: !features.reviewChanges, icon: RestoreIcon, title: t("changes.title") };
}, component: ChangesInspector, onClose: (_ref145) => {
  let { params } = _ref145;
  return { params: { ...params, since: void 0 } };
}, onOpen: (_ref146) => {
  let { params } = _ref146;
  return { params: { ...params, since: "@lastPublished" } };
} };
function getPathTitles(options) {
  const { path, schemaType, value } = options;
  const result = [];
  let s = schemaType;
  let v = value;
  for (const segment of path) {
    if (typeof segment === "string") {
      if (!isRecord$4(v) && v !== void 0) {
        throw new Error("Parent value is not an object, cannot get path segment: .".concat(segment));
      }
      if (s.jsonType !== "object") {
        throw new Error("Parent type is not an object schema type, cannot get path segment: .".concat(segment));
      }
      v = v == null ? void 0 : v[segment];
      const field = s.fields.find((f) => f.name === segment);
      if (!field) {
        result.push({ name: segment });
        return result;
      }
      s = field.type;
      result.push(s);
      continue;
    }
    if (typeof segment === "number") {
      if (!isArray(v) && v !== void 0) {
        throw new Error("Parent value is not an array, cannot get path segment: [".concat(segment, "]"));
      }
      if (s.jsonType !== "array") {
        throw new Error("Parent type is not an array schema type, cannot get path segment: [".concat(segment, "]"));
      }
      v = v == null ? void 0 : v[segment];
      const itemType = s.of.find((ofType) => {
        if (typeof v === "string") {
          return ofType.jsonType === "string";
        }
        if (typeof v === "number") {
          return ofType.jsonType === "number";
        }
        if (typeof v === "boolean") {
          return ofType.jsonType === "boolean";
        }
        if (isRecord$4(v)) {
          return ofType.name === (v == null ? void 0 : v._type);
        }
        return false;
      });
      if (!itemType) {
        throw new Error("Item type not found: [".concat(segment, "]"));
      }
      s = itemType;
      result.push(s);
      continue;
    }
    if (isRecord$4(segment) && segment._key) {
      if (!isArray(v)) {
        throw new Error("Parent value is not an array, cannot get path segment: [_key == ".concat(segment, "]"));
      }
      if (s.jsonType !== "array") {
        throw new Error("Parent type is not an array schema type, cannot get path segment: .".concat(segment));
      }
      const values = v != null ? v : [];
      v = values.find((i) => isRecord$4(i) && i._key === segment._key);
      if (!isRecord$4(v)) {
        throw new Error("Array item not found: [_key == ".concat(segment._key, "]"));
      }
      const ofType = s.of.find((i) => isRecord$4(v) && i.name === (v == null ? void 0 : v._type));
      if (!ofType) {
        throw new Error("Array item type not found: .".concat(v == null ? void 0 : v._type));
      }
      s = ofType;
      result.push(s);
      continue;
    }
    throw new Error("Invalid path segment: ".concat(JSON.stringify(segment)));
  }
  return result;
}
var MARKER_ICON = { error: ErrorOutlineIcon, warning: WarningOutlineIcon, info: InfoOutlineIcon };
var MARKER_TONE = { error: "critical", warning: "caution", info: "primary" };
function ValidationInspector(props) {
  const { onClose } = props;
  const { onFocus, onPathOpen, schemaType, validation, value } = useDocumentPane();
  const { t } = useTranslation2("validation");
  const handleOpen = (0, import_react2.useCallback)((path) => {
    onPathOpen(path);
    onFocus(path);
  }, [onFocus, onPathOpen]);
  return (0, import_jsx_runtime.jsxs)(Flex, { direction: "column", height: "fill", overflow: "hidden", children: [(0, import_jsx_runtime.jsx)(DocumentInspectorHeader, { as: "header", closeButtonLabel: t("panel.close-button-aria-label"), flex: "none", onClose, title: t("panel.title") }), (0, import_jsx_runtime.jsxs)(Card, { flex: 1, overflow: "auto", padding: 3, children: [validation.length === 0 && (0, import_jsx_runtime.jsx)(Box, { padding: 2, children: (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: t("panel.no-errors-message") }) }), validation.length > 0 && (0, import_jsx_runtime.jsx)(Stack, { space: 2, children: validation.map((marker, i) => (0, import_jsx_runtime.jsx)(ValidationCard, { marker, onOpen: handleOpen, schemaType, value }, i)) })] })] });
}
function ValidationCard(props) {
  const { marker, onOpen, schemaType, value } = props;
  const handleOpen = (0, import_react2.useCallback)(() => onOpen(marker.path), [marker, onOpen]);
  const [errorInfo, setErrorInfo] = (0, import_react2.useState)(null);
  return (0, import_jsx_runtime.jsxs)(ErrorBoundary, { onCatch: setErrorInfo, children: [errorInfo && (0, import_jsx_runtime.jsx)(Card, { padding: 3, radius: 2, tone: "critical", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: errorInfo.error.message }) }), !errorInfo && (0, import_jsx_runtime.jsx)(Card, { __unstable_focusRing: true, as: "button", onClick: handleOpen, padding: 3, radius: 2, tone: MARKER_TONE[marker.level], children: (0, import_jsx_runtime.jsxs)(Flex, { align: "flex-start", gap: 3, children: [(0, import_jsx_runtime.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime.jsx)(Text, { size: 1, children: (0, import_react2.createElement)(MARKER_ICON[marker.level]) }) }), (0, import_jsx_runtime.jsxs)(Stack, { flex: 1, space: 2, children: [(0, import_jsx_runtime.jsx)(DocumentNodePathBreadcrumbs, { path: marker.path, schemaType, value }), (0, import_jsx_runtime.jsx)(Text, { muted: true, size: 1, children: marker.message })] })] }) })] });
}
function DocumentNodePathBreadcrumbs(props) {
  const { path, schemaType, value } = props;
  const pathTitles = (0, import_react2.useMemo)(() => getPathTitles({ path, schemaType, value }), [path, schemaType, value]);
  if (!pathTitles.length)
    return null;
  return (0, import_jsx_runtime.jsx)(Text, { size: 1, children: pathTitles.map((t, i) => (0, import_jsx_runtime.jsxs)(import_react2.Fragment, { children: [i > 0 && (0, import_jsx_runtime.jsx)("span", { style: { color: "var(--card-muted-fg-color)", opacity: 0.5 }, children: " / " }), (0, import_jsx_runtime.jsx)("span", { style: { fontWeight: 500 }, children: t.title || t.name })] }, i)) });
}
function useMenuItem(props) {
  const { documentId, documentType } = props;
  const { t } = useTranslation2("validation");
  const { validation: validationMarkers } = useValidationStatus(documentId, documentType);
  const validation = (0, import_react2.useMemo)(() => validationMarkers.map((item) => ({ level: item.level, message: item.message, path: item.path })), [validationMarkers]);
  const hasErrors = validation.some(isValidationError);
  const hasWarnings = validation.some(isValidationWarning);
  const icon = (0, import_react2.useMemo)(() => {
    if (hasErrors)
      return ErrorOutlineIcon;
    if (hasWarnings)
      return WarningOutlineIcon;
    return CheckmarkCircleIcon;
  }, [hasErrors, hasWarnings]);
  const tone = (0, import_react2.useMemo)(() => {
    if (hasErrors)
      return "critical";
    if (hasWarnings)
      return "caution";
    return "positive";
  }, [hasErrors, hasWarnings]);
  return { hidden: validation.length === 0, icon, title: t("panel.title"), tone, showAsAction: true };
}
var validationInspector = { name: VALIDATION_INSPECTOR_NAME, component: ValidationInspector, useMenuItem };
var EMPTY_PARAMS = {};
function legacyEditParamsToState(params) {
  try {
    return JSON.parse(decodeURIComponent(params));
  } catch (err) {
    console.warn("Failed to parse JSON parameters");
    return {};
  }
}
function encodePanesSegment(panes) {
  return (panes || []).map((group) => group.map(encodeChunks).join("|")).map(encodeURIComponent).join(";");
}
function legacyEditParamsToPath(params) {
  return JSON.stringify(params);
}
function toState(pathSegment) {
  return parsePanesSegment(decodeURIComponent(pathSegment));
}
function toPath(panes) {
  return encodePanesSegment(panes);
}
var router = route.create("/", [
  // "Asynchronous intent resolving" route
  route.intents("/intent"),
  // Legacy fallback route, will be redirected to new format
  route.create("/edit/:type/:editDocumentId", [route.create({ path: "/:params", transform: { params: { toState: legacyEditParamsToState, toPath: legacyEditParamsToPath } } })]),
  // The regular path - when the intent can be resolved to a specific pane
  route.create({
    path: "/:panes",
    // Legacy URLs, used to handle redirects
    children: [route.create("/:action", route.create("/:legacyEditDocumentId"))],
    transform: { panes: { toState, toPath } }
  })
]);
var panePattern = /^([.a-z0-9_-]+),?({.*?})?(?:(;|$))/i;
var isParam = (str) => /^[a-z0-9]+=[^=]+/i.test(str);
var isPayloadLike = (str) => /^[A-Za-z0-9\-_]+(?:={0,2})$/.test(str);
var exclusiveParams = ["view", "since", "rev", "inspect", "comment"];
var isTruthy = Boolean;
function parseChunks(chunks, initial) {
  const sibling = { ...initial, params: EMPTY_PARAMS, payload: void 0 };
  return chunks.reduce((pane, chunk) => {
    if (isParam(chunk)) {
      const key = chunk.slice(0, chunk.indexOf("="));
      const value = chunk.slice(key.length + 1);
      pane.params = { ...pane.params, [decodeURIComponent(key)]: decodeURIComponent(value) };
    } else if (isPayloadLike(chunk)) {
      pane.payload = tryParseBase64Payload(chunk);
    } else {
      console.warn("Unknown pane segment: %s - skipping", chunk);
    }
    return pane;
  }, sibling);
}
function encodeChunks(pane, index, group) {
  const { payload, params = {}, id } = pane;
  const [firstSibling] = group;
  const paneIsFirstSibling = pane === firstSibling;
  const sameAsFirst = index !== 0 && id === firstSibling.id;
  const encodedPayload = typeof payload === "undefined" ? void 0 : encodeJsonParams(payload);
  const encodedParams = Object.entries(params).filter((entry) => {
    var _a2;
    const [key, value] = entry;
    if (!value)
      return false;
    if (paneIsFirstSibling)
      return true;
    const valueFromFirstSibling = (_a2 = firstSibling.params) == null ? void 0 : _a2[key];
    if (value === valueFromFirstSibling && !exclusiveParams.includes(key))
      return false;
    return true;
  }).map((_ref147) => {
    let [key, value] = _ref147;
    return "".concat(encodeURIComponent(key), "=").concat(encodeURIComponent(value));
  });
  return [sameAsFirst ? "" : id].concat([encodedParams.length > 0 && encodedParams, encodedPayload].filter(isTruthy).flat()).join(",") || ",";
}
function parsePanesSegment(str) {
  if (str.indexOf(",{") !== -1) {
    return parseOldPanesSegment(str);
  }
  return str.split(";").map((group) => {
    const [firstSibling, ...restOfSiblings] = group.split("|").map((segment) => {
      const [id, ...chunks] = segment.split(",");
      return parseChunks(chunks, { id });
    });
    return [firstSibling, ...restOfSiblings.map((sibling) => ({ ...firstSibling, ...sibling, id: sibling.id || firstSibling.id, params: { ...(0, import_omit.default)(firstSibling.params, exclusiveParams), ...sibling.params }, payload: sibling.payload || firstSibling.payload }))];
  }).filter((group) => group.length > 0);
}
function parseOldPanesSegment(str) {
  const chunks = [];
  let buffer = str;
  while (buffer.length) {
    const [match, id, payloadChunk] = buffer.match(panePattern) || [];
    if (!match) {
      buffer = buffer.slice(1);
      continue;
    }
    const payload = payloadChunk && tryParsePayload(payloadChunk);
    chunks.push({ id, payload });
    buffer = buffer.slice(match.length);
  }
  return [chunks];
}
function tryParsePayload(json) {
  try {
    return JSON.parse(json);
  } catch (err) {
    console.warn("Failed to parse parameters: ".concat(err.message));
    return void 0;
  }
}
function tryParseBase64Payload(data) {
  try {
    return data ? decodeJsonParams(data) : void 0;
  } catch (err) {
    console.warn("Failed to parse parameters: ".concat(err.message));
    return void 0;
  }
}
var documentActions = [PublishAction, UnpublishAction, DiscardChangesAction, DuplicateAction, DeleteAction, HistoryRestoreAction];
var documentBadges = [LiveEditBadge];
var inspectors = [validationInspector, changesInspector];
var structureTool = definePlugin((options) => {
  const icon = (options == null ? void 0 : options.icon) || MasterDetailIcon;
  return { name: "sanity/structure", document: { actions: (prevActions) => {
    return Array.from(/* @__PURE__ */ new Set([...prevActions, ...documentActions]));
  }, badges: (prevBadges) => {
    return Array.from(/* @__PURE__ */ new Set([...prevBadges, ...documentBadges]));
  }, inspectors: (prevInspectors) => {
    return Array.from(/* @__PURE__ */ new Set([...prevInspectors, ...inspectors]));
  } }, plugins: [comments(), tasks()], tools: [{
    name: (options == null ? void 0 : options.name) || "structure",
    title: (options == null ? void 0 : options.title) || "Structure",
    icon,
    component: (0, import_react2.lazy)(() => import("./index-Bn6gWj4A-H54LYK22.js")),
    canHandleIntent: (intent, params) => {
      if (intent === "create")
        return canHandleCreateIntent(params);
      if (intent === "edit")
        return canHandleEditIntent(params);
      return false;
    },
    getIntentState,
    // Controlled by sanity/src/structure/components/structureTool/StructureTitle.tsx
    controlsDocumentTitle: true,
    options,
    router
  }], i18n: { bundles: [structureUsEnglishLocaleBundle] } };
});
function canHandleCreateIntent(params) {
  if (!("type" in params)) {
    return false;
  }
  return "template" in params ? { template: true } : true;
}
function canHandleEditIntent(params) {
  if (!("id" in params)) {
    return false;
  }
  return "mode" in params ? { mode: params.mode === "structure" } : true;
}
function StructureToolProvider(_ref148) {
  let { defaultDocumentNode, structure: resolveStructure, children } = _ref148;
  const [layoutCollapsed, setLayoutCollapsed] = (0, import_react2.useState)(false);
  const source = useSource();
  const configContext = useConfigContextFromSource(source);
  const documentStore = useDocumentStore();
  const S = (0, import_react2.useMemo)(() => {
    return createStructureBuilder({ defaultDocumentNode, source });
  }, [defaultDocumentNode, source]);
  const rootPaneNode = (0, import_react2.useMemo)(() => {
    if (resolveStructure)
      return resolveStructure(S, { ...configContext, documentStore });
    return S.defaults();
  }, [S, resolveStructure, configContext, documentStore]);
  const features = (0, import_react2.useMemo)(() => ({ backButton: layoutCollapsed, resizablePanes: !layoutCollapsed, reviewChanges: !layoutCollapsed, splitPanes: !layoutCollapsed, splitViews: !layoutCollapsed }), [layoutCollapsed]);
  const structureTool2 = (0, import_react2.useMemo)(() => {
    return { features, layoutCollapsed, setLayoutCollapsed, rootPaneNode, structureContext: S.context };
  }, [features, layoutCollapsed, rootPaneNode, S.context]);
  return (0, import_jsx_runtime.jsx)(StructureToolContext.Provider, { value: structureTool2, children });
}

export {
  require_template,
  require_isNumber,
  require_camelCase,
  require_kebabCase,
  CommentsIntentProvider,
  structureLocaleNamespace,
  PaneRouterContext,
  BackLink,
  usePaneLayout,
  ChildLink,
  ParameterizedLink,
  ReferenceChildLink,
  usePaneRouter,
  ConfirmDeleteDialogContainer,
  Pane,
  usePane,
  PaneContent,
  PaneHeader,
  PaneLayout,
  PaneHeaderActions,
  PaneItem,
  _DEBUG,
  LOADING_PANE,
  useDocumentPane,
  LoadingPane,
  useStructureTool,
  useDocumentTitle,
  DocumentInspectorHeader,
  DocumentPaneProvider,
  DocumentPane,
  DocumentListPane,
  SerializeError,
  HELP_URL,
  maybeSerializeMenuItem,
  MenuItemBuilder,
  getOrderingMenuItem,
  getOrderingMenuItemsForSchemaType,
  maybeSerializeMenuItemGroup,
  MenuItemGroupBuilder,
  ComponentBuilder,
  GenericViewBuilder,
  maybeSerializeView,
  ComponentViewBuilder,
  FormViewBuilder,
  form,
  component,
  DocumentBuilder,
  documentFromEditor,
  documentFromEditorWithInitialValue,
  InitialValueTemplateItemBuilder,
  defaultInitialValueTemplateItems,
  maybeSerializeInitialValueTemplateItem,
  menuItemsFromInitialValueTemplateItems,
  DEFAULT_INTENT_HANDLER,
  defaultIntentChecker,
  shallowIntentChecker,
  GenericListBuilder,
  DocumentListBuilder,
  getTypeNamesFromFilter,
  ListBuilder,
  ListItemBuilder,
  DocumentListItemBuilder,
  isDocumentListItem,
  DocumentTypeListBuilder,
  createStructureBuilder,
  setActivePanes,
  structureTool,
  StructureToolProvider
};
//# sourceMappingURL=chunk-SVK3BVLO.js.map
